---
phase: 35-codemirror-yaml-editor-nanostores
plan: 02
type: execute
wave: 2
depends_on: ["35-01"]
files_modified:
  - src/components/tools/ComposeEditorPanel.tsx
  - src/components/tools/ComposeResultsPanel.tsx
  - src/components/tools/ComposeValidator.tsx
  - src/pages/tools/compose-validator/index.astro
autonomous: true
requirements:
  - EDIT-02
  - EDIT-06
  - EDIT-07

must_haves:
  truths:
    - "Clicking Analyze runs the full compose validation pipeline and writes enriched results to the nanostore"
    - "Pressing Cmd/Ctrl+Enter triggers the same analysis as clicking the button"
    - "The editor renders with YAML syntax highlighting in a dark theme"
    - "The layout is stacked on mobile and side-by-side on desktop"
    - "The React island uses client:only='react' and does not attempt SSR"
    - "The results panel reads from the nanostore and displays a placeholder before first analysis"
  artifacts:
    - path: "src/components/tools/ComposeEditorPanel.tsx"
      provides: "Editor panel with Analyze/Clear buttons and full compose validation pipeline"
      exports: ["default (ComposeEditorPanel)"]
    - path: "src/components/tools/ComposeResultsPanel.tsx"
      provides: "Results panel stub reading from composeResult nanostore"
      exports: ["default (ComposeResultsPanel)"]
    - path: "src/components/tools/ComposeValidator.tsx"
      provides: "Root React island composing editor + results in responsive grid"
      exports: ["default (ComposeValidator)"]
    - path: "src/pages/tools/compose-validator/index.astro"
      provides: "Astro page hosting the ComposeValidator React island"
      contains: "client:only=\"react\""
  key_links:
    - from: "src/components/tools/ComposeEditorPanel.tsx"
      to: "src/lib/tools/compose-validator/use-codemirror-yaml.ts"
      via: "useCodeMirrorYaml hook for editor creation"
      pattern: "import.*useCodeMirrorYaml"
    - from: "src/components/tools/ComposeEditorPanel.tsx"
      to: "src/lib/tools/compose-validator/parser.ts"
      via: "parseComposeYaml call in analyze pipeline"
      pattern: "parseComposeYaml"
    - from: "src/components/tools/ComposeEditorPanel.tsx"
      to: "src/lib/tools/compose-validator/engine.ts"
      via: "runComposeEngine call in analyze pipeline"
      pattern: "runComposeEngine"
    - from: "src/components/tools/ComposeEditorPanel.tsx"
      to: "src/lib/tools/compose-validator/scorer.ts"
      via: "computeComposeScore call in analyze pipeline"
      pattern: "computeComposeScore"
    - from: "src/components/tools/ComposeEditorPanel.tsx"
      to: "src/stores/composeValidatorStore.ts"
      via: "write composeResult, composeAnalyzing, composeResultsStale atoms"
      pattern: "composeResult\\.set"
    - from: "src/components/tools/ComposeResultsPanel.tsx"
      to: "src/stores/composeValidatorStore.ts"
      via: "useStore reads composeResult, composeAnalyzing, composeResultsStale"
      pattern: "useStore.*compose"
    - from: "src/pages/tools/compose-validator/index.astro"
      to: "src/components/tools/ComposeValidator.tsx"
      via: "client:only='react' directive"
      pattern: "client:only.*react"
---

<objective>
Wire the compose validation pipeline into React components and an Astro page so users can edit YAML, trigger analysis, and see results.

Purpose: This is the user-facing integration that connects the Phase 33-34 validation engine to the Phase 35-01 CodeMirror hook and nanostores. After this plan, users can visit /tools/compose-validator/, see the sample compose file with YAML highlighting, click Analyze (or press Cmd/Ctrl+Enter), and see results flowing to the results panel.

Output: 3 React components + 1 Astro page = working compose validator tool at /tools/compose-validator/
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-codemirror-yaml-editor-nanostores/35-RESEARCH.md
@.planning/phases/35-codemirror-yaml-editor-nanostores/35-01-SUMMARY.md

# Existing patterns to follow (Dockerfile Analyzer):
@src/components/tools/DockerfileAnalyzer.tsx
@src/components/tools/EditorPanel.tsx
@src/pages/tools/dockerfile-analyzer/index.astro

# Phase 35-01 outputs (from previous plan):
@src/stores/composeValidatorStore.ts
@src/lib/tools/compose-validator/use-codemirror-yaml.ts
@src/lib/tools/compose-validator/sample-compose.ts

# Compose validation pipeline:
@src/lib/tools/compose-validator/types.ts
@src/lib/tools/compose-validator/parser.ts
@src/lib/tools/compose-validator/engine.ts
@src/lib/tools/compose-validator/scorer.ts
@src/lib/tools/compose-validator/rules/index.ts
@src/lib/tools/compose-validator/rules/schema/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ComposeEditorPanel, ComposeResultsPanel, and ComposeValidator React components</name>
  <files>
    src/components/tools/ComposeEditorPanel.tsx
    src/components/tools/ComposeResultsPanel.tsx
    src/components/tools/ComposeValidator.tsx
  </files>
  <action>
**ComposeEditorPanel.tsx** -- Follow the existing `EditorPanel.tsx` pattern precisely, with these compose-specific adaptations:

1. Import the compose-specific hook and modules:
   - `useCodeMirrorYaml` from `../../lib/tools/compose-validator/use-codemirror-yaml`
   - `parseComposeYaml` from `../../lib/tools/compose-validator/parser`
   - `runComposeEngine` from `../../lib/tools/compose-validator/engine`
   - `computeComposeScore` from `../../lib/tools/compose-validator/scorer`
   - `getComposeRuleById` from `../../lib/tools/compose-validator/rules`
   - `getSchemaRuleById` from `../../lib/tools/compose-validator/rules/schema`
   - `SAMPLE_COMPOSE` from `../../lib/tools/compose-validator/sample-compose`
   - `setDiagnostics` and `Diagnostic` type from `@codemirror/lint`
   - Nanostore atoms: `composeResult`, `composeAnalyzing`, `composeResultsStale` from `../../stores/composeValidatorStore`

2. Create an `analyzeRef` using `useRef` to hold the analyze callback (avoids stale closures -- same pattern as EditorPanel.tsx). Update `analyzeRef.current` on every render.

3. The `analyzeRef.current` function (the analysis pipeline):
   a. Get content from `view.state.doc.toString()`
   b. If empty, dispatch empty diagnostics and set result to null, return
   c. Set `composeResultsStale.set(false)` and `composeAnalyzing.set(true)`
   d. Call `parseComposeYaml(content)` -> `runComposeEngine(parseResult, content)` -> `computeComposeScore(violations)`
   e. Convert violations to CodeMirror Diagnostics:
      - For each violation, look up rule via `getComposeRuleById(v.ruleId) ?? getSchemaRuleById(v.ruleId)` (CRITICAL: dual registry lookup covers all 52 rules)
      - Map severity: error -> 'error', warning -> 'warning', else -> 'info'
      - **CLAMP line numbers**: `Math.min(v.line, view.state.doc.lines)` to prevent "Position out of range" crash
      - Compute `from` as `line.from + (v.column - 1)`, `to` as endLine's `line.to` or current `line.to`
      - Set `source: 'compose-validator'`
   f. Dispatch `setDiagnostics(view.state, diagnostics)` to the editor
   g. Enrich violations with metadata (severity, category, title, explanation, fix) from dual registry lookup
   h. Write enriched result to nanostore: `composeResult.set({ violations: enriched, score, parseSuccess: parseResult.parseSuccess, timestamp: Date.now() })`
   i. Wrap the pipeline in try/catch -- on error, set empty diagnostics and a zero-score result with `parseSuccess: false` (same as Dockerfile Analyzer error handling)
   j. Set `composeAnalyzing.set(false)` in finally or after try/catch

4. Call `useCodeMirrorYaml({ initialDoc: SAMPLE_COMPOSE, onAnalyze: () => { if (viewRef.current) analyzeRef.current(viewRef.current); } })` to get `containerRef` and `viewRef`.

5. **No URL hash decoding** for now (SHARE-01/SHARE-02 are in Phase 37, deferred). Use `SAMPLE_COMPOSE` as initial doc directly.

6. Render the same layout as EditorPanel.tsx:
   - Header row with "Editor" h2 and Clear + Analyze buttons
   - Clear button resets editor content, clears diagnostics, nulls result, resets stale
   - Analyze button calls `analyzeRef.current(viewRef.current)` via useCallback
   - Add keyboard shortcut hint text below buttons: `<span className="text-xs text-[var(--color-text-secondary)] hidden sm:inline">Cmd/Ctrl+Enter</span>` (visible on desktop only)
   - Editor container div with `ref={containerRef}`
   - Use same Tailwind classes as EditorPanel: flex-col, min-h-[300px]/[450px], rounded-lg, etc.

**ComposeResultsPanel.tsx** -- Create a STUB results panel that will be fleshed out in Phase 36 (RESULT-* requirements). For now:

1. Import `useStore` from `@nanostores/react`
2. Import `composeResult`, `composeAnalyzing`, `composeResultsStale` from `../../stores/composeValidatorStore`
3. Read all three atoms with `useStore()`
4. Render:
   - If `analyzing`: show "Analyzing..." text with a subtle pulse animation
   - If `result === null`: show "Click Analyze to validate your Docker Compose file" placeholder
   - If `result !== null`: show a summary card with:
     - Score: `result.score.overall` and `result.score.grade`
     - Violation count: `result.violations.length`
     - Parse success indicator
     - If `stale`: show a "Results may be stale -- click Analyze to refresh" banner
   - Style with the same dark theme classes used in the Dockerfile Analyzer
5. This is intentionally minimal -- Phase 36 adds the full ScoreGauge, CategoryBreakdown, ViolationList, and graph tabs.

**ComposeValidator.tsx** -- Follow the exact `DockerfileAnalyzer.tsx` pattern:

1. Import `ComposeEditorPanel` and `ComposeResultsPanel`
2. Export default function with responsive grid: `grid grid-cols-1 lg:grid-cols-2 gap-4 lg:gap-6`
3. Editor panel in `min-h-[350px] lg:min-h-[500px]` wrapper
4. Results panel in `min-h-[200px] lg:min-h-[500px]` wrapper
5. Add JSDoc comment referencing EDIT-06 (responsive layout requirement)
  </action>
  <verify>
  Run `npx tsc --noEmit` to verify all three components compile. Verify `ComposeEditorPanel.tsx` contains `parseComposeYaml`, `runComposeEngine`, `computeComposeScore`, `getComposeRuleById`, `getSchemaRuleById` imports. Verify `ComposeValidator.tsx` uses `grid-cols-1 lg:grid-cols-2`.
  </verify>
  <done>
  ComposeEditorPanel.tsx wires the full validation pipeline (parse -> engine -> score -> enrich -> nanostore + diagnostics) with dual registry lookup, line clamping, and Analyze/Clear buttons. ComposeResultsPanel.tsx reads from nanostore and shows score summary or placeholder. ComposeValidator.tsx composes both in a responsive grid. All pass TypeScript strict mode.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Astro page at /tools/compose-validator/ with client:only="react" island</name>
  <files>
    src/pages/tools/compose-validator/index.astro
  </files>
  <action>
Create `src/pages/tools/compose-validator/index.astro` following the existing `dockerfile-analyzer/index.astro` pattern:

1. **Frontmatter imports**:
   - `Layout` from `../../../layouts/Layout.astro`
   - `ComposeValidator` from `../../../components/tools/ComposeValidator`

2. **Layout props**:
   - `title`: "Docker Compose Validator | Patryk Golabek"
   - `description`: "Free Docker Compose validator and best-practice analyzer by a Kubernetes architect. 52 rules across schema, semantic, security, best-practice, and style categories. 100% browser-based -- your code never leaves your device."
   - Do NOT set ogImage yet (Phase 40 handles OG images)

3. **Page structure**:
   - `<section>` with `max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8 sm:py-12`
   - `<h1>` with "Docker Compose Validator" using `text-3xl sm:text-4xl font-heading font-bold mb-2 text-[var(--color-text-primary)]`
   - `<p>` intro text: "Paste your docker-compose.yml below and click **Analyze**. 100% client-side, your code never leaves your browser."
   - `<ComposeValidator client:only="react" />` -- CRITICAL: must be `client:only="react"`, NOT `client:load` or `client:visible` (CodeMirror cannot be SSR'd)

4. **Do NOT add** JSON-LD, breadcrumbs, blog post cross-links, or companion guide links yet -- those are Phase 39 (SITE-*) and Phase 40 (CONTENT-*) requirements. Keep the page minimal and focused on the editor.

5. Verify the route works by checking that `src/pages/tools/compose-validator/index.astro` would produce the URL `/tools/compose-validator/`.
  </action>
  <verify>
  Run `npm run build` to verify the page builds without errors. Check that `dist/tools/compose-validator/index.html` exists in the build output. Verify the HTML contains `client:only="react"` hydration marker (or the equivalent Astro client directive output).
  </verify>
  <done>
  The Astro page at /tools/compose-validator/ renders the ComposeValidator React island with client:only="react". The page builds successfully, has proper title/description meta tags, and the editor appears with YAML highlighting when viewed in a browser. The build output includes dist/tools/compose-validator/index.html.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes with zero errors
2. `dist/tools/compose-validator/index.html` exists
3. `npx tsc --noEmit` passes
4. Opening the dev server at localhost:4321/tools/compose-validator/ shows:
   - A CodeMirror editor with the sample compose file and YAML syntax highlighting
   - An "Analyze" button and "Clear" button
   - Clicking Analyze populates the results panel with score and violations
   - Pressing Cmd/Ctrl+Enter triggers the same analysis
   - The layout stacks vertically on mobile and goes side-by-side on desktop (lg breakpoint)
</verification>

<success_criteria>
- ComposeEditorPanel runs the full parse -> engine -> score -> enrich -> nanostore pipeline on Analyze click
- ComposeEditorPanel supports Cmd/Ctrl+Enter keyboard shortcut
- ComposeResultsPanel reads from nanostore and shows score summary or placeholder
- ComposeValidator renders both panels in a responsive grid
- Astro page uses client:only="react" and builds successfully
- The tool page is accessible at /tools/compose-validator/
</success_criteria>

<output>
After completion, create `.planning/phases/35-codemirror-yaml-editor-nanostores/35-02-SUMMARY.md`
</output>
