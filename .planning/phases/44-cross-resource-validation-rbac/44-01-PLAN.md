---
phase: 44-cross-resource-validation-rbac
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/lib/tools/k8s-analyzer/rules/cross-resource/well-known-resources.ts
  - src/lib/tools/k8s-analyzer/rules/cross-resource/KA-X001-service-selector-mismatch.ts
  - src/lib/tools/k8s-analyzer/rules/cross-resource/KA-X002-ingress-undefined-service.ts
  - src/lib/tools/k8s-analyzer/rules/cross-resource/KA-X003-configmap-not-found.ts
  - src/lib/tools/k8s-analyzer/rules/cross-resource/KA-X004-secret-not-found.ts
  - src/lib/tools/k8s-analyzer/rules/cross-resource/KA-X005-pvc-not-found.ts
  - src/lib/tools/k8s-analyzer/rules/cross-resource/KA-X006-serviceaccount-not-found.ts
  - src/lib/tools/k8s-analyzer/rules/cross-resource/KA-X007-networkpolicy-no-match.ts
  - src/lib/tools/k8s-analyzer/rules/cross-resource/KA-X008-hpa-target-not-found.ts
  - src/lib/tools/k8s-analyzer/rules/cross-resource/index.ts
autonomous: true

must_haves:
  truths:
    - "A Service whose selector matches no Pod template in any workload resource in the same namespace produces a warning"
    - "An Ingress referencing a Service name not present in the manifest (including defaultBackend) produces a warning"
    - "ConfigMap, Secret, and PVC references from volumes, envFrom, and env.valueFrom that are not defined in the manifest produce info-level diagnostics"
    - "A ServiceAccount referenced by a workload that does not exist in the manifest produces a warning"
    - "A NetworkPolicy whose podSelector.matchLabels matches no Pod template in the same namespace produces an info diagnostic"
    - "An HPA targeting a non-existent resource produces a warning"
    - "Well-known system resources (default ServiceAccount, kube-root-ca.crt ConfigMap) do NOT produce false positives"
  artifacts:
    - path: "src/lib/tools/k8s-analyzer/rules/cross-resource/well-known-resources.ts"
      provides: "Whitelist Sets for ConfigMaps, ServiceAccounts, Secrets, Services, PVCs"
      exports: ["WELL_KNOWN_CONFIGMAPS", "WELL_KNOWN_SERVICE_ACCOUNTS", "WELL_KNOWN_SECRETS", "WELL_KNOWN_SERVICES", "WELL_KNOWN_PVCS"]
    - path: "src/lib/tools/k8s-analyzer/rules/cross-resource/KA-X001-service-selector-mismatch.ts"
      provides: "Service selector vs Pod template label matching rule"
      exports: ["KAX001"]
    - path: "src/lib/tools/k8s-analyzer/rules/cross-resource/KA-X002-ingress-undefined-service.ts"
      provides: "Ingress -> Service reference validation rule"
      exports: ["KAX002"]
    - path: "src/lib/tools/k8s-analyzer/rules/cross-resource/KA-X003-configmap-not-found.ts"
      provides: "ConfigMap reference validation (volumes, envFrom, env valueFrom)"
      exports: ["KAX003"]
    - path: "src/lib/tools/k8s-analyzer/rules/cross-resource/KA-X004-secret-not-found.ts"
      provides: "Secret reference validation (volumes with secretName, envFrom, env valueFrom)"
      exports: ["KAX004"]
    - path: "src/lib/tools/k8s-analyzer/rules/cross-resource/KA-X005-pvc-not-found.ts"
      provides: "PVC reference validation (persistentVolumeClaim.claimName)"
      exports: ["KAX005"]
    - path: "src/lib/tools/k8s-analyzer/rules/cross-resource/KA-X006-serviceaccount-not-found.ts"
      provides: "ServiceAccount reference validation (pod-level serviceAccountName)"
      exports: ["KAX006"]
    - path: "src/lib/tools/k8s-analyzer/rules/cross-resource/KA-X007-networkpolicy-no-match.ts"
      provides: "NetworkPolicy podSelector matching rule"
      exports: ["KAX007"]
    - path: "src/lib/tools/k8s-analyzer/rules/cross-resource/KA-X008-hpa-target-not-found.ts"
      provides: "HPA scaleTargetRef validation rule"
      exports: ["KAX008"]
    - path: "src/lib/tools/k8s-analyzer/rules/cross-resource/index.ts"
      provides: "crossResourceRules aggregation array"
      exports: ["crossResourceRules"]
  key_links:
    - from: "src/lib/tools/k8s-analyzer/rules/cross-resource/KA-X001-service-selector-mismatch.ts"
      to: "src/lib/tools/k8s-analyzer/types.ts"
      via: "K8sRuleContext.resources iteration with TEMPLATE_LABEL_PATHS for Pod template labels"
      pattern: "TEMPLATE_LABEL_PATHS"
    - from: "src/lib/tools/k8s-analyzer/rules/cross-resource/KA-X003-configmap-not-found.ts"
      to: "src/lib/tools/k8s-analyzer/container-helpers.ts"
      via: "getPodSpec + getContainerSpecs for all three reference locations"
      pattern: "getPodSpec|getContainerSpecs"
    - from: "src/lib/tools/k8s-analyzer/rules/cross-resource/well-known-resources.ts"
      to: "KA-X003/X004/X005/X006 rule files"
      via: "WELL_KNOWN_* Set imports for false positive suppression"
      pattern: "WELL_KNOWN_"
---

<objective>
Implement all 8 cross-resource validation rules (KA-X001 through KA-X008) that check references between Kubernetes resources in the same manifest.

Purpose: Cross-resource validation catches integration errors (dangling Service selectors, missing ConfigMap/Secret references, broken Ingress backends) that single-resource rules cannot detect. These rules use the ResourceRegistry built in Phase 41 to perform O(1) lookups by kind/namespace/name.

Output: 8 rule files, 1 well-known resources whitelist, 1 category index -- all in `rules/cross-resource/` directory.
</objective>

<execution_context>
@/Users/patrykattc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrykattc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/44-cross-resource-validation-rbac/44-RESEARCH.md

# Existing patterns to follow exactly:
@src/lib/tools/k8s-analyzer/types.ts
@src/lib/tools/k8s-analyzer/container-helpers.ts
@src/lib/tools/k8s-analyzer/resource-registry.ts
@src/lib/tools/k8s-analyzer/parser.ts
@src/lib/tools/k8s-analyzer/rules/security/KA-C001-privileged-container.ts
@src/lib/tools/k8s-analyzer/rules/security/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create well-known resources whitelist and cross-resource rules KA-X001 through KA-X004</name>
  <files>
    src/lib/tools/k8s-analyzer/rules/cross-resource/well-known-resources.ts
    src/lib/tools/k8s-analyzer/rules/cross-resource/KA-X001-service-selector-mismatch.ts
    src/lib/tools/k8s-analyzer/rules/cross-resource/KA-X002-ingress-undefined-service.ts
    src/lib/tools/k8s-analyzer/rules/cross-resource/KA-X003-configmap-not-found.ts
    src/lib/tools/k8s-analyzer/rules/cross-resource/KA-X004-secret-not-found.ts
  </files>
  <action>
    Create the `rules/cross-resource/` directory and implement:

    **well-known-resources.ts:** Export 5 `Set<string>` constants:
    - `WELL_KNOWN_CONFIGMAPS`: `['kube-root-ca.crt']` (rootcacertpublisher controller)
    - `WELL_KNOWN_SERVICE_ACCOUNTS`: `['default']` (auto-created per namespace)
    - `WELL_KNOWN_SECRETS`: empty Set (no universal well-known secrets)
    - `WELL_KNOWN_SERVICES`: empty Set (no auto-created user-namespace services)
    - `WELL_KNOWN_PVCS`: empty Set (no auto-created PVCs)

    **KA-X001 (Service selector mismatch):**
    - Iterate `ctx.resources`, filter `kind === 'Service'`
    - Extract `spec.selector` (simple key-value map, NOT matchLabels)
    - Skip services with no selector or empty selector (headless services)
    - For each service, check all workload resources (Pod, Deployment, StatefulSet, DaemonSet, Job, CronJob) in the SAME namespace
    - Use `TEMPLATE_LABEL_PATHS` map for pod template label location per kind:
      - Pod: `/metadata/labels`
      - Deployment/StatefulSet/DaemonSet/Job: `/spec/template/metadata/labels`
      - CronJob: `/spec/jobTemplate/spec/template/metadata/labels`
    - Write a `getNestedValue(obj, path)` helper to navigate JSON by path segments
    - Match means ALL selector entries exist in template labels (subset match)
    - If no workload matches, emit warning at `/spec/selector` with message including service name, selector JSON, and namespace
    - severity: 'warning', category: 'cross-resource'

    **KA-X002 (Ingress references undefined Service):**
    - Iterate `ctx.resources`, filter `kind === 'Ingress'`
    - Check TWO locations for service references:
      1. `spec.rules[*].http.paths[*].backend.service.name` (standard)
      2. `spec.defaultBackend.service.name` (default backend)
    - For each service name found, skip if in `WELL_KNOWN_SERVICES`
    - Use `ctx.registry.getByName('Service', resource.namespace, serviceName)` for O(1) lookup
    - If not found, emit warning at the specific JSON path of the service name reference
    - severity: 'warning', category: 'cross-resource'

    **KA-X003 (ConfigMap reference not found):**
    - Use `getPodSpec(resource)` and `getContainerSpecs(resource)` from container-helpers.ts
    - Scan THREE reference locations:
      1. `podSpec.volumes[*].configMap.name`
      2. `container.envFrom[*].configMapRef.name`
      3. `container.env[*].valueFrom.configMapKeyRef.name`
    - Skip names in `WELL_KNOWN_CONFIGMAPS`
    - Deduplicate by name per resource: if the same ConfigMap name is referenced multiple times in one resource, emit only ONE violation pointing to the first occurrence
    - Use `ctx.registry.getByName('ConfigMap', resource.namespace, name)` for lookup
    - severity: 'info', category: 'cross-resource'

    **KA-X004 (Secret reference not found):**
    - Same pattern as KA-X003 but for Secrets. CRITICAL difference in volume path:
      - Volumes use `volumes[*].secret.secretName` (NOT `secret.name` -- K8s uses `secretName` for volume secrets)
      - envFrom uses `envFrom[*].secretRef.name`
      - env uses `env[*].valueFrom.secretKeyRef.name`
    - Skip names in `WELL_KNOWN_SECRETS`
    - Deduplicate by name per resource (same as KA-X003)
    - severity: 'info', category: 'cross-resource'

    Each rule must follow the exact pattern from KA-C001: import types from `../../types`, import parser helpers from `../../parser`, export a named const implementing `K8sLintRule` with id, title, severity, category, explanation, fix (with before/after code), and check() method.

    For explanation text, describe what the rule checks and why dangling references are problematic (deployment failures, runtime errors). For fix text, show the missing resource that should be added to the manifest.
  </action>
  <verify>
    Run `npx tsc --noEmit` from the project root. All 5 new files compile without errors. Verify each file exports the correct named constant.
  </verify>
  <done>
    5 files exist in `rules/cross-resource/`: well-known-resources.ts exports 5 Set constants; KA-X001 through KA-X004 each export a K8sLintRule with check() method, correct severity/category, explanation, and fix.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create cross-resource rules KA-X005 through KA-X008 and category index</name>
  <files>
    src/lib/tools/k8s-analyzer/rules/cross-resource/KA-X005-pvc-not-found.ts
    src/lib/tools/k8s-analyzer/rules/cross-resource/KA-X006-serviceaccount-not-found.ts
    src/lib/tools/k8s-analyzer/rules/cross-resource/KA-X007-networkpolicy-no-match.ts
    src/lib/tools/k8s-analyzer/rules/cross-resource/KA-X008-hpa-target-not-found.ts
    src/lib/tools/k8s-analyzer/rules/cross-resource/index.ts
  </files>
  <action>
    **KA-X005 (PVC reference not found):**
    - Scan `podSpec.volumes[*].persistentVolumeClaim.claimName`
    - Only location is in volumes (PVCs are not referenced via envFrom/env)
    - Skip names in `WELL_KNOWN_PVCS`
    - Use `ctx.registry.getByName('PersistentVolumeClaim', resource.namespace, claimName)` for lookup
    - severity: 'info', category: 'cross-resource'

    **KA-X006 (ServiceAccount reference not found):**
    - Use `getPodSpec(resource)` to get pod-level spec
    - Check `podSpec.serviceAccountName` (pod-level field, NOT container-level)
    - Skip if serviceAccountName is not defined (K8s defaults to 'default')
    - Skip names in `WELL_KNOWN_SERVICE_ACCOUNTS` (notably 'default')
    - Use `ctx.registry.getByName('ServiceAccount', resource.namespace, name)` for lookup
    - severity: 'warning', category: 'cross-resource'

    **KA-X007 (NetworkPolicy selector matches no Pod):**
    - Iterate `ctx.resources`, filter `kind === 'NetworkPolicy'`
    - Extract `spec.podSelector.matchLabels`
    - Skip if podSelector is empty (`{}`) or has no matchLabels -- empty selector intentionally matches all pods
    - For each non-empty podSelector, check all workload resources in the SAME namespace
    - Reuse the `TEMPLATE_LABEL_PATHS` pattern from KA-X001 to find pod template labels
    - If no workload resource has template labels matching ALL matchLabels entries, emit info
    - severity: 'info', category: 'cross-resource'

    **KA-X008 (HPA targets non-existent resource):**
    - Iterate `ctx.resources`, filter `kind === 'HorizontalPodAutoscaler'`
    - Extract `spec.scaleTargetRef.kind` and `spec.scaleTargetRef.name`
    - The HPA namespace is the same namespace as the target resource
    - Use `ctx.registry.getByName(targetKind, resource.namespace, targetName)` for lookup
    - If targetKind is not in the GVK registry (e.g., a CRD), skip the check gracefully (do NOT flag as missing)
    - severity: 'warning', category: 'cross-resource'

    **index.ts (category aggregation):**
    - Follow exact pattern from `rules/security/index.ts` and `rules/reliability/index.ts`
    - Import all 8 rule exports: KAX001 through KAX008
    - Export `crossResourceRules: K8sLintRule[]` array containing all 8 rules in order
    - JSDoc comment: `/** All 8 cross-resource validation rules for K8s manifest analysis. */`
  </action>
  <verify>
    Run `npx tsc --noEmit` from the project root. All 5 new files compile without errors. The `crossResourceRules` array contains exactly 8 entries.
  </verify>
  <done>
    KA-X005 through KA-X008 each export a K8sLintRule; `cross-resource/index.ts` exports `crossResourceRules` array with all 8 rules. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. All 10 files exist in `src/lib/tools/k8s-analyzer/rules/cross-resource/`
3. Each rule file exports a named K8sLintRule const with id matching `KA-X0XX` pattern
4. Each rule has severity, category: 'cross-resource', explanation, fix, and check() method
5. `crossResourceRules` array in index.ts contains exactly 8 rules
6. Well-known resources whitelist suppresses false positives for 'default' SA and 'kube-root-ca.crt' ConfigMap
7. KA-X001 uses TEMPLATE_LABEL_PATHS with CronJob special path `/spec/jobTemplate/spec/template/metadata/labels`
8. KA-X004 uses `secretName` (not `name`) for volume secret references
9. KA-X003/X004 deduplicate by name per resource
10. KA-X007 skips empty podSelector
</verification>

<success_criteria>
- 8 cross-resource rules compile and implement K8sLintRule interface
- Well-known resources whitelist prevents false positives for system resources
- All cross-resource reference locations are covered (volumes, envFrom, env.valueFrom)
- Namespace scoping is correct in all registry lookups
- Category index exports crossResourceRules array with 8 entries
</success_criteria>

<output>
After completion, create `.planning/phases/44-cross-resource-validation-rbac/44-01-SUMMARY.md`
</output>
