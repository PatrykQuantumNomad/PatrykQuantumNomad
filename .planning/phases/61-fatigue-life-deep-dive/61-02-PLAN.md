---
phase: 61-fatigue-life-deep-dive
plan: 02
type: execute
wave: 2
depends_on: [61-01]
files_modified:
  - src/lib/eda/math/distribution-math.ts
  - src/lib/eda/svg-generators/probability-plot.ts
  - src/components/eda/FatigueLifePlots.astro
  - src/data/eda/pages/case-studies/fatigue-life.mdx
autonomous: true
requirements: [FAT-02, FAT-03]

must_haves:
  truths:
    - "Gamma probability plot renders correctly with shape=11.85, scale=118.2 showing data points near the reference line"
    - "Weibull probability plot renders correctly with location-shifted data (subtract 181) showing Weibull fit"
    - "All 6 quantitative test subsections exist with computed test statistics and conclusions"
    - "Test Summary table shows pass/fail for location, variation, randomness, distribution, and outlier tests"
  artifacts:
    - path: "src/lib/eda/math/distribution-math.ts"
      provides: "gammaQuantile function for inverse gamma CDF via bisection"
      contains: "gammaQuantile"
    - path: "src/lib/eda/svg-generators/probability-plot.ts"
      provides: "gamma probability plot type"
      contains: "case 'gamma'"
    - path: "src/components/eda/FatigueLifePlots.astro"
      provides: "weibull-probability and gamma-probability plot types plus computed test statistics"
      contains: "weibull-probability"
    - path: "src/data/eda/pages/case-studies/fatigue-life.mdx"
      provides: "Distribution comparison plots and quantitative test battery"
      contains: "### Test Summary"
  key_links:
    - from: "src/lib/eda/svg-generators/probability-plot.ts"
      to: "src/lib/eda/math/distribution-math.ts"
      via: "import gammaQuantile"
      pattern: "import.*gammaQuantile.*distribution-math"
    - from: "src/components/eda/FatigueLifePlots.astro"
      to: "src/lib/eda/svg-generators/probability-plot.ts"
      via: "generateProbabilityPlot with type gamma/weibull"
      pattern: "generateProbabilityPlot.*type.*gamma"
    - from: "src/components/eda/FatigueLifePlots.astro"
      to: "src/lib/eda/math/statistics"
      via: "import test functions for quantitative battery"
      pattern: "import.*locationTest.*statistics"
    - from: "src/data/eda/pages/case-studies/fatigue-life.mdx"
      to: "src/components/eda/FatigueLifePlots.astro"
      via: "component calls for new plot types and computed stats"
      pattern: "FatigueLifePlots type=\"weibull-probability\""
---

<objective>
Add gamma probability plot engineering, wire Weibull/gamma probability plots into FatigueLifePlots, add distribution comparison subsections to MDX, compute and present the full quantitative test battery.

Purpose: FAT-02 requires quantitative results with distribution fitting tests and Test Summary table. FAT-03 requires Weibull and gamma probability plots with fitted overlays. This plan handles all engineering (gamma quantile function, gamma probability plot renderer) and all quantitative content (6 test subsections + Test Summary).

Output: Working gamma probability plot type, Weibull/gamma distribution comparison subsections in MDX, complete quantitative test battery with Test Summary table
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/61-fatigue-life-deep-dive/61-RESEARCH.md
@src/lib/eda/math/distribution-math.ts
@src/lib/eda/svg-generators/probability-plot.ts
@src/components/eda/FatigueLifePlots.astro
@src/data/eda/pages/case-studies/fatigue-life.mdx
@.planning/phases/61-fatigue-life-deep-dive/61-01-SUMMARY.md
</context>

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/lib/eda/svg-generators/probability-plot.ts:
```typescript
export interface ProbabilityPlotOptions {
  data: number[];
  type?: 'normal' | 'qq' | 'weibull' | 'ppcc' | 'uniform';
  config?: Partial<PlotConfig>;
  title?: string;
  xLabel?: string;
  yLabel?: string;
}
// Must be extended with: 'gamma' type, gammaShape, gammaScale options
```

From src/lib/eda/math/distribution-math.ts (private function, NOT exported):
```typescript
function lowerIncompleteGammaRatio(a: number, x: number): number { ... }
// gammaQuantile must be added IN THIS FILE since it needs access to this private function
```

From src/lib/eda/math/statistics.ts (all already exported):
```typescript
export function locationTest(data: number[]): { t: number; df: number; tCritical: number; reject: boolean; }
export function bartlettTest(data: number[], k: number): { T: number; chiCritical: number; reject: boolean; }
export function runsTest(data: number[]): { Z: number; reject: boolean; }
export function autocorrelation(data: number[]): number[]
export function andersonDarlingNormal(data: number[]): { A2: number; reject: boolean; }
export function ppccNormal(data: number[]): number
export function grubbsTest(data: number[]): { G: number; tCritical: number; reject: boolean; }
```

From src/components/eda/FatigueLifePlots.astro:
```typescript
type PlotType =
  | '4-plot' | 'run-sequence' | 'lag' | 'histogram'
  | 'normal-probability' | 'box-plot'
  | 'autocorrelation' | 'spectral';
// Must be extended with: 'weibull-probability' | 'gamma-probability'
```
</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Add gammaQuantile to distribution-math.ts and gamma probability plot to probability-plot.ts</name>
  <files>
    src/lib/eda/math/distribution-math.ts
    src/lib/eda/svg-generators/probability-plot.ts
  </files>
  <action>
**Step 1: Add gammaQuantile function to distribution-math.ts**

Add the following exported function INSIDE distribution-math.ts (it needs access to the private `lowerIncompleteGammaRatio` function). Place it after the `lowerIncompleteGammaRatio` function and before the `regularizedBeta` function.

```typescript
/**
 * Inverse CDF of the gamma distribution via bisection on lowerIncompleteGammaRatio.
 * Returns x such that P(X <= x) = p for Gamma(shape, scale).
 * Uses scale parameterization: mean = shape * scale.
 */
export function gammaQuantile(p: number, shape: number, scale: number = 1): number {
  if (p <= 0) return 0;
  if (p >= 1) return Infinity;

  // Initial bracket: [0, generous_upper]
  let lo = 0;
  let hi = Math.max(shape * scale * 5, 100);

  // Ensure upper bracket is high enough
  while (lowerIncompleteGammaRatio(shape, hi / scale) < p) {
    hi *= 2;
  }

  // Bisection search
  for (let iter = 0; iter < 100; iter++) {
    const mid = (lo + hi) / 2;
    const cdf = lowerIncompleteGammaRatio(shape, mid / scale);
    if (cdf < p) lo = mid;
    else hi = mid;
    if ((hi - lo) / Math.max(1, lo) < 1e-10) break;
  }
  return (lo + hi) / 2;
}
```

**Step 2: Add 'gamma' type to probability-plot.ts**

2a. Add import for gammaQuantile at the top of probability-plot.ts:
```typescript
import { gammaQuantile } from '../math/distribution-math';
```

2b. Extend the ProbabilityPlotOptions interface type union and add gamma options:
```typescript
export interface ProbabilityPlotOptions {
  data: number[];
  type?: 'normal' | 'qq' | 'weibull' | 'ppcc' | 'uniform' | 'gamma';
  gammaShape?: number;  // required when type = 'gamma'
  gammaScale?: number;  // required when type = 'gamma'
  config?: Partial<PlotConfig>;
  title?: string;
  xLabel?: string;
  yLabel?: string;
}
```

2c. Add `case 'gamma'` to the switch statement in `generateProbabilityPlot`:
```typescript
case 'gamma':
  return renderGamma(data, options, config);
```

2d. Add the `renderGamma` function. Follow the EXACT same pattern as `renderNormalProbability` but use gamma quantiles instead of normal quantiles:

```typescript
function renderGamma(
  data: number[],
  options: ProbabilityPlotOptions,
  config: PlotConfig,
): string {
  const { innerWidth, innerHeight } = innerDimensions(config);
  const { margin } = config;
  const shape = options.gammaShape ?? 2;
  const scale = options.gammaScale ?? 1;

  const sorted = [...data].sort((a, b) => a - b);
  const n = sorted.length;

  // Theoretical quantiles via Blom plotting position
  const theoretical: number[] = [];
  for (let i = 0; i < n; i++) {
    const p = (i + 1 - 0.375) / (n + 0.25);
    theoretical.push(gammaQuantile(p, shape, scale));
  }

  // Scales
  let [xMin, xMax] = extent(theoretical) as [number, number];
  if (xMin === xMax) { xMin -= 1; xMax += 1; }
  let [yMin, yMax] = extent(sorted) as [number, number];
  if (yMin === yMax) { yMin -= 1; yMax += 1; }

  const xScale = scaleLinear()
    .domain([xMin, xMax])
    .range([margin.left, margin.left + innerWidth])
    .nice();
  const yScale = scaleLinear()
    .domain([yMin, yMax])
    .range([margin.top + innerHeight, margin.top])
    .nice();

  // Grid
  const xTicks = xScale.ticks(7);
  const yTicks = yScale.ticks(5);
  const grid =
    gridLinesH(yTicks, yScale, margin.left, margin.left + innerWidth) +
    '\n' +
    gridLinesV(xTicks, xScale, margin.top, margin.top + innerHeight);

  // Data points
  const points = sorted
    .map(
      (v, i) =>
        `<circle cx="${xScale(theoretical[i]).toFixed(2)}" cy="${yScale(v).toFixed(2)}" r="3" fill="${PALETTE.dataPrimary}" fill-opacity="0.6" />`,
    )
    .join('\n');

  // Best-fit line
  const reg = linearRegression(theoretical, sorted);
  const f = (x: number) => reg.slope * x + reg.intercept;
  const xDomMin = xScale.domain()[0];
  const xDomMax = xScale.domain()[1];
  const fitLine = `<line x1="${xScale(xDomMin).toFixed(2)}" y1="${yScale(f(xDomMin)).toFixed(2)}" x2="${xScale(xDomMax).toFixed(2)}" y2="${yScale(f(xDomMax)).toFixed(2)}" stroke="${PALETTE.dataSecondary}" stroke-width="1.5" />`;

  const xLabel = options.xLabel ?? 'Gamma Theoretical Quantiles';
  const yLabel = options.yLabel ?? 'Sample Quantiles';

  return (
    svgOpen(config, `Gamma probability plot${options.title ? ': ' + options.title : ''}`) +
    grid + '\n' +
    points + '\n' +
    fitLine + '\n' +
    xAxis(xTicks, xScale, margin.top + innerHeight, xLabel, config) + '\n' +
    yAxis(yTicks, yScale, margin.left, yLabel, config) + '\n' +
    (options.title ? titleText(config, options.title) : '') +
    '</svg>'
  );
}
```
  </action>
  <verify>
    <automated>cd /Users/patrykattc/work/git/PatrykQuantumNomad && npx astro check 2>&1 | tail -5</automated>
  </verify>
  <done>
- `gammaQuantile` is exported from distribution-math.ts
- probability-plot.ts has `'gamma'` in the type union
- probability-plot.ts imports `gammaQuantile` from distribution-math
- `renderGamma` function exists and follows the same pattern as `renderNormalProbability`
- `npx astro check` reports 0 errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire new plot types into FatigueLifePlots, compute quantitative tests, add distribution comparison and test battery to MDX</name>
  <files>
    src/components/eda/FatigueLifePlots.astro
    src/data/eda/pages/case-studies/fatigue-life.mdx
  </files>
  <action>
**Step 1: Update FatigueLifePlots.astro**

1a. Add imports for statistics functions at the top (after existing imports):
```typescript
import {
  locationTest,
  bartlettTest,
  runsTest,
  autocorrelation,
  andersonDarlingNormal,
  ppccNormal,
  grubbsTest,
} from '../../lib/eda/math/statistics';
```

1b. Extend PlotType union:
```typescript
type PlotType =
  | '4-plot' | 'run-sequence' | 'lag' | 'histogram'
  | 'normal-probability' | 'box-plot'
  | 'autocorrelation' | 'spectral'
  | 'weibull-probability'
  | 'gamma-probability';
```

1c. Add switch cases for the two new plot types:

```typescript
case 'weibull-probability':
  // 3-parameter Weibull: subtract location=181 from data before plotting
  svg = generateProbabilityPlot({
    data: fatigueLife.map(v => v - 181),
    type: 'weibull',
    config: singleConfig,
    title: 'Weibull Probability Plot',
    xLabel: 'ln(-ln(1-p))',
    yLabel: 'ln(Fatigue Life - 181)',
  });
  break;

case 'gamma-probability':
  svg = generateProbabilityPlot({
    data: fatigueLife,
    type: 'gamma',
    gammaShape: 11.85,
    gammaScale: 118.2,
    config: singleConfig,
    title: 'Gamma Probability Plot',
  });
  break;
```

1d. Add default captions for the new types:
```typescript
'weibull-probability': 'Weibull probability plot of location-shifted fatigue life data (x - 181). The 3-parameter Weibull model with location=181, shape=3.43, scale=1357 uses the NIST MLE estimates. Points near the reference line indicate a reasonable Weibull fit.',
'gamma-probability': 'Gamma probability plot of fatigue life data with shape=11.85, scale=118.2 (NIST MLE estimates). Points near the reference line indicate a good gamma fit.',
```

1e. Compute all quantitative test statistics in the frontmatter section (after the `const compositeConfig` block, before `let svg = ''`):

```typescript
// Quantitative test battery
const locTest = locationTest(fatigueLife);
const bartTest = bartlettTest(fatigueLife, 4);
const runs = runsTest(fatigueLife);
const r1 = autocorrelation(fatigueLife)[1];
const adTest = andersonDarlingNormal(fatigueLife);
const ppcc = ppccNormal(fatigueLife);
const grubbs = grubbsTest(fatigueLife);
```

1f. Export these computed values by adding them to the Astro component's scope. After the `const figCaption = ...` line, add:

```typescript
// Export computed test statistics for MDX consumption
const stats = {
  locT: locTest.t.toFixed(4),
  locTCrit: locTest.tCritical.toFixed(3),
  locReject: locTest.reject,
  bartT: bartTest.T.toFixed(4),
  bartCrit: bartTest.chiCritical.toFixed(3),
  bartReject: bartTest.reject,
  runsZ: runs.Z.toFixed(4),
  runsReject: runs.reject,
  r1: r1.toFixed(4),
  r1Crit: (2 / Math.sqrt(fatigueLife.length)).toFixed(4),
  r1Reject: Math.abs(r1) > 2 / Math.sqrt(fatigueLife.length),
  adA2: adTest.A2.toFixed(4),
  adReject: adTest.reject,
  ppcc: ppcc.toFixed(4),
  grubbsG: grubbs.G.toFixed(4),
  grubbsTCrit: grubbs.tCritical.toFixed(3),
  grubbsReject: grubbs.reject,
};
```

NOTE: These stats are exposed on the Astro component but the MDX will HARDCODE the specific computed values (not use dynamic binding). The reason: run the stats computation once during development, then hardcode the values in MDX for clarity and consistency with other case studies. The executor should log the `stats` object values during development and then write them into the MDX.

**Step 2: Add distribution comparison subsections to fatigue-life.mdx**

Under the existing "### Distribution Comparison" section (from Plan 01), add sub-subsections BEFORE the existing candidate distribution paragraph:

```mdx
#### Weibull Probability Plot

The [Weibull probability plot](/eda/techniques/probability-plot/) tests the fit of the 3-parameter Weibull model (location=181, shape=3.43, scale=1357) by subtracting the location parameter from the data before plotting. If the shifted data follow a 2-parameter Weibull distribution, the points should fall near a straight line.

<FatigueLifePlots type="weibull-probability" />

The points follow the reference line reasonably well, with some deviation in the upper tail. The Weibull model captures the general shape of the distribution but the AIC/BIC analysis (below) will show it does not outperform the simpler Gaussian model for this dataset.

#### Gamma Probability Plot

The [gamma probability plot](/eda/techniques/probability-plot/) compares sorted data values against theoretical quantiles from a Gamma distribution with shape <InlineMath tex="\alpha = 11.85" /> and scale <InlineMath tex="\beta = 118.2" /> (NIST MLE estimates, rate parameterization converted: <InlineMath tex="\beta = 1/0.00846" />).

<FatigueLifePlots type="gamma-probability" />

The gamma probability plot shows a good fit with points closely following the reference line across the full range of the data. The gamma distribution provides a reasonable model for this right-skewed dataset, though the formal AIC/BIC comparison will determine whether it outperforms the Gaussian model.
```

Then keep the existing "Four candidate distributions are compared..." paragraph and the bullet list. This becomes a "#### Candidate Distribution Overlay" sub-subsection or can remain as-is without a sub-heading.

**Step 3: Add quantitative test battery subsections to fatigue-life.mdx**

In the "## Quantitative Output and Interpretation" section, AFTER the existing "### Summary Statistics" subsection (keep as-is), add the following new subsections BEFORE the existing "### Model Selection":

The executor must first run `npx astro build` or check the console output for the computed stats values. Then hardcode those values into the MDX content below. Use InlineMath for all statistical values.

Add these subsections (using placeholder values -- executor must replace with actual computed values):

```mdx
### Location Test

A [linear regression](/eda/quantitative/location-test/) of the fatigue life values against run order tests whether the location is drifting over time.

| Statistic | Value |
|-----------|-------|
| Slope <InlineMath tex="t" />-statistic | <InlineMath tex="t = {COMPUTED_VALUE}" /> |
| Critical value <InlineMath tex="t_{0.975, 99}" /> | <InlineMath tex="{COMPUTED_VALUE}" /> |

**Conclusion:** {Fail to reject / Reject} the null hypothesis of constant location at the 5% significance level. The process mean {is / is not} stable over the run.

### Variation Test

[Bartlett's test](/eda/quantitative/bartletts-test/) with <InlineMath tex="k = 4" /> groups tests whether the variation is constant across quarters of the dataset.

| Statistic | Value |
|-----------|-------|
| Bartlett <InlineMath tex="T" /> | <InlineMath tex="{COMPUTED_VALUE}" /> |
| Critical value <InlineMath tex="\chi^2_{0.95, 3}" /> | <InlineMath tex="7.815" /> |

**Conclusion:** {Fail to reject / Reject} the null hypothesis of constant variation. The process variability {is / is not} stable.

### Randomness Tests

**Runs test** -- tests whether the sequence of observations above and below the median is random.

| Statistic | Value |
|-----------|-------|
| Runs <InlineMath tex="Z" /> | <InlineMath tex="{COMPUTED_VALUE}" /> |
| Critical value <InlineMath tex="Z_{1-\alpha/2}" /> | <InlineMath tex="1.96" /> |

**Conclusion:** {Fail to reject / Reject} the null hypothesis of randomness.

**Lag-1 autocorrelation:**

| Statistic | Value |
|-----------|-------|
| <InlineMath tex="r_1" /> | <InlineMath tex="{COMPUTED_VALUE}" /> |
| Critical value <InlineMath tex="2/\sqrt{N}" /> | <InlineMath tex="{COMPUTED_VALUE}" /> |

**Conclusion:** The lag-1 autocorrelation {is / is not} significant. The independence assumption {is / is not} satisfied.

### Distribution Tests

**Anderson-Darling test** for normality:

| Statistic | Value |
|-----------|-------|
| <InlineMath tex="A^2" /> | <InlineMath tex="{COMPUTED_VALUE}" /> |
| Significance | {Reject / Fail to reject} at <InlineMath tex="\alpha = 0.05" /> |

**PPCC (normal):**

| Statistic | Value |
|-----------|-------|
| PPCC | <InlineMath tex="{COMPUTED_VALUE}" /> |

The Anderson-Darling result and PPCC value {support / question} the normality assumption. This result is complemented by the AIC/BIC model comparison below, which provides a more comprehensive assessment across multiple candidate distributions.

### Outlier Detection

The [Grubbs test](/eda/quantitative/grubbs-test/) checks whether the most extreme observation is a statistical outlier.

| Statistic | Value |
|-----------|-------|
| Grubbs <InlineMath tex="G" /> | <InlineMath tex="{COMPUTED_VALUE}" /> |
| Critical value | <InlineMath tex="{COMPUTED_VALUE}" /> |

**Conclusion:** The maximum value of 2440 {is / is not} a statistically significant outlier at the 5% significance level.

### Test Summary

| Assumption | Test | Statistic | Critical Value | Conclusion |
|------------|------|-----------|----------------|------------|
| Location | Regression <InlineMath tex="t" />-test | <InlineMath tex="{t_val}" /> | <InlineMath tex="{t_crit}" /> | {Pass/Fail} |
| Variation | Bartlett | <InlineMath tex="{T_val}" /> | <InlineMath tex="7.815" /> | {Pass/Fail} |
| Randomness | Runs test | <InlineMath tex="{Z_val}" /> | <InlineMath tex="1.96" /> | {Pass/Fail} |
| Randomness | Lag-1 <InlineMath tex="r_1" /> | <InlineMath tex="{r1_val}" /> | <InlineMath tex="{r1_crit}" /> | {Pass/Fail} |
| Distribution | Anderson-Darling | <InlineMath tex="{A2_val}" /> | | {Pass/Fail} |
| Distribution | PPCC (normal) | <InlineMath tex="{ppcc_val}" /> | | {Pass/Fail} |
| Outliers | Grubbs | <InlineMath tex="{G_val}" /> | <InlineMath tex="{G_crit}" /> | {Pass/Fail} |

Three of four assumptions hold: fixed location, fixed variation, and randomness. The distributional assumption is the focus of further analysis via the AIC/BIC model comparison.
```

CRITICAL: The executor MUST compute the actual values by temporarily adding `console.log(JSON.stringify(stats))` to FatigueLifePlots.astro and running `npx astro build`. Then replace ALL `{COMPUTED_VALUE}` placeholders with the actual rounded values and write appropriate conclusions based on whether each test rejects or fails to reject.
  </action>
  <verify>
    <automated>cd /Users/patrykattc/work/git/PatrykQuantumNomad && npx astro check 2>&1 | tail -5</automated>
  </verify>
  <done>
- distribution-math.ts exports `gammaQuantile` function
- probability-plot.ts has 'gamma' type with `renderGamma` function
- FatigueLifePlots.astro has 'weibull-probability' and 'gamma-probability' plot types
- FatigueLifePlots.astro imports and computes all 7 quantitative test statistics
- fatigue-life.mdx has "#### Weibull Probability Plot" and "#### Gamma Probability Plot" subsections with rendered plots
- fatigue-life.mdx has all 6 quantitative test subsections (Location, Variation, Randomness, Distribution, Outlier, Test Summary)
- All test statistic values are hardcoded with actual computed values (no placeholders)
- Test Summary table has all 7 rows with pass/fail conclusions
- `npx astro check` reports 0 errors
- `npx astro build` completes successfully
  </done>
</task>

</tasks>

<verification>
- `npx astro check` reports 0 errors
- `npx astro build` completes successfully
- grep for "gammaQuantile" in distribution-math.ts confirms export
- grep for "'gamma'" in probability-plot.ts confirms case handler
- grep for "weibull-probability" in FatigueLifePlots.astro confirms new type
- grep for "gamma-probability" in FatigueLifePlots.astro confirms new type
- grep for "### Test Summary" in fatigue-life.mdx confirms quantitative table
- grep for "#### Weibull Probability Plot" in fatigue-life.mdx confirms distribution comparison
- grep for "#### Gamma Probability Plot" in fatigue-life.mdx confirms distribution comparison
- Count of FatigueLifePlots component calls should be 10 (8 original + 2 new probability plots)
</verification>

<success_criteria>
Gamma probability plot renders correctly showing data near the reference line. Weibull probability plot renders with location-shifted data. All quantitative test statistics are computed and hardcoded in the MDX with appropriate conclusions. Test Summary table is complete. The build passes with no errors.
</success_criteria>

<output>
After completion, create `.planning/phases/61-fatigue-life-deep-dive/61-02-SUMMARY.md`
</output>
