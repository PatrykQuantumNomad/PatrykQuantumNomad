---
phase: 53-distribution-pages-with-d3-explorers
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/eda/math/distribution-math.ts
  - src/lib/eda/svg-generators/distribution-curve.ts
autonomous: true
requirements: [DIST-18]

must_haves:
  truths:
    - "evalDistribution() returns correct PDF/CDF values for all 19 distributions given valid parameters"
    - "generateDistributionCurve() produces valid SVG strings for all 19 distribution IDs"
    - "Discrete distributions (binomial, poisson) produce bar-stem PMF and step CDF plots"
    - "Tukey-Lambda handles lambda=0 degeneracy without NaN"
  artifacts:
    - path: "src/lib/eda/math/distribution-math.ts"
      provides: "evalDistribution dispatch + getXDomain + all 19 PDF/CDF implementations"
      exports: ["evalDistribution", "getXDomain"]
    - path: "src/lib/eda/svg-generators/distribution-curve.ts"
      provides: "Extended SVG generator using distribution-math.ts for all 19 distributions"
      contains: "generateDistributionCurve"
  key_links:
    - from: "src/lib/eda/svg-generators/distribution-curve.ts"
      to: "src/lib/eda/math/distribution-math.ts"
      via: "import evalDistribution and getXDomain"
      pattern: "import.*distribution-math"
    - from: "src/lib/eda/math/distribution-math.ts"
      to: "erf, gammaFn, lnGamma, lowerIncompleteGammaRatio"
      via: "internal math functions reused from distribution-curve.ts pattern"
      pattern: "function (erf|gammaFn|lnGamma|lowerIncompleteGammaRatio)"
---

<objective>
Create a shared distribution-math.ts module covering all 19 probability distributions and refactor the existing distribution-curve.ts SVG generator to use it, producing static SVG fallbacks for every distribution page.

Purpose: The math module is the single source of truth shared by both the build-time SVG generator (DIST-18) and the client-side DistributionExplorer.tsx (Plan 02). Getting the math right first prevents duplication and ensures correctness for all downstream consumers.

Output: distribution-math.ts with evalDistribution() for all 19 distributions, and distribution-curve.ts refactored to produce SVG for all 19 (including discrete bar-stems).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/53-distribution-pages-with-d3-explorers/53-RESEARCH.md
@src/lib/eda/svg-generators/distribution-curve.ts
@src/lib/eda/svg-generators/plot-base.ts
@src/lib/eda/math/statistics.ts
@src/data/eda/distributions.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create distribution-math.ts with all 19 PDF/CDF implementations</name>
  <files>src/lib/eda/math/distribution-math.ts</files>
  <action>
Create `src/lib/eda/math/distribution-math.ts` as a pure-math module with NO D3 or DOM imports.

**Reuse existing math from distribution-curve.ts pattern:** Copy the proven implementations of `erf`, `gammaFn`, `lnGamma`, `lowerIncompleteGammaRatio` into this module (they will become the canonical location). Do NOT import from distribution-curve.ts since that file imports D3 and would create unwanted bundle coupling for the client-side React island.

**Core exports:**

```typescript
export function evalDistribution(
  id: string, type: 'pdf' | 'cdf', x: number, params: Record<string, number>
): number

export function getXDomain(
  id: string, params: Record<string, number>
): [number, number]

export function isDiscrete(id: string): boolean
```

**CRITICAL: Parameter names MUST match src/data/eda/distributions.json exactly.** The [slug].astro page will pass parameters using the `name` field from the JSON. The switch cases in evalDistribution() must destructure using these exact keys:

| Distribution ID | Parameter keys (from JSON) | Default values (from JSON) |
|---|---|---|
| `normal` | `mu`, `sigma` | 0, 1 |
| `uniform` | `a`, `b` | -1, 1 |
| `cauchy` | `x0`, `gamma` | 0, 1 |
| `t-distribution` | `nu` | 5 |
| `f-distribution` | `d1`, `d2` | 5, 10 |
| `chi-square` | `k` | 5 |
| `exponential` | `lambda` | 1 |
| `weibull` | `alpha`, `beta` | 1, 1 |
| `lognormal` | `mu`, `sigma` | 0, 1 |
| `fatigue-life` | `alpha`, `beta` | 1, 1 |
| `gamma` | `alpha`, `beta` | 2, 1 |
| `double-exponential` | `mu`, `beta` | 0, 1 |
| `power-normal` | `p` | 1 |
| `power-lognormal` | `p`, `sigma` | 1, 1 |
| `tukey-lambda` | `lambda` | 0.14 |
| `extreme-value` | `mu`, `beta` | 0, 1 |
| `beta` | `alpha`, `beta` | 2, 5 |
| `binomial` | `n`, `p` | 10, 0.5 |
| `poisson` | `lambda` | 5 |

**CRITICAL: Switch case IDs must use the JSON `id` field exactly.** The existing distribution-curve.ts uses `case 't'` but the JSON ID is `t-distribution`. In this new module, use `case 't-distribution'` (matching the JSON).

**Already-proven implementations to port (same math, different module):**
- normal (erf-based)
- exponential
- chi-square (lowerIncompleteGammaRatio)
- uniform
- t-distribution (Simpson's rule 400 steps for CDF)
- gamma (lowerIncompleteGammaRatio)

**New implementations to add (13 distributions):**

1. **cauchy**: PDF = 1/(pi*gamma*(1+((x-x0)/gamma)^2)), CDF = atan((x-x0)/gamma)/pi + 0.5. Params: `x0`, `gamma`.
2. **weibull**: PDF = (alpha/beta)*(x/beta)^(alpha-1)*exp(-(x/beta)^alpha) for x>=0, CDF = 1-exp(-(x/beta)^alpha). Params: `alpha` (shape), `beta` (scale). Note: alpha/beta naming per NIST convention used in distributions.json.
3. **lognormal**: PDF = (1/(x*sigma*sqrt(2*pi)))*exp(-(ln(x)-mu)^2/(2*sigma^2)) for x>0, CDF uses erf. Params: `mu`, `sigma`.
4. **fatigue-life** (Birnbaum-Saunders): PDF via normalPDF transform, CDF via normalCDF of z(x) = (1/alpha)*(sqrt(x/beta)-sqrt(beta/x)). Params: `alpha` (shape), `beta` (scale/location). Note: JSON uses alpha/beta, NOT gamma/mu.
5. **double-exponential** (Laplace): PDF = (1/(2*beta))*exp(-|x-mu|/beta), CDF = piecewise. Params: `mu`, `beta`.
6. **power-normal**: PDF = p*normalPDF(x)*normalCDF(x)^(p-1), CDF = normalCDF(x)^p. Param: `p` (power). Note: JSON uses `p`, NOT `c`.
7. **power-lognormal**: PDF = (p/(x*sigma))*normalPDF(z)*normalCDF(z)^(p-1) where z=(ln(x))/sigma, CDF = normalCDF(z)^p. Params: `p` (power), `sigma`. Note: JSON uses `p` and `sigma` only (no `mu` parameter -- power-lognormal is parameterized with sigma only, ln(x)/sigma not (ln(x)-mu)/sigma).
8. **extreme-value** (Gumbel): PDF = (1/beta)*exp(-(z+exp(-z))) where z=(x-mu)/beta, CDF = exp(-exp(-z)). Params: `mu`, `beta`.
9. **beta**: PDF = (x^(a-1)*(1-x)^(b-1))/B(a,b) for x in [0,1], CDF = I_x(a,b) (regularizedBeta). Params: `alpha`, `beta`.
10. **f-distribution**: PDF via gammaFn and power formula, CDF = I(d1*x/(d1*x+d2); d1/2, d2/2) using regularizedBeta. Params: `d1`, `d2`.
11. **tukey-lambda**: Quantile function Q(F) = (F^lambda - (1-F)^lambda)/lambda. Special-case |lambda|<1e-10 as logistic: ln(F/(1-F)). PDF computed as f(x) = 1/Q'(F) where Q'(F) = F^(lambda-1) + (1-F)^(lambda-1). Generate curve by sweeping F from 0.001 to 0.999. Param: `lambda`.
12. **binomial** (discrete): PMF = C(n,k)*p^k*(1-p)^(n-k) using lnBinomialCoeff in log-space. CDF = sum of PMF for k=0..floor(x). Params: `n`, `p`.
13. **poisson** (discrete): PMF = exp(-lambda)*lambda^k/k! using lnGamma in log-space. CDF = sum of PMF for k=0..floor(x). Param: `lambda`.

**New math helper functions:**
- `regularizedBeta(x, a, b)`: Series expansion for x < (a+1)/(a+b+2), continued fraction (Lentz's method) otherwise. Follow identical pattern to lowerIncompleteGammaRatio. Needed by beta, f-distribution.
- `lnBinomialCoeff(n, k)`: lnGamma(n+1) - lnGamma(k+1) - lnGamma(n-k+1). Work in log-space to avoid overflow for large n.

**getXDomain logic:** For each distribution ID, return sensible [xMin, xMax] based on parameters. Discrete distributions return integer-aligned domains. Cauchy uses x0 +/- 10*gamma. Tukey-Lambda uses Q(0.001) to Q(0.999). Match the existing pattern in distribution-curve.ts's getDistributionFn.

**Pitfall avoidance:**
- Tukey-Lambda lambda=0: Special-case to logistic quantile ln(F/(1-F))
- Cauchy: x-domain centered on x0, extend +/- 10*gamma
- Binomial/Poisson: Use log-space math (lnGamma) to avoid factorial overflow for large n/lambda
- Beta: regularizedBeta convergence -- use series for small x, continued fraction for large x (identical strategy to lowerIncompleteGammaRatio)
- All functions: Guard against NaN/Infinity with isFinite checks, return 0 for invalid inputs
  </action>
  <verify>
    <automated>cd /Users/patrykattc/work/git/PatrykQuantumNomad && node -e "
const dm = require('./src/lib/eda/math/distribution-math.ts' /* will need ts-node or tsx */);
" 2>&1 || npx tsx -e "
import { evalDistribution, getXDomain, isDiscrete } from './src/lib/eda/math/distribution-math';
const ids = ['normal','uniform','cauchy','t-distribution','f-distribution','chi-square','exponential','weibull','lognormal','fatigue-life','gamma','double-exponential','power-normal','power-lognormal','tukey-lambda','extreme-value','beta','binomial','poisson'];
const defaults: Record<string, Record<string, number>> = {
  normal:{mu:0,sigma:1},
  uniform:{a:-1,b:1},
  cauchy:{x0:0,gamma:1},
  't-distribution':{nu:5},
  'f-distribution':{d1:5,d2:10},
  'chi-square':{k:5},
  exponential:{lambda:1},
  weibull:{alpha:1,beta:1},
  lognormal:{mu:0,sigma:1},
  'fatigue-life':{alpha:1,beta:1},
  gamma:{alpha:2,beta:1},
  'double-exponential':{mu:0,beta:1},
  'power-normal':{p:1},
  'power-lognormal':{p:1,sigma:1},
  'tukey-lambda':{lambda:0.14},
  'extreme-value':{mu:0,beta:1},
  beta:{alpha:2,beta:5},
  binomial:{n:10,p:0.5},
  poisson:{lambda:5}
};
let pass = 0;
for (const id of ids) {
  const [lo,hi] = getXDomain(id, defaults[id]);
  const mid = (lo+hi)/2;
  const pdf = evalDistribution(id, 'pdf', mid, defaults[id]);
  const cdf = evalDistribution(id, 'cdf', mid, defaults[id]);
  const ok = isFinite(pdf) && isFinite(cdf) && pdf >= 0 && cdf >= 0 && cdf <= 1.01;
  console.log(id, ok ? 'PASS' : 'FAIL', {pdf: pdf.toFixed(4), cdf: cdf.toFixed(4)});
  if (ok) pass++;
}
console.log(pass + '/19 distributions passed');
if (pass < 19) process.exit(1);
"</automated>
    <manual>All 19 distribution IDs return finite, non-negative PDF and CDF values at midpoint of their x-domain</manual>
  </verify>
  <done>distribution-math.ts exports evalDistribution, getXDomain, isDiscrete. All 19 distributions produce valid PDF/CDF values. regularizedBeta works for beta and F distributions. Tukey-Lambda handles lambda=0. Discrete distributions use log-space math.</done>
</task>

<task type="auto">
  <name>Task 2: Refactor distribution-curve.ts to use distribution-math.ts for all 19 distributions</name>
  <files>src/lib/eda/svg-generators/distribution-curve.ts</files>
  <action>
Refactor `src/lib/eda/svg-generators/distribution-curve.ts` to:

1. **Import from distribution-math.ts** instead of defining math functions inline:
   ```typescript
   import { evalDistribution, getXDomain, isDiscrete } from '../math/distribution-math';
   ```

2. **Remove all inline math functions** (erf, gammaFn, lnGamma, lowerIncompleteGammaRatio, normalPDF, normalCDF, etc.) since they now live in distribution-math.ts.

3. **Expand the DistributionCurveOptions type** to accept all 19 distribution IDs (not just the current 6). Change the `distribution` field from the union literal to `string` (since distribution-math.ts handles the dispatch).

4. **Replace the `getDistributionFn` switch-case** with calls to `evalDistribution` and `getXDomain` from distribution-math.ts.

5. **Add discrete distribution rendering** for binomial and poisson:
   - When `isDiscrete(distribution)` is true, render PMF as vertical bar-stems (line elements from baseline to PMF value at each integer k) instead of smooth curves.
   - CDF for discrete distributions: use step function rendering with `curveStepAfter` from d3-shape.
   - PMF bars: `<line>` elements at each integer k, x1=x2=xScale(k), y1=yScale(0), y2=yScale(pmf(k)), stroke=PALETTE.dataPrimary, stroke-width=3.
   - Add circles at bar tops: `<circle>` at (xScale(k), yScale(pmf(k))), r=3, fill=PALETTE.dataPrimary.

6. **Keep the existing SVG structure**: svgOpen, gridLines, xAxis, yAxis, titleText, area fill for continuous PDFs. The refactor only changes where math comes from and adds discrete rendering mode.

7. **Update the barrel export** in `src/lib/eda/svg-generators/index.ts` if the DistributionCurveOptions type changed (ensure it's re-exported correctly).

**Do NOT change:** plot-base.ts, other generators, datasets.ts. Only modify distribution-curve.ts and potentially index.ts for type re-export.
  </action>
  <verify>
    <automated>cd /Users/patrykattc/work/git/PatrykQuantumNomad && npx tsx -e "
import { generateDistributionCurve } from './src/lib/eda/svg-generators/distribution-curve';
const ids = ['normal','uniform','cauchy','t-distribution','f-distribution','chi-square','exponential','weibull','lognormal','fatigue-life','gamma','double-exponential','power-normal','power-lognormal','tukey-lambda','extreme-value','beta','binomial','poisson'];
const defaults: Record<string, Record<string, number>> = {
  normal:{mu:0,sigma:1},
  uniform:{a:-1,b:1},
  cauchy:{x0:0,gamma:1},
  't-distribution':{nu:5},
  'f-distribution':{d1:5,d2:10},
  'chi-square':{k:5},
  exponential:{lambda:1},
  weibull:{alpha:1,beta:1},
  lognormal:{mu:0,sigma:1},
  'fatigue-life':{alpha:1,beta:1},
  gamma:{alpha:2,beta:1},
  'double-exponential':{mu:0,beta:1},
  'power-normal':{p:1},
  'power-lognormal':{p:1,sigma:1},
  'tukey-lambda':{lambda:0.14},
  'extreme-value':{mu:0,beta:1},
  beta:{alpha:2,beta:5},
  binomial:{n:10,p:0.5},
  poisson:{lambda:5}
};
let pass = 0;
for (const id of ids) {
  const pdf = generateDistributionCurve({ type: 'pdf', distribution: id, params: defaults[id] });
  const cdf = generateDistributionCurve({ type: 'cdf', distribution: id, params: defaults[id] });
  const ok = pdf.startsWith('<svg') && pdf.endsWith('</svg>') && cdf.startsWith('<svg') && cdf.endsWith('</svg>') && !pdf.includes('NaN') && !cdf.includes('NaN');
  console.log(id, ok ? 'PASS' : 'FAIL', 'pdf=' + pdf.length + 'b cdf=' + cdf.length + 'b');
  if (ok) pass++;
}
console.log(pass + '/19 SVG pairs passed');
if (pass < 19) process.exit(1);
" && npm run build 2>&1 | tail -5</automated>
    <manual>All 19 distributions produce valid SVG without NaN, and the build passes</manual>
  </verify>
  <done>distribution-curve.ts uses distribution-math.ts for all math, produces valid SVG for all 19 distributions including discrete bar-stems for binomial/poisson, and the site builds without errors.</done>
</task>

</tasks>

<verification>
- All 19 distributions return valid PDF/CDF values via evalDistribution()
- All 19 distributions produce valid SVG via generateDistributionCurve()
- No NaN values in any SVG output
- Discrete distributions (binomial, poisson) render as bar-stems (not smooth curves)
- Tukey-Lambda handles lambda=0 without errors
- Site builds successfully with existing pages unaffected
</verification>

<success_criteria>
- distribution-math.ts exists with evalDistribution(), getXDomain(), isDiscrete() covering all 19 distributions
- distribution-curve.ts refactored to use distribution-math.ts, no inline math duplication
- 19/19 SVG pairs (PDF+CDF) generate valid markup
- npm run build passes without regressions
</success_criteria>

<output>
After completion, create `.planning/phases/53-distribution-pages-with-d3-explorers/53-01-SUMMARY.md`
</output>
