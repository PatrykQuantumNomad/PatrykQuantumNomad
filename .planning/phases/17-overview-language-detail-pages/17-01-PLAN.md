---
phase: 17-overview-language-detail-pages
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/data/beauty-index/snippets.ts
  - src/components/beauty-index/ScoringTable.astro
  - src/components/beauty-index/LanguageGrid.astro
  - src/components/beauty-index/LanguageNav.astro
autonomous: true
requirements: [OVER-02, OVER-03, OVER-04, OVER-05, LANG-04, LANG-06]

must_haves:
  truths:
    - "All 25 languages have a signature code snippet available via getSnippet()"
    - "ScoringTable renders a sortable HTML table with rank, language name, 6 dimension scores, and total"
    - "Clicking a column header in ScoringTable re-sorts the table rows by that dimension"
    - "LanguageGrid renders radar chart thumbnails grouped by tier with links to /beauty-index/{id}/"
    - "LanguageNav renders previous/next links and a back-to-overview link"
  artifacts:
    - path: "src/data/beauty-index/snippets.ts"
      provides: "Code snippets for all 25 languages"
      exports: ["SNIPPETS", "getSnippet", "CodeSnippet"]
    - path: "src/components/beauty-index/ScoringTable.astro"
      provides: "Sortable scoring table component"
      contains: "data-sortable"
    - path: "src/components/beauty-index/LanguageGrid.astro"
      provides: "Tier-grouped radar chart thumbnail grid"
      contains: "RadarChart"
    - path: "src/components/beauty-index/LanguageNav.astro"
      provides: "Previous/next language navigation"
      contains: "aria-label"
  key_links:
    - from: "src/components/beauty-index/ScoringTable.astro"
      to: "src/lib/beauty-index/schema.ts"
      via: "totalScore() and DIMENSIONS imports"
      pattern: "totalScore|DIMENSIONS"
    - from: "src/components/beauty-index/LanguageGrid.astro"
      to: "src/components/beauty-index/RadarChart.astro"
      via: "RadarChart component with size={160}"
      pattern: "RadarChart.*size"
    - from: "src/data/beauty-index/snippets.ts"
      to: "astro:components Code"
      via: "lang field maps to Shiki language identifier"
      pattern: "lang:"
---

<objective>
Create the 3 new components (ScoringTable, LanguageGrid, LanguageNav) and the code snippets data file that the overview and detail pages will assemble.

Purpose: These are the building blocks that Plan 02 (overview page) and Plan 03 (detail pages) will import. Building them first allows both page plans to run in parallel.
Output: 4 new files -- 1 data file + 3 Astro components.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-data-foundation-chart-components/16-01-SUMMARY.md
@.planning/phases/16-data-foundation-chart-components/16-02-SUMMARY.md
@.planning/phases/17-overview-language-detail-pages/17-RESEARCH.md
@src/lib/beauty-index/schema.ts
@src/lib/beauty-index/dimensions.ts
@src/lib/beauty-index/tiers.ts
@src/components/beauty-index/RadarChart.astro
@src/components/beauty-index/TierBadge.astro
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create code snippets data file for all 25 languages</name>
  <files>src/data/beauty-index/snippets.ts</files>
  <action>
Create `src/data/beauty-index/snippets.ts` with signature code snippets for all 25 languages.

Export a `CodeSnippet` interface with fields: `lang` (Shiki language ID string), `label` (display label like "Pattern matching"), and `code` (the actual code string using template literals).

Export a `SNIPPETS: Record<string, CodeSnippet>` object keyed by language ID (matching `entry.data.id` values: haskell, rust, elixir, kotlin, swift, python, ruby, typescript, scala, clojure, fsharp, ocaml, go, csharp, dart, julia, lua, zig, java, javascript, c, cpp, php, perl, cobol).

Export a `getSnippet(languageId: string): CodeSnippet | undefined` helper function.

Each snippet should be 5-12 lines and showcase what makes that language distinctive:
- Rust: pattern matching with enums
- Haskell: list comprehension / quicksort
- Elixir: pipe operator + pattern matching
- Kotlin: data classes + null safety
- Swift: protocol-oriented design
- Python: list comprehension / generators
- Ruby: blocks and method chaining
- TypeScript: discriminated unions
- Scala: for-comprehension
- Clojure: threading macro
- F#: pipe + discriminated unions
- OCaml: recursive pattern match
- Go: goroutines + channels
- C#: LINQ query
- Dart: cascade notation
- Julia: multiple dispatch
- Lua: metatables
- Zig: comptime
- Java: streams API
- JavaScript: async/await + destructuring
- C: pointer arithmetic
- C++: RAII / smart pointers
- PHP: array functions + arrow functions
- Perl: regex + map
- COBOL: procedural division

Use the correct Shiki `lang` identifiers: `rust`, `haskell`, `elixir`, `kotlin`, `swift`, `python`, `ruby`, `typescript`, `scala`, `clojure`, `fsharp`, `ocaml`, `go`, `csharp`, `dart`, `julia`, `lua`, `zig`, `java`, `javascript`, `c`, `cpp`, `php`, `perl`, `cobol`.

Use template literals (backticks) for all code strings -- this is why we use a TypeScript file instead of JSON (avoids escaping hell).
  </action>
  <verify>Run `npx astro check 2>&1 | tail -5` to confirm no TypeScript errors. Run `node -e "const s = require('./src/data/beauty-index/snippets.ts')" 2>&1 || echo 'TS file - check with astro check instead'"` to confirm the file parses. Verify all 25 keys exist by counting: `grep -c "lang:" src/data/beauty-index/snippets.ts` should return 25.</verify>
  <done>All 25 languages have a code snippet entry with valid Shiki lang identifier, descriptive label, and 5-12 line code string. getSnippet() returns the correct snippet for any language ID.</done>
</task>

<task type="auto">
  <name>Task 2: Create ScoringTable, LanguageGrid, and LanguageNav components</name>
  <files>
    src/components/beauty-index/ScoringTable.astro
    src/components/beauty-index/LanguageGrid.astro
    src/components/beauty-index/LanguageNav.astro
  </files>
  <action>
**ScoringTable.astro** -- Sortable HTML table component.

Props interface: `{ languages: Language[] }`.

Import `Language` and `totalScore` from `../../lib/beauty-index/schema`, `DIMENSIONS` from `../../lib/beauty-index/dimensions`, `getTierColor` from `../../lib/beauty-index/tiers`.

In the frontmatter, sort languages by totalScore descending (default sort). Build the HTML table:

- Add `data-sortable` attribute to the `<table>` element.
- `<thead>` row with `<th>` elements: Rank (data-sort="rank" data-type="number"), Language (data-sort="name"), one column per DIMENSIONS entry (data-sort={dim.key} data-type="number", display dim.symbol, title={dim.name}), Total (data-sort="total" data-type="number"). Add `cursor-pointer select-none` classes and a sort indicator span to each `<th>`.
- `<tbody>` rows: each `<tr>` has data attributes for ALL sortable values (data-rank, data-name, data-phi through data-sigma, data-total). Cells: rank number, language name as a link to `/beauty-index/${lang.id}/` styled with accent color, 6 dimension score cells (each with `data-col={dim.key}`), and total score in bold. Apply a subtle left border color using `getTierColor(lang.tier)` on each row for tier indication.
- Table uses Tailwind: `w-full text-sm`, rows have `border-b border-[var(--color-border)]/50 hover:bg-[var(--color-surface-alt)]` and `transition-colors`.
- Add responsive wrapper: `<div class="overflow-x-auto">` around the table for mobile.

Include an inline `<script>` tag (approximately 30 lines) for client-side sorting:
- Listen on `astro:page-load` event (not DOMContentLoaded) for view transition compatibility.
- Query `[data-sortable]` table, get all `th[data-sort]` headers and the `tbody`.
- On header click: determine sort key from `dataset.sort`, toggle direction (default desc for numbers, asc for text), read values from `tr.dataset[key]`, sort rows, re-append to tbody.
- Update sort direction indicator: add/remove CSS classes `sort-asc` / `sort-desc` on the active header, reset others.
- Add CSS for sort indicators using `::after` pseudo-element showing up/down arrows.

**LanguageGrid.astro** -- Tier-grouped radar chart thumbnail grid.

Props interface: `{ languages: Language[] }`.

Import `RadarChart` from `./RadarChart.astro`, `TIERS` from `../../lib/beauty-index/tiers`, `totalScore` from `../../lib/beauty-index/schema`.

In the frontmatter, sort languages by totalScore descending. Group into tiers using `TIERS.slice().reverse()` (Beautiful first). For each tier group:
- Render a tier section header with the tier label in tier color, and the score range (e.g., "47-60 points") in secondary text.
- Render a responsive grid: `grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4`.
- Each grid item is an `<a>` linking to `/beauty-index/${lang.id}/` containing:
  - `<RadarChart language={lang} size={160} />` -- thumbnail radar chart
  - Language name in `text-sm font-medium`
  - Total score in `text-xs text-[var(--color-text-secondary)]`
- Card styling: `rounded-xl border border-[var(--color-border)] hover:border-[var(--color-accent)] transition-colors bg-[var(--color-surface)] p-3 flex flex-col items-center`

**LanguageNav.astro** -- Previous/next language navigation.

Props interface: `{ prev: { id: string; name: string } | null; next: { id: string; name: string } | null }`.

Render a `<nav>` element with `aria-label="Language navigation"` containing:
- Flex layout: `flex items-center justify-between mt-12 pt-6 border-t border-[var(--color-border)]`.
- Left: if `prev`, render a link to `/beauty-index/${prev.id}/` with left arrow and prev.name; else render an empty `<span />` for spacing.
- Center: link to `/beauty-index/` labeled "Overview" in secondary text color with hover accent.
- Right: if `next`, render a link to `/beauty-index/${next.id}/` with next.name and right arrow; else empty `<span />`.
- Links use `text-[var(--color-accent)] hover:underline` styling.
  </action>
  <verify>Run `npx astro check 2>&1 | tail -20` to confirm no TypeScript errors in any of the 3 new components. Verify files exist: `ls -la src/components/beauty-index/ScoringTable.astro src/components/beauty-index/LanguageGrid.astro src/components/beauty-index/LanguageNav.astro`.</verify>
  <done>ScoringTable renders a full 25-language table with data-* attributes and inline sort script. LanguageGrid renders tier-grouped radar thumbnails in a responsive grid with links. LanguageNav renders prev/next/overview navigation.</done>
</task>

</tasks>

<verification>
- `npx astro check` passes with no errors related to beauty-index components
- `grep -c "lang:" src/data/beauty-index/snippets.ts` returns 25 (all languages covered)
- All 3 new component files exist in `src/components/beauty-index/`
- ScoringTable contains `data-sortable` attribute and an inline `<script>` tag
- LanguageGrid imports and uses RadarChart with `size={160}`
- LanguageNav accepts prev/next props and renders navigation links
</verification>

<success_criteria>
- 25 code snippets with valid Shiki language IDs and 5-12 line template-literal code strings
- ScoringTable component with client-side sort via inline script (~30 lines)
- LanguageGrid component with tier-grouped responsive grid of radar chart thumbnails
- LanguageNav component with prev/next/overview links
- All files pass `npx astro check`
</success_criteria>

<output>
After completion, create `.planning/phases/17-overview-language-detail-pages/17-01-SUMMARY.md`
</output>
