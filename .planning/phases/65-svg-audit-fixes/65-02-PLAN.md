---
phase: 65-svg-audit-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/eda/svg-generators/line-plot.ts
  - src/lib/eda/technique-renderer.ts
autonomous: true

must_haves:
  truths:
    - "Autocorrelation plot confidence band uses +-2/sqrt(N) matching NIST convention, not 1.96/sqrt(N)"
    - "Box-Cox Linearity and Box-Cox Normality plots render connected lines, not discrete scatter dots"
    - "Youden Plot reference lines use scale-based positioning, not hardcoded pixel math"
    - "Probability Plot renders a non-normal distribution (e.g., uniform) to differentiate from Normal Probability Plot"
  artifacts:
    - path: "src/lib/eda/svg-generators/line-plot.ts"
      provides: "Corrected autocorrelation confidence band constant"
      contains: "2 / Math.sqrt"
    - path: "src/lib/eda/technique-renderer.ts"
      provides: "Fixed Box-Cox, Youden, and probability-plot renderers"
      contains: "generateLinePlot"
  key_links:
    - from: "src/lib/eda/technique-renderer.ts"
      to: "src/lib/eda/svg-generators/line-plot.ts"
      via: "Box-Cox composition uses generateLinePlot instead of generateScatterPlot"
      pattern: "generateLinePlot"
---

<objective>
Fix the 4 MEDIUM-priority visual issues and 1 LOW-priority differentiation issue: autocorrelation confidence band formula, Box-Cox line rendering, Youden reference line positioning, and probability-plot vs normal-probability-plot differentiation.

Purpose: These are smaller but measurable deviations from NIST visual conventions. Fixing them brings all remaining composition-based techniques to NIST parity.
Output: Corrected autocorrelation band, line-based Box-Cox plots, scale-based Youden reference lines, differentiated probability plot.
</objective>

<execution_context>
@/Users/patrykattc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrykattc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/65-svg-audit-fixes/65-RESEARCH.md
@src/lib/eda/technique-renderer.ts
@src/lib/eda/svg-generators/line-plot.ts
@src/lib/eda/svg-generators/scatter-plot.ts
@src/lib/eda/svg-generators/plot-base.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix autocorrelation confidence band and Box-Cox line rendering</name>
  <files>src/lib/eda/svg-generators/line-plot.ts, src/lib/eda/technique-renderer.ts</files>
  <action>
**Fix 1: Autocorrelation confidence band (line-plot.ts)**

In `renderAutocorrelation()` function inside line-plot.ts:
- Change line 162: `const bound = 1.96 / Math.sqrt(n);` to `const bound = 2 / Math.sqrt(n);`
- Update the comment on line 161 from "Significance bounds at +/- 1.96/sqrt(n)" to "Significance bounds at +/- 2/sqrt(n) per NIST convention"

This is a one-line fix. The dedicated autocorrelation-plot.ts already uses 2/sqrt(N). This makes the line-plot.ts version consistent with NIST and with the dedicated generator.

**Fix 2: Box-Cox Linearity plot — dots to connected line (technique-renderer.ts)**

Replace `composeBoxCoxLinearity()` function body. Currently it uses `generateScatterPlot` which renders discrete dots. Instead:

1. Compute the same lambda sweep and correlation data (keep existing logic for lambdas, xVals, yVals, correlations array)
2. Instead of calling `generateScatterPlot({ data: correlations, ... })`, use `generateLinePlot` in `time-series` mode:
   - Sort correlations by x (lambda) value
   - Extract just the y values (correlations sorted by lambda)
   - Call `generateLinePlot` with mode `'time-series'` — BUT this won't work because LinePlot takes `number[]` not `{x,y}[]`

   Better approach: Keep `generateScatterPlot` but add a connecting polyline path between the points after generating the base scatter. Inject a `<polyline>` element connecting all points in order before the `</svg>` closing tag:

   ```typescript
   function composeBoxCoxLinearity(): string {
     // ... existing lambda sweep and correlation computation ...
     const sorted = correlations.sort((a, b) => a.x - b.x);

     const baseSvg = generateScatterPlot({
       data: sorted,
       showRegression: false,
       title: 'Box-Cox Linearity Plot',
       xLabel: 'Lambda',
       yLabel: 'Correlation',
     });

     // Add connecting line through the points
     // We need to compute pixel coordinates from the scatter plot's scales
     // Since we can't access internal scales, use the plot-base defaults:
     const config = { width: 600, height: 400, margin: { top: 40, right: 20, bottom: 50, left: 60 } };
     const innerW = config.width - config.margin.left - config.margin.right;
     const innerH = config.height - config.margin.top - config.margin.bottom;

     const xExtent = [Math.min(...sorted.map(d => d.x)), Math.max(...sorted.map(d => d.x))];
     const yExtent = [Math.min(...sorted.map(d => d.y)), Math.max(...sorted.map(d => d.y))];
     // Add same padding as scatterPlot (uses .nice() so approximate)
     const xPad = (xExtent[1] - xExtent[0]) * 0.05;
     const yPad = (yExtent[1] - yExtent[0]) * 0.05;

     const xScale = (v: number) => config.margin.left + ((v - (xExtent[0] - xPad)) / ((xExtent[1] + xPad) - (xExtent[0] - xPad))) * innerW;
     const yScale = (v: number) => config.margin.top + innerH - ((v - (yExtent[0] - yPad)) / ((yExtent[1] + yPad) - (yExtent[0] - yPad))) * innerH;

     const polyPoints = sorted.map(d => `${xScale(d.x).toFixed(2)},${yScale(d.y).toFixed(2)}`).join(' ');
     const polyline = `<polyline points="${polyPoints}" fill="none" stroke="${PALETTE.dataPrimary}" stroke-width="2" />`;

     return baseSvg.replace('</svg>', polyline + '</svg>');
   }
   ```

   IMPORTANT: Import PALETTE at the top of technique-renderer.ts if not already imported (it IS already imported).

   NOTE: The scale approximation may not be pixel-perfect due to d3's `.nice()` domain extension. An acceptable alternative: increase the number of lambda points from 7 to 21 (step 0.2) so the scatter dots are close enough together to appear as a continuous curve. The user's eye sees a line. Choose whichever approach produces cleaner code. The polyline approach is preferred for accuracy.

**Fix 3: Box-Cox Normality plot — same fix as Box-Cox Linearity (technique-renderer.ts)**

Apply the identical polyline injection pattern to `composeBoxCoxNormality()`:
- Keep existing lambda sweep computation (it already uses 21 points with step 0.2)
- Sort the pairs by x before passing to `generateScatterPlot`
- Inject a `<polyline>` connecting all points in lambda order before `</svg>`

The Box-Cox Normality already computes 21 lambda points (step 0.2), so the polyline will be smoother than the Linearity plot's 7 points. Consider also increasing the Linearity plot to 21 points for consistency.
  </action>
  <verify>Run `npx astro build 2>&1 | tail -30` -- build must pass. Grep: `grep -n "1.96" src/lib/eda/svg-generators/line-plot.ts` must return nothing (the old constant is gone).</verify>
  <done>Autocorrelation band uses 2/sqrt(N). Box-Cox Linearity and Normality plots show connected lines through the computed points. Build succeeds.</done>
</task>

<task type="auto">
  <name>Task 2: Fix Youden reference lines and differentiate probability-plot</name>
  <files>src/lib/eda/technique-renderer.ts</files>
  <action>
**Fix 1: Youden Plot reference lines (technique-renderer.ts)**

The current `composeYoudenPlot()` uses hardcoded pixel math for median reference lines:
```typescript
y1="${((1 - (medianY - 45) / 45) * 310 + 40).toFixed(2)}"
```
This assumes data in range ~45-90 and fixed margin/dimension values.

Replace with scale-based computation:
1. Keep existing data generation (seededRandom, labData)
2. Keep the `generateScatterPlot` call
3. Replace the reference line computation:

```typescript
// Match scatter plot's default dimensions and margins
const margin = { top: 40, right: 20, bottom: 50, left: 60 };
const plotWidth = 600;
const plotHeight = 400;
const innerW = plotWidth - margin.left - margin.right;
const innerH = plotHeight - margin.top - margin.bottom;

// Compute data extents (same as scatter plot would)
const allX = labData.map(d => d.x);
const allY = labData.map(d => d.y);
const xMin = Math.min(...allX);
const xMax = Math.max(...allX);
const yMin = Math.min(...allY);
const yMax = Math.max(...allY);

// Add padding similar to scatter plot (approx 5% each side for nice())
const xPad = (xMax - xMin) * 0.08;
const yPad = (yMax - yMin) * 0.08;
const xDomain = [xMin - xPad, xMax + xPad];
const yDomain = [yMin - yPad, yMax + yPad];

const xScale = (v: number) => margin.left + ((v - xDomain[0]) / (xDomain[1] - xDomain[0])) * innerW;
const yScale = (v: number) => margin.top + innerH - ((v - yDomain[0]) / (yDomain[1] - yDomain[0])) * innerH;

const refLines =
  `<line x1="${margin.left}" y1="${yScale(medianY).toFixed(2)}" x2="${(margin.left + innerW)}" y2="${yScale(medianY).toFixed(2)}" stroke="${PALETTE.dataSecondary}" stroke-width="1" stroke-dasharray="6,4" />` +
  `<line x1="${xScale(medianX).toFixed(2)}" y1="${margin.top}" x2="${xScale(medianX).toFixed(2)}" y2="${(margin.top + innerH)}" stroke="${PALETTE.dataSecondary}" stroke-width="1" stroke-dasharray="6,4" />`;
```

This ensures reference lines track the actual data regardless of the data range.

**Fix 2: Differentiate probability-plot from normal-probability-plot (technique-renderer.ts)**

Currently both render `generateProbabilityPlot({ type: 'normal' })`. Per NIST, the general Probability Plot should demonstrate a non-normal distribution to show the technique's generality.

Change the `'probability-plot'` entry in TECHNIQUE_RENDERERS:
```typescript
'probability-plot': () => generateProbabilityPlot({
  data: uniformRandom,
  type: 'normal',
  title: 'Probability Plot (Uniform Data)',
}),
```

Using `uniformRandom` data on a normal probability plot shows the characteristic S-curve deviation that NIST describes for non-normal data on a probability plot. This visually differentiates it from the `normal-probability-plot` which uses `normalRandom` (showing a straight diagonal line).

Alternative: If `generateProbabilityPlot` supports `type: 'general'` or similar, use that. But since the current types are `'normal' | 'qq' | 'weibull' | 'ppcc'`, using `type: 'normal'` with non-normal data is the clearest way to show the diagnostic power of the probability plot.
  </action>
  <verify>Run `npx astro build 2>&1 | tail -30` -- build must pass. Grep: `grep "45) / 45" src/lib/eda/technique-renderer.ts` must return nothing (hardcoded pixel math removed).</verify>
  <done>Youden Plot reference lines use data-driven scale functions. Probability Plot uses uniform data to differentiate from Normal Probability Plot. Build succeeds.</done>
</task>

</tasks>

<verification>
1. `npx astro build` completes with 0 errors
2. `grep "1.96" src/lib/eda/svg-generators/line-plot.ts` returns nothing
3. `grep "45) / 45" src/lib/eda/technique-renderer.ts` returns nothing
4. All 29 technique pages still build successfully
</verification>

<success_criteria>
- Autocorrelation confidence band uses 2/sqrt(N)
- Box-Cox Linearity and Normality render connected lines
- Youden reference lines are data-driven
- Probability Plot is visually distinct from Normal Probability Plot
- Build passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/65-svg-audit-fixes/65-02-SUMMARY.md`
</output>
