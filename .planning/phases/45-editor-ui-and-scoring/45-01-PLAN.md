---
phase: 45-editor-ui-and-scoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/stores/k8sAnalyzerStore.ts
  - src/lib/tools/k8s-analyzer/scorer.ts
  - src/lib/tools/k8s-analyzer/url-state.ts
  - src/lib/tools/k8s-analyzer/badge-generator.ts
  - src/lib/tools/k8s-analyzer/use-codemirror-k8s.ts
  - src/lib/tools/k8s-analyzer/types.ts
autonomous: true
requirements:
  - SCORE-01
  - SCORE-02
  - SCORE-03
  - UI-01
  - UI-04
  - UI-13
  - UI-14
  - SHARE-01
  - SHARE-02

must_haves:
  truths:
    - "K8s scorer computes weighted 0-100 score with Security 35%, Reliability 20%, Best Practice 20%, Schema 15%, Cross-Resource 10%"
    - "K8s scorer assigns letter grades from A+ through F using identical thresholds as existing tools"
    - "Nanostore atoms share K8s analysis state (result, analyzing, editorViewRef, resultsStale) across React components"
    - "URL hash encoding uses #k8s= prefix with lz-string compression and decoding handles missing/invalid hashes"
    - "Badge generator produces 400x200 SVG with K8s-specific 5 category labels/colors and rasterizes to retina PNG"
    - "CodeMirror hook creates YAML editor with dark theme, Mod-Enter shortcut, stale detection, and View Transitions cleanup"
  artifacts:
    - path: "src/stores/k8sAnalyzerStore.ts"
      provides: "Nanostore atoms for K8s analyzer state"
      exports: ["k8sResult", "k8sAnalyzing", "k8sEditorViewRef", "k8sResultsStale"]
    - path: "src/lib/tools/k8s-analyzer/scorer.ts"
      provides: "Category-weighted K8s scoring engine"
      exports: ["computeK8sScore"]
    - path: "src/lib/tools/k8s-analyzer/url-state.ts"
      provides: "URL hash state encode/decode with #k8s= prefix"
      exports: ["encodeToHash", "decodeFromHash", "buildShareUrl", "isUrlSafeLength"]
    - path: "src/lib/tools/k8s-analyzer/badge-generator.ts"
      provides: "SVG badge builder and PNG download for K8s scores"
      exports: ["buildK8sBadgeSvg", "downloadK8sBadgePng"]
    - path: "src/lib/tools/k8s-analyzer/use-codemirror-k8s.ts"
      provides: "React hook for CodeMirror 6 YAML editor with K8s-specific store wiring"
      exports: ["useCodeMirrorK8s"]
  key_links:
    - from: "src/lib/tools/k8s-analyzer/scorer.ts"
      to: "src/lib/tools/k8s-analyzer/types.ts"
      via: "imports K8sCategory, K8sSeverity, K8sScoreResult types"
      pattern: "import type.*from.*types"
    - from: "src/lib/tools/k8s-analyzer/scorer.ts"
      to: "src/lib/tools/k8s-analyzer/rules/index.ts"
      via: "imports allK8sRules for rule lookup"
      pattern: "import.*allK8sRules.*from.*rules"
    - from: "src/lib/tools/k8s-analyzer/scorer.ts"
      to: "src/lib/tools/k8s-analyzer/diagnostic-rules.ts"
      via: "imports SCHEMA_RULE_METADATA for dual rule lookup"
      pattern: "import.*SCHEMA_RULE_METADATA.*from.*diagnostic-rules"
    - from: "src/lib/tools/k8s-analyzer/use-codemirror-k8s.ts"
      to: "src/stores/k8sAnalyzerStore.ts"
      via: "sets k8sEditorViewRef, reads k8sResult for stale detection"
      pattern: "import.*k8sEditorViewRef.*from.*k8sAnalyzerStore"
---

<objective>
Create the 5 foundation utility modules for the K8s analyzer UI: nanostore atoms, category-weighted scorer, URL hash state, badge generator, and CodeMirror YAML hook.

Purpose: These pure-logic modules are the plumbing layer that the UI components (Plan 02, 03) will import. Building them first eliminates all blocking dependencies so the editor and results components can be built in parallel in Wave 2.

Output: 5 new TypeScript modules in src/stores/ and src/lib/tools/k8s-analyzer/
</objective>

<execution_context>
@/Users/patrykattc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrykattc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/stores/composeValidatorStore.ts
@src/lib/tools/compose-validator/scorer.ts
@src/lib/tools/compose-validator/url-state.ts
@src/lib/tools/compose-validator/badge-generator.ts
@src/lib/tools/compose-validator/use-codemirror-yaml.ts
@src/lib/tools/k8s-analyzer/types.ts
@src/lib/tools/k8s-analyzer/rules/index.ts
@src/lib/tools/k8s-analyzer/diagnostic-rules.ts
@src/lib/tools/k8s-analyzer/engine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create nanostore atoms and K8s category-weighted scorer</name>
  <files>
    src/lib/tools/k8s-analyzer/types.ts
    src/stores/k8sAnalyzerStore.ts
    src/lib/tools/k8s-analyzer/scorer.ts
  </files>
  <action>
**types.ts** — Add `pssCompliance` field to `K8sAnalysisResult` interface. Add `pssCompliance?: PssComplianceSummary;` after the `resourceSummary` field. This ensures Plan 02's K8sEditorPanel can include `pssCompliance: engineResult.pssCompliance` in the `k8sResult.set()` call, and Plan 03's K8sResultsPanel can read `result.pssCompliance` without a type error.

**k8sAnalyzerStore.ts** — Fork `src/stores/composeValidatorStore.ts` exactly. Replace all `compose` prefixes with `k8s`. Import `K8sAnalysisResult` from `../lib/tools/k8s-analyzer/types`. Four atoms:
- `k8sResult: atom<K8sAnalysisResult | null>(null)`
- `k8sAnalyzing: atom<boolean>(false)`
- `k8sEditorViewRef: atom<EditorView | null>(null)`
- `k8sResultsStale: atom<boolean>(false)`

**scorer.ts** — Fork `src/lib/tools/compose-validator/scorer.ts` and adapt:
1. Import K8s types from `./types` (K8sRuleViolation, K8sCategory, K8sSeverity, K8sScoreDeduction, K8sCategoryScore, K8sScoreResult)
2. Import `allK8sRules` from `./rules` and `SCHEMA_RULE_METADATA` from `./diagnostic-rules`
3. CATEGORY_WEIGHTS per SCORE-01: `{ security: 35, reliability: 20, 'best-practice': 20, schema: 15, 'cross-resource': 10 }` — these sum to 100
4. SEVERITY_DEDUCTIONS: `{ error: 15, warning: 8, info: 3 }` (same as Compose)
5. ALL_CATEGORIES: `['security', 'reliability', 'best-practice', 'schema', 'cross-resource']` (5 categories, not Compose's 5)
6. `computeK8sScore(violations: K8sRuleViolation[]): K8sScoreResult` — Build dual rule lookup from `allK8sRules` (57 lint rules) AND `SCHEMA_RULE_METADATA` entries (10 schema rules). For SCHEMA_RULE_METADATA, iterate `Object.entries()` to get `[id, meta]` pairs. Same diminishing returns formula: `basePoints / (1 + 0.3 * priorCount)`, rounded to 2 decimals.
7. `computeGrade(score: number): string` — identical thresholds as Compose (A+ >= 97 through F)
8. Export `computeK8sScore` as the public API

Key difference from Compose scorer: dual lookup uses `Object.entries(SCHEMA_RULE_METADATA)` instead of importing a schema rules array, because K8s schema rules are metadata objects (no check method), not rule instances.
  </action>
  <verify>
Run `npx tsc --noEmit` — both files compile with no type errors. Verify the scorer imports resolve correctly (allK8sRules from rules/index.ts, SCHEMA_RULE_METADATA from diagnostic-rules.ts).
  </verify>
  <done>
k8sAnalyzerStore.ts exports 4 nanostore atoms. scorer.ts exports computeK8sScore that accepts K8sRuleViolation[] and returns K8sScoreResult with 5-category weighted scoring matching SCORE-01 weights.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create URL hash state and badge generator</name>
  <files>
    src/lib/tools/k8s-analyzer/url-state.ts
    src/lib/tools/k8s-analyzer/badge-generator.ts
  </files>
  <action>
**url-state.ts** — Fork `src/lib/tools/compose-validator/url-state.ts` exactly. Change only the HASH_PREFIX constant from `'#compose='` to `'#k8s='` (per SHARE-02). All 4 functions remain identical in logic:
- `encodeToHash(content: string): string`
- `decodeFromHash(): string | null`
- `buildShareUrl(content: string): string`
- `isUrlSafeLength(content: string): { safe: boolean; length: number }`

**badge-generator.ts** — Fork `src/lib/tools/compose-validator/badge-generator.ts` and adapt:
1. Import K8s types: `K8sScoreResult`, `K8sCategoryScore` from `./types`
2. CATEGORY_LABELS: `{ security: 'Security', reliability: 'Reliability', 'best-practice': 'Best Practice', schema: 'Schema', 'cross-resource': 'Cross-Resource' }`
3. CATEGORY_COLORS: `{ security: '#ef4444', reliability: '#f59e0b', 'best-practice': '#06b6d4', schema: '#3b82f6', 'cross-resource': '#8b5cf6' }` — per research color spec
4. `buildK8sBadgeSvg(score: K8sScoreResult): string` — Same SVG structure. Change the title text from `'Docker Compose Analysis'` to `'K8s Manifest Analysis'`. Change the footer URL from compose-validator to `patrykgolabek.dev/tools/k8s-analyzer`.
5. `downloadK8sBadgePng(score: K8sScoreResult): Promise<void>` — Same rasterization logic. Change the download filename from `compose-score-` to `k8s-score-`.
6. `getGradeColor` function is identical — copy as-is.
  </action>
  <verify>
Run `npx tsc --noEmit` — both files compile. Verify url-state.ts uses `'#k8s='` prefix (not compose). Verify badge-generator.ts has 5 category labels matching the K8s categories.
  </verify>
  <done>
url-state.ts exports 4 URL hash functions with #k8s= prefix. badge-generator.ts exports buildK8sBadgeSvg and downloadK8sBadgePng with K8s-specific category labels, colors, and branding.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create CodeMirror YAML hook for K8s analyzer</name>
  <files>src/lib/tools/k8s-analyzer/use-codemirror-k8s.ts</files>
  <action>
Fork `src/lib/tools/compose-validator/use-codemirror-yaml.ts` and adapt for K8s:

1. Rename hook to `useCodeMirrorK8s` with interface `UseCodeMirrorK8sOptions { initialDoc: string; onAnalyze: () => void; }`
2. Import store atoms from `../../../stores/k8sAnalyzerStore` instead of compose store: `k8sEditorViewRef`, `k8sResultsStale`, `k8sResult`
3. Import all the same CodeMirror dependencies: `EditorView`, `EditorState`, `basicSetup`, `yaml`, `lintGutter`, `editorTheme`, `oneDarkTheme`, `a11ySyntaxHighlighting`, `highlightLineField` — same import paths as the compose hook
4. Add `keymap` import from `@codemirror/view` and include `keymap.of([{ key: 'Mod-Enter', run: () => { analyzeRef.current(); return true; } }])` in the extensions array — this is the UI-04 keyboard shortcut that the compose hook does NOT include (the compose hook accepts onAnalyze but never wires up a keymap)
5. Place the keymap extension BEFORE the theme extensions for correct precedence
6. Change the aria-label from Docker Compose to: `'Kubernetes manifest editor — paste or type your K8s YAML here'`
7. Update stale detection listener to check `k8sResult.get()` instead of `composeResult.get()`
8. View Transitions cleanup: set `k8sEditorViewRef.set(null)` in both the handleSwap and the useEffect return
9. Keep empty deps array `[]` for the useEffect — the hook creates once and destroys on unmount

The hook returns `{ containerRef, viewRef }` exactly like the compose version.
  </action>
  <verify>
Run `npx tsc --noEmit` — the hook compiles. Verify the keymap.of() extension is present with 'Mod-Enter' key binding. Verify all store references are k8s (not compose). Verify the astro:before-swap listener is present for View Transitions safety.
  </verify>
  <done>
use-codemirror-k8s.ts exports useCodeMirrorK8s hook that creates a CodeMirror 6 YAML editor with dark theme, Mod-Enter shortcut (UI-04), lint gutter, stale result detection, and double cleanup for View Transitions. All store references use k8sAnalyzerStore atoms.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors across all 5 new files
2. All 5 files follow the established naming convention (camelCase store, kebab-case lib modules)
3. scorer.ts category weights sum to exactly 100 (35 + 20 + 20 + 15 + 10)
4. scorer.ts builds dual rule lookup covering all 67 rules (57 lint + 10 schema)
5. url-state.ts HASH_PREFIX is '#k8s=' (not '#compose=' or '#dockerfile=')
6. badge-generator.ts has exactly 5 category labels and colors matching K8s categories
7. use-codemirror-k8s.ts includes keymap.of with Mod-Enter binding
8. No imports reference compose or dockerfile stores
</verification>

<success_criteria>
All 5 foundation utility modules compile, export the documented public APIs, and use K8s-specific constants (category weights, hash prefix, badge labels). The scorer implements the SCORE-01 category weighting formula. The CodeMirror hook includes the Mod-Enter shortcut (UI-04) and View Transitions cleanup (UI-13).
</success_criteria>

<output>
After completion, create `.planning/phases/45-editor-ui-and-scoring/45-01-SUMMARY.md`
</output>
