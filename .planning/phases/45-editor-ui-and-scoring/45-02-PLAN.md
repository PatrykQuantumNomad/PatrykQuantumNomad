---
phase: 45-editor-ui-and-scoring
plan: 02
type: execute
wave: 2
depends_on: ["45-01"]
files_modified:
  - src/components/tools/K8sEditorPanel.tsx
  - src/components/tools/k8s-results/K8sCategoryBreakdown.tsx
  - src/components/tools/k8s-results/K8sViolationList.tsx
  - src/components/tools/k8s-results/K8sEmptyState.tsx
  - src/components/tools/k8s-results/K8sShareActions.tsx
  - src/components/tools/k8s-results/K8sResourceSummary.tsx
  - src/components/tools/k8s-results/K8sPromptGenerator.tsx
  - src/components/tools/k8s-results/K8sPssCompliance.tsx
autonomous: true

must_haves:
  truths:
    - "K8sEditorPanel renders a CodeMirror YAML editor with Analyze and Clear buttons, triggers async engine on click, and pushes violations as CodeMirror diagnostics"
    - "Violations are enriched with rule metadata (title, explanation, fix, category, severity) from dual lookup of allK8sRules and SCHEMA_RULE_METADATA"
    - "Line numbers are clamped to prevent Position out of range crash when document changes between analysis runs"
    - "Category breakdown shows 5 K8s categories with colored progress bars and numeric scores"
    - "Violation list groups violations by severity with expandable details and click-to-navigate line numbers"
    - "Empty state shows congratulatory message when no violations found"
    - "Share actions provide badge download and 3-tier share fallback (Web Share > Clipboard > prompt)"
    - "Resource summary displays parsed resource types and counts from the engine's Map<string, number>"
  artifacts:
    - path: "src/components/tools/K8sEditorPanel.tsx"
      provides: "CodeMirror editor + Analyze/Clear buttons + async engine integration"
      min_lines: 120
    - path: "src/components/tools/k8s-results/K8sCategoryBreakdown.tsx"
      provides: "5-category score breakdown with progress bars"
      exports: ["K8sCategoryBreakdown"]
    - path: "src/components/tools/k8s-results/K8sViolationList.tsx"
      provides: "Severity-grouped violation list with click-to-navigate"
      exports: ["K8sViolationList"]
    - path: "src/components/tools/k8s-results/K8sEmptyState.tsx"
      provides: "Clean manifest congratulatory empty state"
      exports: ["K8sEmptyState"]
    - path: "src/components/tools/k8s-results/K8sShareActions.tsx"
      provides: "Badge download + 3-tier share fallback"
      exports: ["K8sShareActions"]
    - path: "src/components/tools/k8s-results/K8sResourceSummary.tsx"
      provides: "Resource types and counts panel"
      exports: ["K8sResourceSummary"]
    - path: "src/components/tools/k8s-results/K8sPromptGenerator.tsx"
      provides: "AI fix prompt generation for violations"
      exports: ["K8sPromptGenerator"]
    - path: "src/components/tools/k8s-results/K8sPssCompliance.tsx"
      provides: "PSS compliance badge (Baseline/Restricted)"
      exports: ["K8sPssCompliance"]
  key_links:
    - from: "src/components/tools/K8sEditorPanel.tsx"
      to: "src/lib/tools/k8s-analyzer/engine.ts"
      via: "await runK8sEngine(content) for async analysis"
      pattern: "await runK8sEngine"
    - from: "src/components/tools/K8sEditorPanel.tsx"
      to: "src/lib/tools/k8s-analyzer/scorer.ts"
      via: "computeK8sScore(engineResult.violations) for scoring"
      pattern: "computeK8sScore"
    - from: "src/components/tools/K8sEditorPanel.tsx"
      to: "src/stores/k8sAnalyzerStore.ts"
      via: "sets k8sResult, k8sAnalyzing, k8sResultsStale atoms"
      pattern: "k8sResult\\.set"
    - from: "src/components/tools/k8s-results/K8sShareActions.tsx"
      to: "src/lib/tools/k8s-analyzer/badge-generator.ts"
      via: "downloadK8sBadgePng for badge download"
      pattern: "downloadK8sBadgePng"
    - from: "src/components/tools/k8s-results/K8sShareActions.tsx"
      to: "src/lib/tools/k8s-analyzer/url-state.ts"
      via: "buildShareUrl for share link generation"
      pattern: "buildShareUrl"
---

<objective>
Create the K8s editor panel and all results sub-components: the async-aware editor panel with analyze/clear buttons, category breakdown, violation list, empty state, share actions, resource summary, prompt generator, and PSS compliance badge.

Purpose: These 8 React components are the interactive UI layer that users directly interact with. The editor panel adapts the established Compose pattern for the K8s async engine, while the results components present scored analysis with K8s-specific features (resource summary, PSS compliance).

Output: 8 new React components in src/components/tools/
</objective>

<execution_context>
@/Users/patrykattc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrykattc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/45-editor-ui-and-scoring/45-01-SUMMARY.md
@src/components/tools/ComposeEditorPanel.tsx
@src/components/tools/compose-results/ComposeCategoryBreakdown.tsx
@src/components/tools/compose-results/ComposeViolationList.tsx
@src/components/tools/compose-results/ComposeEmptyState.tsx
@src/components/tools/compose-results/ComposeShareActions.tsx
@src/components/tools/compose-results/ComposePromptGenerator.tsx
@src/lib/tools/k8s-analyzer/engine.ts
@src/lib/tools/k8s-analyzer/types.ts
@src/lib/tools/k8s-analyzer/rules/index.ts
@src/lib/tools/k8s-analyzer/diagnostic-rules.ts
@src/lib/tools/k8s-analyzer/sample-manifest.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create K8sEditorPanel with async engine integration</name>
  <files>src/components/tools/K8sEditorPanel.tsx</files>
  <action>
Fork `src/components/tools/ComposeEditorPanel.tsx` and adapt for the K8s async engine. This is the most critical adaptation in the entire phase because the K8s engine is async (unlike Compose).

**Imports to change:**
- `useCodeMirrorK8s` from `../../lib/tools/k8s-analyzer/use-codemirror-k8s` (instead of useCodeMirrorYaml)
- `runK8sEngine` from `../../lib/tools/k8s-analyzer/engine` (instead of parseComposeYaml + runComposeEngine)
- `computeK8sScore` from `../../lib/tools/k8s-analyzer/scorer` (instead of computeComposeScore)
- `getK8sRuleById` from `../../lib/tools/k8s-analyzer/rules` (instead of getComposeRuleById)
- `SCHEMA_RULE_METADATA` from `../../lib/tools/k8s-analyzer/diagnostic-rules` (instead of getSchemaRuleById)
- `SAMPLE_K8S_MANIFEST` from `../../lib/tools/k8s-analyzer/sample-manifest` (instead of SAMPLE_COMPOSE)
- `decodeFromHash` from `../../lib/tools/k8s-analyzer/url-state` (instead of compose url-state)
- K8s store atoms from `../../stores/k8sAnalyzerStore`: `k8sResult`, `k8sAnalyzing`, `k8sResultsStale`
- K8s types: `K8sLintViolation`, `K8sRuleFix`, `K8sSeverity`, `K8sCategory` from types.ts

**CRITICAL async adaptation of analyzeRef.current:**
```
analyzeRef.current = async (view: EditorView) => {
  const content = view.state.doc.toString();
  if (!content.trim()) {
    view.dispatch(setDiagnostics(view.state, []));
    k8sResult.set(null);
    return;
  }

  k8sResultsStale.set(false);
  k8sAnalyzing.set(true);

  try {
    // PITFALL 2: Yield to event loop so React paints "Analyzing..." state
    await new Promise(resolve => setTimeout(resolve, 0));

    // PITFALL 1: K8s engine is async (unlike Compose) — MUST await
    const engineResult = await runK8sEngine(content);
    const score = computeK8sScore(engineResult.violations);

    // Convert violations to CodeMirror Diagnostics
    const diagnostics = engineResult.violations.map((v) => {
      // PITFALL 4: Clamp line numbers to prevent crash
      const clampedLine = Math.min(v.line, view.state.doc.lines);
      const line = view.state.doc.line(clampedLine);

      // PITFALL 8: Dual lookup — check lint rules AND schema rule metadata
      const lintRule = getK8sRuleById(v.ruleId);
      const schemaMeta = SCHEMA_RULE_METADATA[v.ruleId];
      const rule = lintRule ?? schemaMeta;

      const severity = rule?.severity === 'error' ? 'error'
        : rule?.severity === 'warning' ? 'warning' : 'info';

      const from = line.from + Math.max(0, (v.column - 1));
      let to;
      if (v.endLine) {
        const clampedEndLine = Math.min(v.endLine, view.state.doc.lines);
        to = view.state.doc.line(clampedEndLine).to;
      } else {
        to = line.to;
      }

      return { from, to, severity, message: `[${v.ruleId}] ${v.message}`, source: 'k8s-analyzer' };
    });

    view.dispatch(setDiagnostics(view.state, diagnostics));

    // Enrich violations with metadata (same pattern as Compose)
    const enrichedViolations = engineResult.violations.map((v) => {
      const lintRule = getK8sRuleById(v.ruleId);
      const schemaMeta = SCHEMA_RULE_METADATA[v.ruleId];
      const rule = lintRule ?? schemaMeta;
      // Find which resource this violation belongs to
      const resource = engineResult.resources.find(r => {
        const endLine = v.endLine ?? v.line;
        const nextResource = engineResult.resources.find(nr => nr.startLine > r.startLine);
        const resourceEndLine = nextResource ? nextResource.startLine - 1 : Infinity;
        return v.line >= r.startLine && endLine <= resourceEndLine;
      });
      return {
        ...v,
        severity: (rule?.severity ?? 'info') as K8sSeverity,
        category: (rule?.category ?? 'schema') as K8sCategory,
        title: rule?.title ?? v.ruleId,
        explanation: rule?.explanation ?? '',
        fix: rule?.fix ?? { description: '', beforeCode: '', afterCode: '' } as K8sRuleFix,
        resourceName: resource?.name,
        resourceKind: resource?.kind,
      };
    });

    k8sResult.set({
      violations: enrichedViolations,
      score,
      resources: engineResult.resources,
      resourceSummary: engineResult.resourceSummary,
      parseSuccess: true,
      timestamp: Date.now(),
    });
  } catch {
    view.dispatch(setDiagnostics(view.state, []));
    k8sResult.set({
      violations: [],
      score: { overall: 0, grade: 'F', categories: [], deductions: [] },
      resources: [],
      resourceSummary: new Map(),
      parseSuccess: false,
      timestamp: Date.now(),
    });
  }

  k8sAnalyzing.set(false);
};
```

**Hook wiring:**
```
const { containerRef, viewRef } = useCodeMirrorK8s({
  initialDoc: hashContentRef.current || SAMPLE_K8S_MANIFEST,
  onAnalyze: () => {
    if (viewRef.current) analyzeRef.current(viewRef.current);
  },
});
```

**handleButtonClick note:** The async analyzeRef means the button click returns a promise, but we don't need to await it — the UI state is managed by the nanostore atoms. The useCallback wrapper stays identical to Compose.

**JSX:** Same layout as ComposeEditorPanel — "Editor" heading, Clear button, Analyze button, CodeMirror container div. No changes needed to the button styles or layout.
  </action>
  <verify>
Run `npx tsc --noEmit` — K8sEditorPanel.tsx compiles. Verify the analyzeRef.current function is async. Verify `await runK8sEngine(content)` is called (not synchronous). Verify `await new Promise(resolve => setTimeout(resolve, 0))` is present before the engine call. Verify line clamping uses `Math.min(v.line, view.state.doc.lines)`. Verify dual rule lookup uses both `getK8sRuleById` and `SCHEMA_RULE_METADATA[v.ruleId]`.
  </verify>
  <done>
K8sEditorPanel renders a CodeMirror YAML editor with Analyze and Clear buttons. Clicking Analyze runs the async K8s engine with a setTimeout yield, converts violations to CodeMirror diagnostics with clamped line numbers, enriches them with metadata from dual rule lookup, and sets the k8sResult nanostore atom with full analysis results including resources, resourceSummary, and score.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create all K8s results sub-components</name>
  <files>
    src/components/tools/k8s-results/K8sCategoryBreakdown.tsx
    src/components/tools/k8s-results/K8sViolationList.tsx
    src/components/tools/k8s-results/K8sEmptyState.tsx
    src/components/tools/k8s-results/K8sShareActions.tsx
    src/components/tools/k8s-results/K8sResourceSummary.tsx
    src/components/tools/k8s-results/K8sPromptGenerator.tsx
    src/components/tools/k8s-results/K8sPssCompliance.tsx
  </files>
  <action>
Create the `src/components/tools/k8s-results/` directory and 7 components. Each is a fork of its Compose equivalent with K8s-specific adaptations.

**K8sCategoryBreakdown.tsx** — Fork `ComposeCategoryBreakdown.tsx`:
- Accept `categories: K8sCategoryScore[]` prop (from types.ts)
- CATEGORY_LABELS: `{ security: 'Security', reliability: 'Reliability', 'best-practice': 'Best Practice', schema: 'Schema', 'cross-resource': 'Cross-Resource' }`
- CATEGORY_COLORS: `{ security: '#ef4444', reliability: '#f59e0b', 'best-practice': '#06b6d4', schema: '#3b82f6', 'cross-resource': '#8b5cf6' }`
- Render a row per category with label, colored progress bar (width = score%), weight percentage, and numeric score
- Same styling pattern as Compose version

**K8sViolationList.tsx** — Fork `ComposeViolationList.tsx`:
- Accept `violations: K8sLintViolation[]` and `onNavigate: (line: number) => void` props
- Group violations by severity (error, warning, info) using the same grouping logic
- Each violation row shows: severity icon, rule ID (link to `/tools/k8s-analyzer/rules/{ruleId}/`), title, line number button (triggers onNavigate)
- Expandable detail section shows explanation and before/after fix code
- ALSO show resourceKind and resourceName if present: e.g., "[Deployment/my-app]" prefix before the violation title
- Rule link pattern: `/tools/k8s-analyzer/rules/${v.ruleId.toLowerCase()}/` (links may 404 until Phase 47, that's fine)

**K8sEmptyState.tsx** — Fork `ComposeEmptyState.tsx`:
- Accept `score: number` and `grade: string` props
- Show ScoreGauge with the perfect score
- Congratulatory message: "No issues found! Your Kubernetes manifests follow best practices." (not "Docker Compose file")
- Same styling/layout as Compose version

**K8sShareActions.tsx** — Fork `ComposeShareActions.tsx`:
- Import from K8s-specific modules: `downloadK8sBadgePng` from badge-generator, `buildShareUrl`/`isUrlSafeLength` from url-state
- Import `k8sResult`/`k8sEditorViewRef` from k8sAnalyzerStore
- Share title: `K8s Score: ${grade} (${overall}/100)` (not "Compose Score")
- Include `<K8sPromptGenerator />` component (same pattern as Compose)

**K8sResourceSummary.tsx** — NEW component (no Compose equivalent):
- Accept `resourceSummary: Map<string, number>` prop
- PITFALL 7: Convert Map to array via `Array.from(resourceSummary.entries())`, sort by count descending
- If entries is empty, return null
- Render a compact panel: heading "Resources ({total})", then flex-wrap of pill badges showing `{kind} {count}`
- Style: rounded-lg bg-white/5 border border-white/10, pills use bg-[var(--color-accent)]/10 text-[var(--color-accent)]
- See research code example for exact JSX structure

**K8sPromptGenerator.tsx** — Fork `ComposePromptGenerator.tsx`:
- Import `k8sResult`/`k8sEditorViewRef` from k8sAnalyzerStore
- Change prompt template to reference "Kubernetes manifest" instead of "Docker Compose file"
- Include violation details with resource context (kind/name) when available

**K8sPssCompliance.tsx** — NEW component:
- Accept `pssCompliance: PssComplianceSummary` prop (from types.ts)
- Import `PssComplianceSummary` from types.ts
- Display two badges: "PSS Baseline" and "PSS Restricted"
- Each badge shows compliant (green checkmark) or non-compliant (red X with violation count)
- Compact layout: flex row of two small badges
- If no workload resources exist (both counts are 0 and both compliant), return null
  </action>
  <verify>
Run `npx tsc --noEmit` — all 7 components compile. Verify K8sCategoryBreakdown has exactly 5 category labels matching K8sCategory type. Verify K8sViolationList links use `/tools/k8s-analyzer/rules/` prefix. Verify K8sResourceSummary uses `Array.from()` to convert Map. Verify K8sShareActions imports from k8s-specific badge-generator and url-state modules.
  </verify>
  <done>
7 K8s results sub-components created: K8sCategoryBreakdown (5-category bars), K8sViolationList (severity-grouped with click-to-navigate), K8sEmptyState (congratulatory), K8sShareActions (badge download + 3-tier share), K8sResourceSummary (Map-based resource type/count pills), K8sPromptGenerator (AI fix prompt), K8sPssCompliance (Baseline/Restricted badges). All compile and use K8s-specific stores, types, and imports.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors across all 8 new files
2. K8sEditorPanel.tsx has an async analyzeRef with `await runK8sEngine()` and `setTimeout(0)` yield
3. K8sEditorPanel.tsx uses dual rule lookup (getK8sRuleById + SCHEMA_RULE_METADATA) for all 67 rules
4. K8sEditorPanel.tsx clamps line numbers with `Math.min(v.line, view.state.doc.lines)`
5. K8sCategoryBreakdown has 5 K8s-specific category labels and colors
6. K8sViolationList links point to `/tools/k8s-analyzer/rules/{code}/`
7. K8sResourceSummary converts Map to array via `Array.from()`
8. K8sShareActions uses `#k8s=` hash prefix via K8s url-state module
9. K8sPssCompliance handles the PssComplianceSummary type from engine output
10. No component imports from compose or dockerfile stores/modules
</verification>

<success_criteria>
K8sEditorPanel wires the async K8s engine to CodeMirror with all pitfall mitigations (async await, setTimeout yield, line clamping, dual lookup). All 7 results sub-components render K8s-specific data (5 categories, resource summary, PSS compliance) with correct types and store references. All 8 files compile with zero TypeScript errors.
</success_criteria>

<output>
After completion, create `.planning/phases/45-editor-ui-and-scoring/45-02-SUMMARY.md`
</output>
