---
phase: 42-security-rules
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/tools/k8s-analyzer/container-helpers.ts
  - src/lib/tools/k8s-analyzer/rules/security/KA-C001-privileged-container.ts
  - src/lib/tools/k8s-analyzer/rules/security/KA-C002-privilege-escalation.ts
  - src/lib/tools/k8s-analyzer/rules/security/KA-C003-runs-as-root.ts
  - src/lib/tools/k8s-analyzer/rules/security/KA-C004-missing-run-as-non-root.ts
  - src/lib/tools/k8s-analyzer/rules/security/KA-C005-uid-zero.ts
  - src/lib/tools/k8s-analyzer/rules/security/KA-C006-host-pid.ts
  - src/lib/tools/k8s-analyzer/rules/security/KA-C007-host-ipc.ts
  - src/lib/tools/k8s-analyzer/rules/security/KA-C008-host-network.ts
  - src/lib/tools/k8s-analyzer/rules/security/KA-C009-host-port.ts
  - src/lib/tools/k8s-analyzer/rules/security/KA-C010-dangerous-capabilities.ts
  - src/lib/tools/k8s-analyzer/rules/security/KA-C011-capabilities-not-dropped.ts
  - src/lib/tools/k8s-analyzer/rules/security/KA-C012-writable-filesystem.ts
  - src/lib/tools/k8s-analyzer/rules/security/KA-C013-missing-seccomp.ts
  - src/lib/tools/k8s-analyzer/rules/security/KA-C014-sensitive-host-path.ts
  - src/lib/tools/k8s-analyzer/rules/security/KA-C015-docker-socket-mount.ts
  - src/lib/tools/k8s-analyzer/rules/security/KA-C016-sa-token-automount.ts
  - src/lib/tools/k8s-analyzer/rules/security/KA-C017-default-service-account.ts
  - src/lib/tools/k8s-analyzer/rules/security/KA-C018-secrets-in-env.ts
  - src/lib/tools/k8s-analyzer/rules/security/KA-C019-default-namespace.ts
  - src/lib/tools/k8s-analyzer/rules/security/KA-C020-missing-security-context.ts
  - src/lib/tools/k8s-analyzer/rules/security/index.ts
  - src/lib/tools/k8s-analyzer/rules/index.ts
autonomous: true

must_haves:
  truths:
    - "A container with privileged:true produces KA-C001 error with PSS Baseline reference"
    - "A container with allowPrivilegeEscalation not set to false produces KA-C002 error"
    - "A container without runAsNonRoot:true and without non-zero runAsUser produces KA-C003 warning"
    - "A container with explicit runAsUser:0 produces KA-C005 error (NOT KA-C003)"
    - "A pod with hostPID/hostIPC/hostNetwork true produces KA-C006/C007/C008 violations"
    - "A container with SYS_ADMIN/NET_RAW/ALL capabilities produces KA-C010 error"
    - "A container without capabilities drop ALL produces KA-C011 warning"
    - "A hostPath volume mounting /etc, /proc, /sys, or /var/run produces KA-C014 error"
    - "A hostPath volume mounting /var/run/docker.sock produces KA-C015 error"
    - "A pod with automountServiceAccountToken not false produces KA-C016 warning"
    - "A pod using 'default' ServiceAccount produces KA-C017 warning"
    - "An env var with hardcoded secret-looking value (PASSWORD, TOKEN, SECRET suffix) produces KA-C018 warning"
    - "A resource in the default namespace produces KA-C019 info"
    - "A container with securityContext completely absent (undefined) produces KA-C020 warning"
    - "All 20 security rules work across Pod, Deployment, StatefulSet, DaemonSet, Job, and CronJob resource kinds"
    - "CronJob containers are found at spec.jobTemplate.spec.template.spec.containers"
  artifacts:
    - path: "src/lib/tools/k8s-analyzer/container-helpers.ts"
      provides: "getPodSpec and getContainerSpecs helpers for all 6 workload kinds"
      exports: ["getPodSpec", "getContainerSpecs", "ContainerSpec", "PodSpec"]
    - path: "src/lib/tools/k8s-analyzer/rules/security/index.ts"
      provides: "Aggregated securityRules array with all 20 rules"
      exports: ["securityRules"]
    - path: "src/lib/tools/k8s-analyzer/rules/index.ts"
      provides: "Master allK8sRules array and allDocumentedK8sRules array"
      exports: ["allK8sRules", "allDocumentedK8sRules"]
  key_links:
    - from: "src/lib/tools/k8s-analyzer/rules/security/KA-C001-privileged-container.ts"
      to: "src/lib/tools/k8s-analyzer/container-helpers.ts"
      via: "import getContainerSpecs"
      pattern: "getContainerSpecs\\(resource\\)"
    - from: "src/lib/tools/k8s-analyzer/rules/security/KA-C006-host-pid.ts"
      to: "src/lib/tools/k8s-analyzer/container-helpers.ts"
      via: "import getPodSpec"
      pattern: "getPodSpec\\(resource\\)"
    - from: "src/lib/tools/k8s-analyzer/rules/security/index.ts"
      to: "src/lib/tools/k8s-analyzer/rules/security/KA-C001-privileged-container.ts"
      via: "import and aggregate into securityRules array"
      pattern: "securityRules.*K8sLintRule\\[\\]"
---

<objective>
Create shared container extraction helpers and all 20 K8s security rules (KA-C001 through KA-C020) covering PSS Baseline/Restricted profiles and CIS Benchmark controls.

Purpose: These rules form the core security analysis capability of the K8s Manifest Analyzer, enabling detection of privileged containers, missing security contexts, dangerous capabilities, host namespace sharing, sensitive volume mounts, and secrets exposure across all 6 workload resource kinds.

Output: 20 security rule files following the one-file-per-rule pattern, container-helpers.ts utility, security/index.ts aggregator, and rules/index.ts master index.
</objective>

<execution_context>
@/Users/patrykattc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrykattc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/42-security-rules/42-RESEARCH.md  (CRITICAL: contains all rule patterns, helpers, pitfalls)
@.planning/phases/41-foundation-schema-infrastructure/41-01-SUMMARY.md (types.ts interfaces)
@.planning/phases/41-foundation-schema-infrastructure/41-04-SUMMARY.md (engine.ts architecture)

# Source files to reference:
@src/lib/tools/k8s-analyzer/types.ts (K8sLintRule, K8sRuleContext, K8sRuleViolation, ParsedResource)
@src/lib/tools/k8s-analyzer/parser.ts (resolveInstancePath, getNodeLine exports)
@src/lib/tools/compose-validator/rules/security/index.ts (pattern reference for security index)
@src/lib/tools/compose-validator/rules/index.ts (pattern reference for master index)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create container helpers and first 10 security rules (SEC-01 through SEC-05, SEC-09 through SEC-13)</name>
  <files>
    src/lib/tools/k8s-analyzer/container-helpers.ts
    src/lib/tools/k8s-analyzer/rules/security/KA-C001-privileged-container.ts
    src/lib/tools/k8s-analyzer/rules/security/KA-C002-privilege-escalation.ts
    src/lib/tools/k8s-analyzer/rules/security/KA-C003-runs-as-root.ts
    src/lib/tools/k8s-analyzer/rules/security/KA-C004-missing-run-as-non-root.ts
    src/lib/tools/k8s-analyzer/rules/security/KA-C005-uid-zero.ts
    src/lib/tools/k8s-analyzer/rules/security/KA-C009-host-port.ts
    src/lib/tools/k8s-analyzer/rules/security/KA-C010-dangerous-capabilities.ts
    src/lib/tools/k8s-analyzer/rules/security/KA-C011-capabilities-not-dropped.ts
    src/lib/tools/k8s-analyzer/rules/security/KA-C012-writable-filesystem.ts
    src/lib/tools/k8s-analyzer/rules/security/KA-C013-missing-seccomp.ts
    src/lib/tools/k8s-analyzer/rules/security/index.ts
    src/lib/tools/k8s-analyzer/rules/index.ts
  </files>
  <action>
    **Step 1: Create `container-helpers.ts`** at `src/lib/tools/k8s-analyzer/container-helpers.ts`.

    Follow the exact pattern from RESEARCH.md "Pattern 2: Container Extraction Helper":

    - Export `ContainerSpec` interface: `{ container: Record<string, unknown>, jsonPath: string, containerType: 'container' | 'initContainer' }`
    - Export `PodSpec` interface: `{ podSpec: Record<string, unknown>, podSpecPath: string }`
    - Define `POD_SPEC_PATHS` map for exactly 6 kinds:
      - Pod: `/spec`
      - Deployment: `/spec/template/spec`
      - StatefulSet: `/spec/template/spec`
      - DaemonSet: `/spec/template/spec`
      - Job: `/spec/template/spec`
      - CronJob: `/spec/jobTemplate/spec/template/spec`
    - Export `getPodSpec(resource: ParsedResource): PodSpec | null` — navigates JSON along path segments, returns null for non-workload kinds
    - Export `getContainerSpecs(resource: ParsedResource): ContainerSpec[]` — calls getPodSpec, then iterates both `containers` and `initContainers` arrays, building JSON Pointer paths for AST resolution
    - Import `ParsedResource` from `../types` (relative, not from `./types`)

    **Step 2: Create 10 container-level security rules.** Each rule follows the K8s security rule pattern from RESEARCH.md "Pattern 1":

    Each rule file exports a named constant implementing `K8sLintRule`:
    - Import `K8sLintRule, K8sRuleContext, K8sRuleViolation` from `../../types`
    - Import `resolveInstancePath, getNodeLine` from `../../parser`
    - Import `getContainerSpecs` (or `getPodSpec` where needed) from `../../container-helpers`
    - Each rule has: id, title, severity, category: 'security', explanation (mention PSS profile where applicable), fix (with beforeCode/afterCode)
    - `check(ctx)` iterates `ctx.resources`, calls `getContainerSpecs(resource)`, checks JSON values, resolves line numbers via `resolveInstancePath(resource.doc, jsonPath) + getNodeLine(node, ctx.lineCounter)`

    **Rule specifications:**

    **KA-C001** (SEC-01, error, PSS Baseline): Check `container.securityContext?.privileged === true`. Path: `${jsonPath}/securityContext/privileged`.

    **KA-C002** (SEC-02, error, PSS Restricted): Check `container.securityContext?.allowPrivilegeEscalation !== false`. Only fire when securityContext exists but allowPrivilegeEscalation is not explicitly set to false. This means: if securityContext is present AND allowPrivilegeEscalation is undefined or true, fire. If securityContext is completely absent, SEC-20 handles that — but still fire KA-C002 since the default is true. Simplification: fire whenever allowPrivilegeEscalation is NOT explicitly false (i.e., `sc?.allowPrivilegeEscalation !== false` where sc is `container.securityContext`). Path: `${jsonPath}/securityContext` (or `${jsonPath}/securityContext/allowPrivilegeEscalation` if key exists).

    **KA-C003** (SEC-03, warning, PSS Restricted): "Could run as root" — fire when:
    - Container-level `runAsNonRoot` is not true AND container-level `runAsUser` is not set to a non-zero value
    - BUT also check pod-level: if pod-level `securityContext.runAsNonRoot === true` OR pod-level `securityContext.runAsUser` is set to non-zero, do NOT fire (pod-level satisfies the requirement unless container overrides)
    - AND if `runAsUser === 0` is explicitly set, do NOT fire (SEC-05/KA-C005 handles that case)
    - Use `getPodSpec(resource)` to get pod-level securityContext at `${podSpecPath}/securityContext`
    - Path: `${jsonPath}/securityContext` if it exists, else `${jsonPath}` (the container itself)

    **KA-C004** (SEC-04, warning, PSS Restricted): Missing runAsNonRoot — fire when:
    - Neither container-level nor pod-level securityContext has `runAsNonRoot: true`
    - Container-level `runAsNonRoot` is not true AND pod-level `securityContext.runAsNonRoot` is not true
    - Different from KA-C003: KA-C004 checks specifically for the `runAsNonRoot` field, KA-C003 checks the broader "could run as root" condition. In practice, KA-C004 fires when runAsNonRoot is missing/false at both levels; KA-C003 fires when the container could run as root (no runAsNonRoot AND no non-zero runAsUser at either level). Both can fire for the same container — that is correct (they are complementary recommendations).
    - Path: `${jsonPath}/securityContext` or `${jsonPath}`

    **KA-C005** (SEC-05, error, PSS Restricted): Explicit `runAsUser: 0` — fire when:
    - Container-level `securityContext.runAsUser === 0` (explicit UID 0)
    - OR pod-level `securityContext.runAsUser === 0` AND container-level does not override with non-zero
    - When KA-C005 fires for explicit container-level `runAsUser: 0`, KA-C003 must NOT fire for that container
    - Path: `${jsonPath}/securityContext/runAsUser`

    **KA-C009** (SEC-09, info, PSS Baseline): Host port specified — check containers for `ports[*].hostPort` being set (non-null, non-zero). Iterate each container's `ports` array. Path: `${jsonPath}/ports/${portIndex}/hostPort`.

    **KA-C010** (SEC-10, error, PSS Baseline/Restricted): Dangerous capabilities — check `container.securityContext?.capabilities?.add` array for `SYS_ADMIN`, `NET_RAW`, or `ALL`. Also flag any capability not in the PSS Baseline allowed set: `AUDIT_WRITE, CHOWN, DAC_OVERRIDE, FOWNER, FSETID, KILL, MKNOD, NET_BIND_SERVICE, SETFCAP, SETGID, SETPCAP, SETUID, SYS_CHROOT`. Path: `${jsonPath}/securityContext/capabilities/add/${capIndex}`. Message should name the specific dangerous capability.

    **KA-C011** (SEC-11, warning, PSS Restricted): Capabilities not dropped — check that `container.securityContext?.capabilities?.drop` includes `ALL` (case-insensitive). Fire when `drop` is absent or does not contain `ALL`. Path: `${jsonPath}/securityContext/capabilities` or `${jsonPath}/securityContext`.

    **KA-C012** (SEC-12, warning, best practice): Filesystem not read-only — check `container.securityContext?.readOnlyRootFilesystem !== true`. Fire when not explicitly true. Path: `${jsonPath}/securityContext/readOnlyRootFilesystem` or `${jsonPath}/securityContext`.

    **KA-C013** (SEC-13, warning, PSS Baseline): Missing seccomp profile — check both pod-level and container-level `securityContext.seccompProfile`. Fire when neither level has a seccomp profile set. Pod-level profile satisfies requirement for all containers. Path: `${jsonPath}/securityContext/seccompProfile` or pod-level path.

    **Step 3: Create `rules/security/index.ts`** — import all 10 rules (from this task) and export `securityRules: K8sLintRule[]` array. Will be updated in Task 2 to include all 20.

    **Step 4: Create `rules/index.ts`** — following compose-validator pattern:
    - Import `securityRules` from `./security`
    - Import `K8sLintRule` from `../types`
    - Export `allK8sRules: K8sLintRule[]` spreading `...securityRules`
    - Export `DocumentedK8sRule` interface (mirrors compose-validator's DocumentedRule) with id, title, severity, category, explanation, fix
    - Export `allDocumentedK8sRules: DocumentedK8sRule[]` casting allK8sRules
    - Export `getK8sRuleById(id: string): K8sLintRule | undefined` lookup function
    - Comment: "Phase 43 will add: ...reliabilityRules, ...bestPracticeRules"

    **Step 5: Verify TypeScript compiles** — run `npx tsc -p tsconfig.json --noEmit` and confirm no new errors in k8s-analyzer files.
  </action>
  <verify>
    Run `npx tsc -p tsconfig.json --noEmit` — no new errors in k8s-analyzer files.
    Confirm files exist: `ls src/lib/tools/k8s-analyzer/container-helpers.ts src/lib/tools/k8s-analyzer/rules/security/KA-C001-privileged-container.ts src/lib/tools/k8s-analyzer/rules/security/index.ts src/lib/tools/k8s-analyzer/rules/index.ts`
    Spot-check: grep for `getContainerSpecs` in at least 3 rule files to confirm helper usage.
    Spot-check: grep for `category: 'security'` across all rule files — should appear in every one.
  </verify>
  <done>
    container-helpers.ts exports getPodSpec/getContainerSpecs covering Pod, Deployment, StatefulSet, DaemonSet, Job, CronJob.
    10 security rules (KA-C001 through KA-C005, KA-C009 through KA-C013) each implement K8sLintRule with correct severity, PSS profile reference in explanation, and fix code examples.
    SEC-03 vs SEC-05 distinction: KA-C005 fires for explicit runAsUser:0 (error), KA-C003 fires for "could run as root" absence scenario (warning), no overlap.
    Pod-level securityContext inheritance handled in KA-C003, KA-C004, KA-C005, KA-C013.
    security/index.ts exports securityRules array, rules/index.ts exports allK8sRules.
    TypeScript compiles without new errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create remaining 10 security rules (SEC-06 through SEC-08, SEC-14 through SEC-20)</name>
  <files>
    src/lib/tools/k8s-analyzer/rules/security/KA-C006-host-pid.ts
    src/lib/tools/k8s-analyzer/rules/security/KA-C007-host-ipc.ts
    src/lib/tools/k8s-analyzer/rules/security/KA-C008-host-network.ts
    src/lib/tools/k8s-analyzer/rules/security/KA-C014-sensitive-host-path.ts
    src/lib/tools/k8s-analyzer/rules/security/KA-C015-docker-socket-mount.ts
    src/lib/tools/k8s-analyzer/rules/security/KA-C016-sa-token-automount.ts
    src/lib/tools/k8s-analyzer/rules/security/KA-C017-default-service-account.ts
    src/lib/tools/k8s-analyzer/rules/security/KA-C018-secrets-in-env.ts
    src/lib/tools/k8s-analyzer/rules/security/KA-C019-default-namespace.ts
    src/lib/tools/k8s-analyzer/rules/security/KA-C020-missing-security-context.ts
    src/lib/tools/k8s-analyzer/rules/security/index.ts
  </files>
  <action>
    **Step 1: Create 10 remaining security rules.** Same file structure and import pattern as Task 1 rules.

    **KA-C006** (SEC-06, error, PSS Baseline): Host PID namespace shared — use `getPodSpec(resource)`, check `podSpec.hostPID === true`. Path: `${podSpecPath}/hostPID`. Following RESEARCH.md "Pattern 3: Pod-Level Rule" exactly.

    **KA-C007** (SEC-07, error, PSS Baseline): Host IPC namespace shared — same pattern as C006, check `podSpec.hostIPC === true`. Path: `${podSpecPath}/hostIPC`.

    **KA-C008** (SEC-08, warning, PSS Baseline): Host network enabled — check `podSpec.hostNetwork === true`. Path: `${podSpecPath}/hostNetwork`.

    **KA-C014** (SEC-14, error, PSS Baseline): Sensitive host path mounted — iterate `podSpec.volumes` array, check for `hostPath.path` entries matching sensitive paths. Use prefix matching with the SENSITIVE_HOST_PATHS list from RESEARCH.md: `/, /etc, /proc, /sys, /dev, /boot, /root, /home, /var/run, /var/lib/kubelet, /var/lib/docker, /var/lib/containerd, /var/log`. Normalize path (strip trailing slashes) before comparison. Match: `normalized === sensitive || normalized.startsWith(sensitive + '/')`. Path: `${podSpecPath}/volumes/${volIndex}/hostPath/path`. Message should name the specific sensitive path matched.

    **KA-C015** (SEC-15, error, CIS): Docker socket mounted — iterate `podSpec.volumes` array, check for `hostPath.path` matching `/var/run/docker.sock` exactly (or with trailing slash). This is a specific check separate from KA-C014's general sensitive path check. Both can fire for the same volume (docker.sock IS under /var/run which is sensitive). Path: `${podSpecPath}/volumes/${volIndex}/hostPath/path`.

    **KA-C016** (SEC-16, warning, CIS): ServiceAccount token auto-mounted — check `podSpec.automountServiceAccountToken !== false`. Fire when not explicitly set to false. Only check resources that have a PodSpec (6 workload kinds). Path: `${podSpecPath}/automountServiceAccountToken` or `${podSpecPath}`.

    **KA-C017** (SEC-17, warning, CIS): Default ServiceAccount used — check resources that have a PodSpec. Fire when `podSpec.serviceAccountName` is absent, empty, or literally `'default'`. The K8s default behavior is to use the `default` ServiceAccount when none is specified. Path: `${podSpecPath}/serviceAccountName` or `${podSpecPath}`.

    **KA-C018** (SEC-18, warning, CIS): Secrets in environment variables — iterate containers, check `env` array for entries with inline `value` set (NOT `valueFrom`) where the env var name matches a secret-looking suffix pattern. Use regex: `/(PASSWORD|SECRET|TOKEN|API_KEY|APIKEY|AUTH|CREDENTIAL|PRIVATE_KEY)$/i`. Only flag when `value` field is present (a string), NOT when using `valueFrom.secretKeyRef` (which is the K8s-recommended approach). Path: `${jsonPath}/env/${envIndex}/value`. Message should name the specific env var.

    **KA-C019** (SEC-19, info, CIS): Default namespace used — iterate ALL resources (not just workload kinds). Skip cluster-scoped resources: Namespace, ClusterRole, ClusterRoleBinding. Fire when `resource.namespace === 'default'`. Path: resolve `/metadata` node for line number. Following RESEARCH.md "Pattern 6: Resource-Scoped Rule".

    **KA-C020** (SEC-20, warning, best practice): Missing security context entirely — iterate containers, fire when `container.securityContext` is `undefined` (NOT when it is `{}` — an empty object is explicitly set per Pitfall 5). Check with strict `=== undefined` or `!('securityContext' in container)`. Path: `${jsonPath}` (the container element itself since there is no securityContext node to point to).

    **Step 2: Update `rules/security/index.ts`** — add imports for all 10 new rules (KA-C006, KA-C007, KA-C008, KA-C014 through KA-C020) and add them to the securityRules array. Final array should have all 20 rules: KAC001 through KAC020.

    **Step 3: Verify TypeScript compiles** — `npx tsc -p tsconfig.json --noEmit`.
  </action>
  <verify>
    Run `npx tsc -p tsconfig.json --noEmit` — no new errors in k8s-analyzer files.
    Confirm all 20 rule files exist: `ls src/lib/tools/k8s-analyzer/rules/security/KA-C0*.ts | wc -l` should output 20.
    Count rules in security index: `grep -c 'KAC0' src/lib/tools/k8s-analyzer/rules/security/index.ts` should show 20 imports and 20 array entries.
    Spot-check: grep for `getPodSpec` in KA-C006, KA-C007, KA-C008 to confirm pod-level pattern.
    Spot-check: grep for `SENSITIVE_HOST_PATHS` in KA-C014 to confirm path list.
    Spot-check: grep for `securityContext === undefined` or equivalent in KA-C020 to confirm undefined-only check (not empty object).
  </verify>
  <done>
    All 20 security rule files exist and compile.
    Pod-level rules (KA-C006/C007/C008) use getPodSpec for host namespace checks.
    KA-C014 uses prefix matching with the 13 sensitive host paths.
    KA-C015 specifically checks for /var/run/docker.sock.
    KA-C016/C017 check pod-level serviceAccount/automount fields.
    KA-C018 uses suffix regex pattern for secret-looking env var names with inline values only (not secretKeyRef).
    KA-C019 skips cluster-scoped resources and checks for 'default' namespace.
    KA-C020 fires only for undefined securityContext (not empty object).
    security/index.ts aggregates all 20 rules.
    TypeScript compiles without new errors.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc -p tsconfig.json --noEmit` passes with no new errors in k8s-analyzer files
2. `ls src/lib/tools/k8s-analyzer/rules/security/KA-C0*.ts | wc -l` outputs 20
3. `grep -c "category: 'security'" src/lib/tools/k8s-analyzer/rules/security/KA-C0*.ts` shows every rule file has security category
4. `grep "getContainerSpecs\|getPodSpec" src/lib/tools/k8s-analyzer/rules/security/KA-C0*.ts` confirms helper usage across all rules
5. container-helpers.ts contains all 6 workload kinds in POD_SPEC_PATHS including CronJob
6. rules/index.ts exports allK8sRules and allDocumentedK8sRules
</verification>

<success_criteria>
- 20 security rule files implementing K8sLintRule interface with correct id, severity, category, explanation, fix, and check function
- container-helpers.ts handles Pod, Deployment, StatefulSet, DaemonSet, Job, CronJob PodSpec paths
- SEC-03/SEC-05 distinction enforced: no overlap for explicit runAsUser:0
- Pod-level vs container-level securityContext inheritance handled correctly
- SEC-20 fires only for undefined securityContext, not empty object
- SEC-18 flags inline values only, not secretKeyRef
- All code compiles with TypeScript
</success_criteria>

<output>
After completion, create `.planning/phases/42-security-rules/42-01-SUMMARY.md`
</output>
