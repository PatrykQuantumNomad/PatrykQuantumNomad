---
phase: 34-rule-engine-rules-scoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/tools/compose-validator/port-parser.ts
  - src/lib/tools/compose-validator/graph-builder.ts
  - src/lib/tools/compose-validator/rules/semantic/CV-M001-duplicate-ports.ts
  - src/lib/tools/compose-validator/rules/semantic/CV-M002-circular-depends-on.ts
  - src/lib/tools/compose-validator/rules/semantic/CV-M003-undefined-network.ts
  - src/lib/tools/compose-validator/rules/semantic/CV-M004-undefined-volume.ts
  - src/lib/tools/compose-validator/rules/semantic/CV-M005-undefined-secret.ts
  - src/lib/tools/compose-validator/rules/semantic/CV-M006-undefined-config.ts
  - src/lib/tools/compose-validator/rules/semantic/CV-M007-orphan-network.ts
  - src/lib/tools/compose-validator/rules/semantic/CV-M008-orphan-volume.ts
  - src/lib/tools/compose-validator/rules/semantic/CV-M009-orphan-secret.ts
  - src/lib/tools/compose-validator/rules/semantic/CV-M010-depends-on-healthy-no-healthcheck.ts
  - src/lib/tools/compose-validator/rules/semantic/CV-M011-self-referencing-dependency.ts
  - src/lib/tools/compose-validator/rules/semantic/CV-M012-undefined-service-dependency.ts
  - src/lib/tools/compose-validator/rules/semantic/CV-M013-duplicate-container-names.ts
  - src/lib/tools/compose-validator/rules/semantic/CV-M014-port-range-overlap.ts
  - src/lib/tools/compose-validator/rules/semantic/CV-M015-invalid-image-reference.ts
  - src/lib/tools/compose-validator/rules/semantic/index.ts
autonomous: true
requirements: [SEM-01, SEM-02, SEM-03, SEM-04, SEM-05, SEM-06, SEM-07, SEM-08, SEM-09, SEM-10, SEM-11, SEM-12, SEM-13, SEM-14, SEM-15]

must_haves:
  truths:
    - "Port conflict detection finds duplicate host ports across services including range overlaps"
    - "Circular depends_on chains are detected via topological sort and cycle participants identified"
    - "Undefined resource references (networks, volumes, secrets, configs) produce violations with the exact line of the reference"
    - "Orphan definitions (networks, volumes, secrets not used by any service) produce violations"
    - "Invalid image references, self-referencing dependencies, and duplicate container names are flagged"
  artifacts:
    - path: "src/lib/tools/compose-validator/port-parser.ts"
      provides: "Port string parser with ParsedPort interface, parsePortString, expandPortRange, portsConflict"
      exports: ["ParsedPort", "parsePortString", "expandPortRange", "portsConflict"]
    - path: "src/lib/tools/compose-validator/graph-builder.ts"
      provides: "Dependency graph builder with Kahn's cycle detection"
      exports: ["ServiceNode", "DependencyEdge", "DependencyGraph", "CycleDetectionResult", "buildDependencyGraph", "detectCycles"]
    - path: "src/lib/tools/compose-validator/rules/semantic/index.ts"
      provides: "Semantic rules registry array"
      exports: ["semanticRules"]
  key_links:
    - from: "src/lib/tools/compose-validator/rules/semantic/CV-M001-duplicate-ports.ts"
      to: "src/lib/tools/compose-validator/port-parser.ts"
      via: "import parsePortString, portsConflict"
      pattern: "import.*from.*port-parser"
    - from: "src/lib/tools/compose-validator/rules/semantic/CV-M002-circular-depends-on.ts"
      to: "src/lib/tools/compose-validator/graph-builder.ts"
      via: "import buildDependencyGraph, detectCycles"
      pattern: "import.*from.*graph-builder"
    - from: "src/lib/tools/compose-validator/rules/semantic/CV-M014-port-range-overlap.ts"
      to: "src/lib/tools/compose-validator/port-parser.ts"
      via: "import parsePortString, expandPortRange"
      pattern: "import.*from.*port-parser"
---

<objective>
Create shared utilities (port parser, dependency graph builder with cycle detection) and all 15 semantic analysis rules for Docker Compose validation.

Purpose: Semantic rules are the most complex rule category -- they perform cross-service analysis (port conflicts, circular dependencies, undefined references, orphan definitions) requiring shared utility modules. The graph builder is also exported for Phase 36's dependency graph visualization.

Output: port-parser.ts, graph-builder.ts, 15 semantic rule files (CV-M001 through CV-M015), and semantic/index.ts registry
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-rule-engine-rules-scoring/34-RESEARCH.md
@.planning/phases/33-yaml-parsing-schema-validation-foundation/33-01-SUMMARY.md
@.planning/phases/33-yaml-parsing-schema-validation-foundation/33-02-SUMMARY.md

@src/lib/tools/compose-validator/types.ts
@src/lib/tools/compose-validator/parser.ts
@src/lib/tools/compose-validator/rules/schema/index.ts
@src/lib/tools/dockerfile-analyzer/engine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create port-parser.ts and graph-builder.ts shared utilities</name>
  <files>
    src/lib/tools/compose-validator/port-parser.ts
    src/lib/tools/compose-validator/graph-builder.ts
  </files>
  <action>
Create two shared utility modules used by semantic rules and downstream phases.

**port-parser.ts** (~80 lines):
- Export `ParsedPort` interface with fields: `hostIp?: string`, `hostPort?: number`, `hostPortEnd?: number`, `containerPort: number`, `containerPortEnd?: number`, `protocol: 'tcp' | 'udp'`
- Export `parsePortString(port: string): ParsedPort | null` that handles ALL Docker Compose short-syntax port formats:
  - `"80"` (container only)
  - `"8080:80"` (host:container)
  - `"127.0.0.1:8080:80"` (ip:host:container)
  - `"8080:80/udp"` (with protocol)
  - `"8000-8010:8000-8010"` (port ranges)
  - `"127.0.0.1::80"` (ip with ephemeral host port -- empty string between colons)
  - Return null for unparseable strings
  - Strip /tcp or /udp suffix first, then split on colons
  - When 3 parts: first is IP if it contains a dot, otherwise it's host range
  - Parse ranges with dash: `"8000-8010"` -> start=8000, end=8010
- Export `parseLongSyntaxPort(portMap: any): ParsedPort | null` that extracts from YAML map nodes with keys `target`, `published`, `host_ip`, `protocol` (handles long-syntax port objects)
- Export `expandPortRange(start: number, end?: number): number[]` that expands a range into individual port numbers
- Export `portsConflict(a: ParsedPort, b: ParsedPort): boolean` that checks if two ports conflict (same protocol + same/overlapping IP + overlapping host port range). Treat undefined hostIp as '0.0.0.0'. Two ports on different IPs do NOT conflict. A port with IP '0.0.0.0' conflicts with any specific IP.

**graph-builder.ts** (~80 lines):
- Export interfaces: `ServiceNode { name: string; dependsOn: string[] }`, `DependencyEdge { from: string; to: string; condition?: string }`, `DependencyGraph { nodes: ServiceNode[]; edges: DependencyEdge[] }`, `CycleDetectionResult { hasCycle: boolean; cycleParticipants: string[]; topologicalOrder: string[] }`
- Export `extractDependsOn(serviceNode: any): { service: string; condition?: string }[]` helper that handles BOTH depends_on forms:
  - Short form: `depends_on: [redis, db]` (YAMLSeq of scalars) -- use `isSeq` + `isScalar`
  - Long form: `depends_on: { redis: { condition: service_healthy } }` (YAMLMap with nested maps) -- use `isMap` + `isPair` + extract condition from nested map
  - Return empty array if depends_on key not found or value is null
  - Import `isMap, isPair, isScalar, isSeq` from 'yaml'
- Export `buildDependencyGraph(services: Map<string, any>): DependencyGraph` that iterates all services, calls extractDependsOn for each, builds nodes and edges arrays
- Export `detectCycles(graph: DependencyGraph): CycleDetectionResult` using Kahn's algorithm (BFS topological sort):
  1. Build adjacency map and in-degree counts from graph edges (only for nodes that exist in graph.nodes)
  2. Start with queue of nodes with in-degree 0
  3. Process queue: remove node, decrement neighbors' in-degrees, add new zero-degree nodes to queue
  4. Nodes NOT in the topological order are cycle participants
  </action>
  <verify>
Run `npx astro build` to confirm no TypeScript compilation errors. Verify both files export the documented interfaces and functions by checking the file content.
  </verify>
  <done>
port-parser.ts exports ParsedPort, parsePortString, parseLongSyntaxPort, expandPortRange, portsConflict. graph-builder.ts exports ServiceNode, DependencyEdge, DependencyGraph, CycleDetectionResult, extractDependsOn, buildDependencyGraph, detectCycles. Both compile without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create 15 semantic rules and semantic/index.ts registry</name>
  <files>
    src/lib/tools/compose-validator/rules/semantic/CV-M001-duplicate-ports.ts
    src/lib/tools/compose-validator/rules/semantic/CV-M002-circular-depends-on.ts
    src/lib/tools/compose-validator/rules/semantic/CV-M003-undefined-network.ts
    src/lib/tools/compose-validator/rules/semantic/CV-M004-undefined-volume.ts
    src/lib/tools/compose-validator/rules/semantic/CV-M005-undefined-secret.ts
    src/lib/tools/compose-validator/rules/semantic/CV-M006-undefined-config.ts
    src/lib/tools/compose-validator/rules/semantic/CV-M007-orphan-network.ts
    src/lib/tools/compose-validator/rules/semantic/CV-M008-orphan-volume.ts
    src/lib/tools/compose-validator/rules/semantic/CV-M009-orphan-secret.ts
    src/lib/tools/compose-validator/rules/semantic/CV-M010-depends-on-healthy-no-healthcheck.ts
    src/lib/tools/compose-validator/rules/semantic/CV-M011-self-referencing-dependency.ts
    src/lib/tools/compose-validator/rules/semantic/CV-M012-undefined-service-dependency.ts
    src/lib/tools/compose-validator/rules/semantic/CV-M013-duplicate-container-names.ts
    src/lib/tools/compose-validator/rules/semantic/CV-M014-port-range-overlap.ts
    src/lib/tools/compose-validator/rules/semantic/CV-M015-invalid-image-reference.ts
    src/lib/tools/compose-validator/rules/semantic/index.ts
  </files>
  <action>
Create all 15 semantic rules implementing `ComposeLintRule` interface. Each rule file exports a single const (e.g., `CVM001`) with id, title, severity, category: 'semantic', explanation (expert-level), fix (with beforeCode/afterCode), and check(ctx) method.

All rules import from 'yaml' (`isMap, isPair, isScalar, isSeq`) and from `../../parser` (`getNodeLine`). Use `ctx.lineCounter` for line extraction. Report violations on the SPECIFIC property line, not the service name line.

**Rule specifications:**

**CV-M001 (error):** Duplicate exported host ports. Import `parsePortString, parseLongSyntaxPort, portsConflict` from `../../port-parser`. Collect all port entries across ALL services (both short string syntax via `isScalar` and long map syntax via `isMap`). For each pair of ports from DIFFERENT services, check `portsConflict()`. Report on the second occurrence's port line. Message: "Port {port} in service '{b}' conflicts with service '{a}'."

**CV-M002 (error):** Circular depends_on. Import `buildDependencyGraph, detectCycles` from `../../graph-builder`. Build graph from ctx.services, run detectCycles. For each cycle participant, find the depends_on key node in that service's AST and report its line. Message: "Service '{name}' is part of a circular dependency chain."

**CV-M003 (error):** Undefined network reference. Build `Set` from `ctx.networks.keys()`. Iterate services looking for `networks` key. Handle BOTH YAMLSeq (list of names) and YAMLMap (names as keys). Skip 'default' network (implicit). Report on the network name node. Message: "Service '{svc}' references undefined network '{net}'."

**CV-M004 (error):** Undefined volume reference. Build `Set` from `ctx.volumes.keys()`. Iterate services looking for `volumes` key. For each volume entry: if short syntax string, check if it's a named volume (not a bind mount -- bind mounts start with `.`, `/`, `~`, or contain `$`). Only named volumes must exist in top-level. If long syntax map, check `type: volume` entries where `source` is not empty. Report on the volume entry node. Message: "Service '{svc}' references undefined volume '{vol}'."

**CV-M005 (error):** Undefined secret reference. Build `Set` from `ctx.secrets.keys()`. Iterate services looking for `secrets` key. Handle both short form (seq of strings) and long form (seq of maps with `source` key, defaulting to the item name if no source). Report on the secret name node. Message: "Service '{svc}' references undefined secret '{sec}'."

**CV-M006 (error):** Undefined config reference. Same pattern as CV-M005 but for `configs` key and `ctx.configs`. Message: "Service '{svc}' references undefined config '{cfg}'."

**CV-M007 (warning):** Orphan network. Collect all network names referenced by any service (same traversal as M003 but building a used-set). Compare against `ctx.networks.keys()`. For each unused network, report on the network's key in the top-level networks map (find the node via `ctx.doc.contents` traversal). Message: "Network '{net}' is defined but not used by any service."

**CV-M008 (warning):** Orphan volume. Same pattern as M007 but for volumes. Only count named volume references (skip bind mounts). Report on unused top-level volume definitions. Message: "Volume '{vol}' is defined but not used by any service."

**CV-M009 (warning):** Orphan secret. Same pattern as M007 but for secrets. Message: "Secret '{sec}' is defined but not used by any service."

**CV-M010 (error):** depends_on with service_healthy but target has no healthcheck. Import `extractDependsOn` from `../../graph-builder`. For each service, extract depends_on entries. For entries with condition 'service_healthy', look up the target service in ctx.services and check if it has a 'healthcheck' key (via AST traversal). If not, report on the depends_on entry line. Message: "Service '{svc}' depends on '{target}' with condition service_healthy, but '{target}' has no healthcheck."

**CV-M011 (error):** Self-referencing dependency. Import `extractDependsOn` from `../../graph-builder`. For each service, check if any depends_on entry references itself. Report on the depends_on key line. Message: "Service '{svc}' depends on itself."

**CV-M012 (error):** Dependency on undefined service. Import `extractDependsOn` from `../../graph-builder`. Build `Set` from `ctx.services.keys()`. For each depends_on entry, check if the referenced service exists. Report on the reference node line. Message: "Service '{svc}' depends on undefined service '{target}'."

**CV-M013 (error):** Duplicate container names. Collect `container_name` values across all services. If same name appears in multiple services, report on the second occurrence. Message: "Container name '{name}' is used by both service '{a}' and '{b}'."

**CV-M014 (warning):** Port range overlap between services. Similar to M001 but specifically for overlapping ranges (not exact duplicates). Import `parsePortString, parseLongSyntaxPort, expandPortRange` from `../../port-parser`. For ports from different services, expand ranges and check set intersection. Only report if there is partial overlap (full duplicates already caught by M001, so M014 can include all overlaps or just be the range-aware version). Actually, M001 uses `portsConflict` which already handles ranges, so M014 should focus on range-specific overlaps. Implementation: M001 and M014 can share logic. M001 catches exact single-port conflicts. M014 catches range overlaps where ranges partially overlap. For simplicity, have M001 handle ALL port conflicts (including range overlaps) and have M014 be a no-op that returns empty -- OR better: M001 handles single-port duplicates (hostPort === hostPort) and M014 handles range overlaps. The cleanest approach: both use portsConflict (which handles ranges). M001 fires for conflicts where BOTH ports are single ports. M014 fires for conflicts where at least one port is a range. This avoids duplicate violations. Message: "Port range in service '{b}' overlaps with ports in service '{a}'."

**CV-M015 (warning):** Invalid image reference format. For each service with an `image` key, validate the string against a simplified OCI reference regex: `/^[a-z0-9]([a-z0-9._\/-]*[a-z0-9])?(:[a-zA-Z0-9_.-]+)?(@sha256:[a-fA-F0-9]{64})?$/`. Skip services without `image` key (they use `build`). Report on the image value node. Message: "Service '{svc}' has invalid image reference '{img}'."

**semantic/index.ts:** Import all 15 rules and export as `semanticRules: ComposeLintRule[]` array.

Follow the naming convention from schema rules: variable names like CVM001, CVM002, etc.
  </action>
  <verify>
Run `npx astro build` to confirm no TypeScript compilation errors. Verify semantic/index.ts exports a `semanticRules` array with 15 entries.
  </verify>
  <done>
All 15 semantic rules exist as separate files under rules/semantic/, each implementing ComposeLintRule with id, title, severity, category, explanation, fix, and check() method. The semantic/index.ts exports semanticRules array with all 15 rules. Astro build succeeds.
  </done>
</task>

</tasks>

<verification>
1. `npx astro build` succeeds with no TypeScript errors
2. port-parser.ts exports ParsedPort, parsePortString, parseLongSyntaxPort, expandPortRange, portsConflict
3. graph-builder.ts exports ServiceNode, DependencyEdge, DependencyGraph, CycleDetectionResult, extractDependsOn, buildDependencyGraph, detectCycles
4. 15 files exist in rules/semantic/ (CV-M001 through CV-M015) plus index.ts
5. Each rule file exports a ComposeLintRule with all required fields and a check() method
6. Rules use AST traversal (isMap/isPair/isScalar/isSeq) for line-accurate violation reporting
</verification>

<success_criteria>
- port-parser handles all 6+ Docker Compose short-syntax port formats plus long-syntax map ports
- graph-builder detects cycles using Kahn's algorithm and exports graph structure for Phase 36
- All 15 semantic rules compile and conform to ComposeLintRule interface
- Rules handle both short and long syntax forms for depends_on, ports, volumes, secrets, configs
- Volume rules distinguish named volumes from bind mounts (no false positives on bind mounts)
- Astro build succeeds with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/34-rule-engine-rules-scoring/34-01-SUMMARY.md`
</output>
