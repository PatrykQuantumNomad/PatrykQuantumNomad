---
phase: 34-rule-engine-rules-scoring
plan: 03
type: execute
wave: 2
depends_on: ["34-01", "34-02"]
files_modified:
  - src/lib/tools/compose-validator/rules/style/CV-F001-services-not-alphabetical.ts
  - src/lib/tools/compose-validator/rules/style/CV-F002-ports-not-quoted.ts
  - src/lib/tools/compose-validator/rules/style/CV-F003-inconsistent-port-quoting.ts
  - src/lib/tools/compose-validator/rules/style/index.ts
  - src/lib/tools/compose-validator/rules/index.ts
  - src/lib/tools/compose-validator/engine.ts
  - src/lib/tools/compose-validator/scorer.ts
autonomous: true
requirements: [STYLE-01, STYLE-02, STYLE-03, SCORE-01, SCORE-02, SCORE-03, SCORE-04]

must_haves:
  truths:
    - "Style rules detect non-alphabetical service ordering, unquoted ports, and inconsistent port quoting"
    - "The rule engine runs all 44 rules (8 schema + 36 custom) and produces sorted violations"
    - "The scoring engine produces a 0-100 score with letter grade using category weights and diminishing returns"
    - "Per-category sub-scores are computed for all 5 categories"
  artifacts:
    - path: "src/lib/tools/compose-validator/rules/style/index.ts"
      provides: "Style rules registry array"
      exports: ["styleRules"]
    - path: "src/lib/tools/compose-validator/rules/index.ts"
      provides: "Master rule registry combining semantic, security, best-practice, style rules"
      exports: ["allComposeRules", "getComposeRuleById"]
    - path: "src/lib/tools/compose-validator/engine.ts"
      provides: "Rule engine orchestrator"
      exports: ["ComposeEngineResult", "runComposeEngine"]
    - path: "src/lib/tools/compose-validator/scorer.ts"
      provides: "Category-weighted scoring with diminishing returns"
      exports: ["computeComposeScore"]
  key_links:
    - from: "src/lib/tools/compose-validator/rules/index.ts"
      to: "src/lib/tools/compose-validator/rules/semantic/index.ts"
      via: "import semanticRules"
      pattern: "import.*semanticRules.*from.*semantic"
    - from: "src/lib/tools/compose-validator/rules/index.ts"
      to: "src/lib/tools/compose-validator/rules/security/index.ts"
      via: "import securityRules"
      pattern: "import.*securityRules.*from.*security"
    - from: "src/lib/tools/compose-validator/rules/index.ts"
      to: "src/lib/tools/compose-validator/rules/best-practice/index.ts"
      via: "import bestPracticeRules"
      pattern: "import.*bestPracticeRules.*from.*best-practice"
    - from: "src/lib/tools/compose-validator/engine.ts"
      to: "src/lib/tools/compose-validator/rules/index.ts"
      via: "import allComposeRules"
      pattern: "import.*allComposeRules.*from.*rules"
    - from: "src/lib/tools/compose-validator/engine.ts"
      to: "src/lib/tools/compose-validator/schema-validator.ts"
      via: "import validateComposeSchema, categorizeSchemaErrors"
      pattern: "import.*categorizeSchemaErrors.*from.*schema-validator"
    - from: "src/lib/tools/compose-validator/scorer.ts"
      to: "src/lib/tools/compose-validator/rules/index.ts"
      via: "import allComposeRules for rule lookup"
      pattern: "import.*allComposeRules.*from.*rules"
    - from: "src/lib/tools/compose-validator/scorer.ts"
      to: "src/lib/tools/compose-validator/rules/schema/index.ts"
      via: "import schemaRules for schema rule lookup"
      pattern: "import.*schemaRules.*from.*rules/schema"
---

<objective>
Create 3 style rules, the master rule registry, the rule engine orchestrator, and the category-weighted scoring engine -- completing the full validation pipeline.

Purpose: This plan wires everything together. The style rules (3) are small and complete the rule set. The master registry aggregates all 36 custom rules. The engine orchestrates parsing + schema validation + custom rules. The scorer produces the final 0-100 grade. After this plan, calling `runComposeEngine()` + `computeComposeScore()` produces a complete analysis result.

Output: 3 style rule files, style/index.ts, master rules/index.ts, engine.ts, scorer.ts
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-rule-engine-rules-scoring/34-RESEARCH.md
@.planning/phases/33-yaml-parsing-schema-validation-foundation/33-01-SUMMARY.md
@.planning/phases/33-yaml-parsing-schema-validation-foundation/33-02-SUMMARY.md

# Prior plan summaries from this phase (needed for file locations and exports)
@.planning/phases/34-rule-engine-rules-scoring/34-01-SUMMARY.md
@.planning/phases/34-rule-engine-rules-scoring/34-02-SUMMARY.md

@src/lib/tools/compose-validator/types.ts
@src/lib/tools/compose-validator/parser.ts
@src/lib/tools/compose-validator/schema-validator.ts
@src/lib/tools/compose-validator/rules/schema/index.ts
@src/lib/tools/dockerfile-analyzer/engine.ts
@src/lib/tools/dockerfile-analyzer/scorer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create 3 style rules, style/index.ts, and master rules/index.ts</name>
  <files>
    src/lib/tools/compose-validator/rules/style/CV-F001-services-not-alphabetical.ts
    src/lib/tools/compose-validator/rules/style/CV-F002-ports-not-quoted.ts
    src/lib/tools/compose-validator/rules/style/CV-F003-inconsistent-port-quoting.ts
    src/lib/tools/compose-validator/rules/style/index.ts
    src/lib/tools/compose-validator/rules/index.ts
  </files>
  <action>
Create 3 style rules and the master rule registry.

**Style rules** (category: 'style'):

**CV-F001 (info):** Services not alphabetically ordered. Access `ctx.doc.contents` to find the `services` top-level key. Get the services map node (YAMLMap). Extract key names IN ORDER from the map items array. Compare against a sorted copy. If different, report on the first out-of-order service key node. Message: "Services are not in alphabetical order. Found '{first_wrong}' where '{expected}' was expected."
Fix: Reorder services alphabetically for readability.

**CV-F002 (info):** Ports not quoted (YAML base-60 risk). Iterate services, find `ports` key (YAMLSeq). For each scalar item (skip long-syntax maps), check the scalar node's `type` property. If `type === 'PLAIN'` (which means the value is unquoted) AND the string representation contains a colon, the port is at risk of YAML 1.1 sexagesimal interpretation. Report on the port node. Message: "Port '{port}' in service '{svc}' is not quoted. Unquoted port values risk YAML sexagesimal (base-60) interpretation."

IMPORTANT: The yaml package's Scalar nodes have a `type` property. Check if it is one of `Scalar.PLAIN`, `Scalar.QUOTE_DOUBLE`, `Scalar.QUOTE_SINGLE`, `Scalar.BLOCK_LITERAL`, `Scalar.BLOCK_FOLDED`. For unquoted scalars it will be `Scalar.PLAIN` which equals the string `'PLAIN'`. Access via `(node as any).type === 'PLAIN'` or import `Scalar` from 'yaml' and check `node.type === Scalar.PLAIN`. If `type` property doesn't work as expected, fall back to checking if `node.type` is falsy or check the raw YAML at the node offset.

Fix: Quote all port values, e.g., `"8080:80"` instead of `8080:80`.

**CV-F003 (info):** Inconsistent quoting in port values. Iterate services, find `ports` key (YAMLSeq). Collect the quoting style of each scalar port entry (PLAIN vs QUOTE_DOUBLE vs QUOTE_SINGLE). If there is a mix of quoted and unquoted within the same service's ports, report on the first unquoted entry. Only applies to short-syntax string ports (skip long-syntax maps). Message: "Service '{svc}' has inconsistent port quoting. Mix of quoted and unquoted port values."
Fix: Quote all port values consistently.

**style/index.ts:** Import all 3 rules, export as `styleRules: ComposeLintRule[]` array.

**Master rules/index.ts:**
```typescript
import type { ComposeLintRule } from '../types';
import { semanticRules } from './semantic';
import { securityRules } from './security';
import { bestPracticeRules } from './best-practice';
import { styleRules } from './style';

// NOTE: Schema rules are NOT included -- they use SchemaRuleMetadata (no check method).
// Schema violations are generated by categorizeSchemaErrors() in schema-validator.ts.

/** All custom lint rules with check() methods. 44 total (15 semantic + 14 security + 12 best-practice + 3 style). */
export const allComposeRules: ComposeLintRule[] = [
  ...semanticRules,
  ...securityRules,
  ...bestPracticeRules,
  ...styleRules,
];

/** Look up a rule by ID. Returns undefined if not found. */
export function getComposeRuleById(id: string): ComposeLintRule | undefined {
  return allComposeRules.find((r) => r.id === id);
}
```

Note the comment says "44 total" but this is 15+14+12+3 = 44 MINUS the 8 schema rules that are separate = 36 custom rules with check() methods, plus the 8 schema rules without check() = 44 total rules in the system. The comment in the actual code should say "36 total custom rules" to be accurate. The 8 schema rules are counted separately in the engine.
  </action>
  <verify>
Run `npx astro build` to confirm no TypeScript compilation errors. Verify rules/index.ts exports `allComposeRules` with 36 entries (15+14+12+3=44, minus 8 schema = 36). Wait -- 15+14+12+3 = 44. The allComposeRules array has 44 entries. The schema rules are separate (8 more). Total rule system is 52. Verify the count matches.
  </verify>
  <done>
All 3 style rules exist under rules/style/. Style/index.ts exports styleRules with 3 entries. Master rules/index.ts combines all 4 category arrays into allComposeRules (44 custom rules with check methods). Schema rules (8) remain separate in rules/schema/index.ts. Astro build succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create engine.ts and scorer.ts</name>
  <files>
    src/lib/tools/compose-validator/engine.ts
    src/lib/tools/compose-validator/scorer.ts
  </files>
  <action>
Create the rule engine orchestrator and scoring engine, mirroring the Dockerfile Analyzer's `engine.ts` and `scorer.ts` patterns.

**engine.ts** (~50 lines):
- Import types: `ComposeRuleContext`, `ComposeRuleViolation` from `./types`
- Import: `ComposeParseResult` from `./parser`
- Import: `allComposeRules` from `./rules`
- Import: `validateComposeSchema`, `categorizeSchemaErrors` from `./schema-validator`
- Export interface `ComposeEngineResult { violations: ComposeRuleViolation[]; rulesRun: number; rulesPassed: number; }`
- Export function `runComposeEngine(parseResult: ComposeParseResult, rawText: string): ComposeEngineResult`:
  1. Start violations array with `parseResult.parseErrors` (CV-S001 parse errors from Phase 33)
  2. If `parseResult.normalizedJson` exists, run schema validation:
     - Call `validateComposeSchema(parseResult.normalizedJson)`
     - Call `categorizeSchemaErrors(schemaErrors, parseResult.doc, parseResult.lineCounter)`
     - Add schema violations to violations array
  3. If `parseResult.json` exists, build `ComposeRuleContext` from parseResult fields (doc, rawText, lineCounter, json, services, networks, volumes, secrets, configs) and iterate `allComposeRules`:
     - For each rule, call `rule.check(ctx)`
     - If no violations returned, increment rulesPassed counter
     - Add all violations to the array
  4. Sort violations by `line` then `column`
  5. Return `{ violations, rulesRun: allComposeRules.length + 8, rulesPassed }` (the +8 counts schema rules)

**scorer.ts** (~70 lines):
Mirror `src/lib/tools/dockerfile-analyzer/scorer.ts` exactly but with Compose-specific types and weights.

- Import types: `ComposeRuleViolation`, `ComposeCategory`, `ComposeSeverity`, `ComposeScoreDeduction`, `ComposeCategoryScore`, `ComposeScoreResult` from `./types`
- Import: `allComposeRules` from `./rules`
- Import: `schemaRules` from `./rules/schema`

- Define `CATEGORY_WEIGHTS`: `{ security: 30, semantic: 25, 'best-practice': 20, schema: 15, style: 10 }`
- Define `SEVERITY_DEDUCTIONS`: `{ error: 15, warning: 8, info: 3 }`
- Define `ALL_CATEGORIES`: `['security', 'semantic', 'best-practice', 'schema', 'style']`

- Export function `computeComposeScore(violations: ComposeRuleViolation[]): ComposeScoreResult`:
  1. Build rule lookup Map from allComposeRules AND schemaRules (both contribute id -> severity/category)
  2. Initialize categoryDeductions record for all 5 categories
  3. For each violation, look up rule, compute diminishing returns deduction: `points = basePoints / (1 + 0.3 * priorCount)`, round to 2 decimal places
  4. Compute per-category scores: `score = Math.max(0, Math.round((100 - totalDeduction) * 100) / 100)`
  5. Compute weighted aggregate: `overall = Math.round(sum(category.score * category.weight / 100))`
  6. Return `{ overall, grade: computeGrade(overall), categories, deductions }`

- Private function `computeGrade(score: number): string` with thresholds: A+ >= 97, A >= 93, A- >= 90, B+ >= 87, B >= 83, B- >= 80, C+ >= 77, C >= 73, C- >= 70, D+ >= 67, D >= 63, D- >= 60, F < 60

These thresholds match the Dockerfile Analyzer's grade scale exactly.
  </action>
  <verify>
Run `npx astro build` to confirm no TypeScript compilation errors. Verify engine.ts exports `runComposeEngine` and `ComposeEngineResult`. Verify scorer.ts exports `computeComposeScore`. Confirm the category weights sum to 100 (30+25+20+15+10=100).
  </verify>
  <done>
engine.ts orchestrates the full pipeline: parse errors + schema validation + 44 custom rules, producing sorted violations with rulesRun count. scorer.ts computes category-weighted 0-100 score with diminishing returns formula matching Dockerfile Analyzer. Grade thresholds A+ through F. Both files compile without errors. The full Phase 34 validation pipeline is complete.
  </done>
</task>

</tasks>

<verification>
1. `npx astro build` succeeds with no TypeScript errors
2. 3 files exist in rules/style/ (CV-F001 through CV-F003) plus index.ts
3. rules/index.ts exports allComposeRules array combining all 4 category arrays (44 rules total)
4. engine.ts exports runComposeEngine that runs schema + custom rules and returns sorted violations
5. scorer.ts exports computeComposeScore with correct category weights summing to 100
6. Grade scale matches Dockerfile Analyzer (A+ through F)
7. Diminishing returns formula: basePoints / (1 + 0.3 * priorCount)
8. Schema rules (8) are included in scoring via separate schemaRules import (NOT in allComposeRules array)
</verification>

<success_criteria>
- Style rules correctly check alphabetical ordering, quoting style via AST scalar type, and quoting consistency
- Master registry contains exactly 44 rules (15+14+12+3)
- Engine runs all rules and produces violations sorted by line/column
- Scorer produces weighted score with Security 30%, Semantic 25%, Best Practice 20%, Schema 15%, Style 10%
- A clean compose file scores 100/A+, a file with violations scores proportionally lower
- Astro build succeeds with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/34-rule-engine-rules-scoring/34-03-SUMMARY.md`
</output>
