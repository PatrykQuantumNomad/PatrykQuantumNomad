---
phase: 28-data-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db-compass/schema.ts
  - src/lib/db-compass/dimensions.ts
  - src/content.config.ts
autonomous: true
requirements:
  - DATA-01
  - DATA-02
  - DATA-03
  - DATA-05
  - DATA-06
  - DATA-07

must_haves:
  truths:
    - "Zod schema validates 12-model JSON with 8 dimension scores (int 1-10), justifications, crossCategory, CAP theorem, and topDatabases"
    - "Dimension definitions export 8 entries with key, symbol, name, shortName, and description"
    - "Content collection 'dbModels' is registered and loads from src/data/db-compass/models.json"
  artifacts:
    - path: "src/lib/db-compass/schema.ts"
      provides: "Zod schema + TypeScript types + helper functions"
      exports: ["dbModelSchema", "DbModel", "Scores", "totalScore", "dimensionScores"]
      contains: "z.object"
    - path: "src/lib/db-compass/dimensions.ts"
      provides: "8 dimension definitions with metadata"
      exports: ["DIMENSIONS", "Dimension"]
      contains: "operationalSimplicity"
    - path: "src/content.config.ts"
      provides: "dbModels collection registration"
      contains: "dbModels"
  key_links:
    - from: "src/content.config.ts"
      to: "src/lib/db-compass/schema.ts"
      via: "import { dbModelSchema }"
      pattern: "import.*dbModelSchema.*db-compass/schema"
    - from: "src/lib/db-compass/schema.ts"
      to: "src/lib/db-compass/dimensions.ts"
      via: "dimension keys must match between schema scores object and dimensions array"
      pattern: "scalability|performance|reliability|operationalSimplicity|queryFlexibility|schemaFlexibility|ecosystemMaturity|learningCurve"
---

<objective>
Create the Zod schema, dimension definitions, and content collection registration for the Database Compass data layer.

Purpose: Establish the structural foundation that all 12 database model entries must conform to. The schema enforces data quality (score ranges, required justifications, CAP profiles, topDatabases constraints) at build time. This mirrors the Beauty Index pattern (schema.ts + dimensions.ts + content.config.ts) with extensions for nested scores, justifications, crossCategory, and CAP theorem.

Output: Three files -- schema with types/helpers, dimensions library, and updated content.config.ts -- ready to validate the models.json data created in Plan 02.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-data-foundation/28-RESEARCH.md
@src/content.config.ts
@src/lib/beauty-index/schema.ts
@src/lib/beauty-index/dimensions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zod schema and dimension definitions</name>
  <files>
    src/lib/db-compass/schema.ts
    src/lib/db-compass/dimensions.ts
  </files>
  <action>
Create `src/lib/db-compass/schema.ts` following the Beauty Index schema pattern (`src/lib/beauty-index/schema.ts`). Use `import { z } from 'astro/zod'` (not `zod` directly -- Astro 5 convention).

Schema must define:

1. `dimensionScoreSchema` -- `z.number().int().min(1).max(10)` (reuse naming convention from Beauty Index)

2. `scoresSchema` -- nested object with exactly these 8 keys: `scalability`, `performance`, `reliability`, `operationalSimplicity`, `queryFlexibility`, `schemaFlexibility`, `ecosystemMaturity`, `learningCurve`. All use `dimensionScoreSchema`.

3. `justificationsSchema` -- parallel object with the same 8 keys, all `z.string()`. These are required (not optional) to enforce score accountability.

4. `topDatabaseSchema` -- object with `name: z.string()`, `description: z.string()`, `license: z.string()`, `url: z.string().url()`.

5. `capTheoremSchema` -- object with `classification: z.enum(['CP', 'AP', 'CA', 'Tunable'])`, `notes: z.string()`.

6. `dbModelSchema` -- the main schema with fields:
   - `id: z.string()` -- machine identifier (e.g., "key-value")
   - `name: z.string()` -- display name (e.g., "Key-Value Store")
   - `slug: z.string()` -- URL slug (e.g., "key-value")
   - `icon: z.string()` -- icon identifier for future component use
   - `complexityPosition: z.number().min(0).max(1)` -- position on simple-to-complex spectrum (0.0-1.0)
   - `summary: z.string()` -- one-paragraph model description
   - `characterSketch: z.string()` -- personality-style description (like Beauty Index)
   - `scores: scoresSchema` -- 8 dimension scores
   - `justifications: justificationsSchema` -- per-dimension score explanations
   - `capTheorem: capTheoremSchema` -- CAP classification + notes
   - `crossCategory: z.array(z.string()).default([])` -- related model type IDs for multi-model databases
   - `strengths: z.array(z.string()).min(2).max(5)` -- model advantages
   - `weaknesses: z.array(z.string()).min(2).max(5)` -- model disadvantages
   - `bestFor: z.array(z.string()).min(2).max(6)` -- recommended use cases
   - `avoidWhen: z.array(z.string()).min(1).max(4)` -- anti-patterns
   - `topDatabases: z.array(topDatabaseSchema).min(3).max(6)` -- representative databases
   - `useCases: z.array(z.string()).min(2).max(6)` -- short use case labels

7. Export TypeScript types via `z.infer`:
   - `export type DbModel = z.infer<typeof dbModelSchema>`
   - `export type Scores = z.infer<typeof scoresSchema>`

8. Export helper functions:
   - `totalScore(model: DbModel): number` -- sum of all 8 dimension scores (max 80)
   - `dimensionScores(model: DbModel): number[]` -- scores array in canonical dimension order (matching DIMENSIONS array order in dimensions.ts)

Create `src/lib/db-compass/dimensions.ts` following `src/lib/beauty-index/dimensions.ts` pattern.

1. Export `Dimension` interface with fields: `key` (union type of 8 dimension keys from Scores type), `symbol` (Unicode string), `name` (full name), `shortName` (compact label), `description` (one sentence).

2. Use `keyof import('./schema').Scores` for the `key` type to enforce sync with the schema.

3. Export `DIMENSIONS` array with exactly 8 entries in this canonical order:
   - `scalability` -- symbol: upward arrow (U+2191), name: "Scalability", shortName: "Scale"
   - `performance` -- symbol: lightning bolt (U+26A1), name: "Performance", shortName: "Perf"
   - `reliability` -- symbol: anchor (U+2693), name: "Reliability", shortName: "Rely"
   - `operationalSimplicity` -- symbol: gear (U+2699), name: "Operational Simplicity", shortName: "Ops"
   - `queryFlexibility` -- symbol: magnifying glass (U+1F50D), name: "Query Flexibility", shortName: "Query"
   - `schemaFlexibility` -- symbol: puzzle piece (U+1F9E9), name: "Schema Flexibility", shortName: "Schema"
   - `ecosystemMaturity` -- symbol: star (U+2605), name: "Ecosystem Maturity", shortName: "Eco"
   - `learningCurve` -- symbol: graduation cap (U+1F393), name: "Learning Curve", shortName: "Learn"

   Include a one-sentence description for each dimension explaining what 1/10 vs 10/10 means. Use the descriptions from the research (28-RESEARCH.md "The 8 Scoring Dimensions" section). Note: learningCurve 10 = easiest to learn (bigger polygon = better, consistent across all dimensions).

Important: If a Unicode symbol like U+1F50D renders as emoji on some platforms and breaks layout, use simpler Unicode alternatives. The research suggested U+2BD1 for query flexibility -- evaluate which renders more consistently. Prefer symbols from the Basic Multilingual Plane (U+0000-FFFF) that render as text characters, not emoji. Safe alternatives: query = U+2BD1 or U+2315 (telephone recorder), schema = U+29C9 (joined squares), learning = U+2197 (arrow up-right). Avoid emoji-range codepoints (U+1F000+).

Use these BMP-safe symbols instead:
- queryFlexibility: U+2BD1 or fallback to a simple character like a circled Q or just use the text "Q" -- use U+2BD1 as the research recommends
- schemaFlexibility: U+29C9 (joined squares)
- learningCurve: U+2197 (north-east arrow)
  </action>
  <verify>
Run `npx tsc --noEmit --project tsconfig.json 2>&1 | grep -E "db-compass|error"` to check for TypeScript compilation errors in the new files. Verify the Dimension interface key type resolves correctly against the Scores type.
  </verify>
  <done>
schema.ts exports dbModelSchema, DbModel, Scores, dimensionScoreSchema, totalScore, dimensionScores. dimensions.ts exports DIMENSIONS (8 entries) and Dimension interface. Both files compile without TypeScript errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register dbModels content collection</name>
  <files>
    src/content.config.ts
  </files>
  <action>
Add the `dbModels` content collection to `src/content.config.ts` following the exact pattern of the existing `languages` collection.

1. Add import: `import { dbModelSchema } from './lib/db-compass/schema';`

2. Add collection definition after the `languages` definition:
```typescript
const dbModels = defineCollection({
  loader: file('src/data/db-compass/models.json'),
  schema: dbModelSchema,
});
```

3. Update the exports to include the new collection:
```typescript
export const collections = { blog, languages, dbModels };
```

Also create an empty placeholder file at `src/data/db-compass/models.json` containing a valid empty JSON array `[]` so that the build does not fail before Plan 02 populates the data. This placeholder allows `astro build` to succeed with zero entries.

Note: The `file()` loader is already imported in content.config.ts (`import { glob, file } from 'astro/loaders'`), so no new import is needed for the loader.
  </action>
  <verify>
Run `npx astro build 2>&1 | tail -20` to verify the build succeeds with the empty models.json placeholder. The build should complete without errors related to the dbModels collection. Check that no Zod validation errors appear (empty array should be valid).
  </verify>
  <done>
`astro build` succeeds. `src/content.config.ts` exports `dbModels` collection. The `src/data/db-compass/models.json` placeholder exists with `[]`. The collection is loadable via `getCollection('dbModels')` (will return empty array until Plan 02 populates data).
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes without errors in db-compass files
2. `npx astro build` succeeds with dbModels collection registered
3. schema.ts contains all required sub-schemas: scoresSchema, justificationsSchema, capTheoremSchema, topDatabaseSchema, dbModelSchema
4. dimensions.ts contains exactly 8 dimension entries with keys matching scoresSchema fields
5. content.config.ts imports dbModelSchema and registers dbModels collection with file() loader
</verification>

<success_criteria>
- Schema file exports Zod schema covering all DATA requirements (scores, justifications, crossCategory, CAP theorem, topDatabases)
- Dimension definitions file exports 8 entries with metadata (key, symbol, name, shortName, description)
- Content collection registered and build passes
- TypeScript compilation succeeds
- Foundation ready for Plan 02 to populate models.json with actual data
</success_criteria>

<output>
After completion, create `.planning/phases/28-data-foundation/28-01-SUMMARY.md`
</output>
