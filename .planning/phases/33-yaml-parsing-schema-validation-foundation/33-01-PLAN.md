---
phase: 33-yaml-parsing-schema-validation-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - package-lock.json
  - src/lib/tools/compose-validator/types.ts
  - src/lib/tools/compose-validator/interpolation.ts
  - src/lib/tools/compose-validator/parser.ts
  - src/lib/tools/compose-validator/compose-spec-schema.json
autonomous: true

must_haves:
  truths:
    - "A Docker Compose YAML string with merge keys (<<) parses correctly in YAML 1.1 mode and returns a Document AST with node ranges"
    - "Variable interpolation patterns like ${VAR:-default} are normalized before validation so they do not produce false-positive schema errors"
    - "Invalid YAML syntax produces a clear error message with the 1-based line number where parsing failed"
    - "The compose-spec JSON Schema is bundled as a static JSON file at build time (not fetched at runtime)"
  artifacts:
    - path: "src/lib/tools/compose-validator/types.ts"
      provides: "ComposeLintRule interface, ComposeRuleViolation, ComposeRuleContext, ComposeSeverity, ComposeCategory types"
      exports: ["ComposeSeverity", "ComposeCategory", "ComposeRuleFix", "ComposeLintRule", "ComposeRuleContext", "ComposeRuleViolation", "ComposeScoreDeduction", "ComposeCategoryScore", "ComposeScoreResult", "ComposeLintViolation", "ComposeAnalysisResult"]
    - path: "src/lib/tools/compose-validator/interpolation.ts"
      provides: "Variable interpolation detection and normalization for Docker Compose ${VAR:-default} patterns"
      exports: ["containsInterpolation", "normalizeInterpolation", "normalizeJsonForValidation"]
    - path: "src/lib/tools/compose-validator/parser.ts"
      provides: "YAML 1.1 parsing with LineCounter, merge key support, AST extraction helpers, and interpolation-normalized JSON output"
      exports: ["ComposeParseResult", "parseComposeYaml", "extractTopLevelMap", "resolveInstancePath", "getNodeLine"]
    - path: "src/lib/tools/compose-validator/compose-spec-schema.json"
      provides: "Bundled compose-spec JSON Schema for ajv validation"
  key_links:
    - from: "src/lib/tools/compose-validator/parser.ts"
      to: "src/lib/tools/compose-validator/types.ts"
      via: "imports ComposeRuleViolation for parse error typing"
      pattern: "import.*types"
    - from: "src/lib/tools/compose-validator/parser.ts"
      to: "src/lib/tools/compose-validator/interpolation.ts"
      via: "normalizeJsonForValidation called on doc.toJSON() output"
      pattern: "normalizeJsonForValidation"
    - from: "src/lib/tools/compose-validator/parser.ts"
      to: "yaml"
      via: "parseDocument with { version: '1.1', merge: true, lineCounter }"
      pattern: "parseDocument.*version.*1\\.1"
---

<objective>
Install the yaml/ajv/ajv-formats npm dependencies, define the compose-validator type system, build the variable interpolation normalizer, bundle the compose-spec JSON Schema, and create the YAML 1.1 parser with LineCounter integration and AST extraction helpers.

Purpose: Establish the foundational parsing pipeline that all subsequent compose-validator phases depend on -- YAML string in, Document AST + interpolation-normalized JSON + line number resolution out.
Output: types.ts, interpolation.ts, parser.ts, compose-spec-schema.json, and 3 new npm dependencies installed.
</objective>

<execution_context>
@/Users/patrykattc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrykattc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-yaml-parsing-schema-validation-foundation/33-RESEARCH.md

# Mirror the existing Dockerfile Analyzer pattern
@src/lib/tools/dockerfile-analyzer/types.ts
@src/lib/tools/dockerfile-analyzer/parser.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies, create types and interpolation normalizer</name>
  <files>
    package.json
    package-lock.json
    src/lib/tools/compose-validator/types.ts
    src/lib/tools/compose-validator/interpolation.ts
  </files>
  <action>
**Step 1: Install npm dependencies.**
Run `npm install yaml ajv ajv-formats` from the project root. This adds:
- `yaml` 2.x -- YAML parsing with AST + LineCounter
- `ajv` 8.x -- JSON Schema Draft-07 validation
- `ajv-formats` 3.x -- format validators (duration, uri) required by compose-spec

**Step 2: Create `src/lib/tools/compose-validator/types.ts`.**
Mirror the existing `src/lib/tools/dockerfile-analyzer/types.ts` pattern but adapted for compose validation:

- `ComposeSeverity` = `'error' | 'warning' | 'info'`
- `ComposeCategory` = `'schema' | 'security' | 'semantic' | 'best-practice' | 'style'` (matches the 5 category weights from the ROADMAP: Security 30%, Semantic 25%, Best Practice 20%, Schema 15%, Style 10%)
- `ComposeRuleFix` = `{ description: string; beforeCode: string; afterCode: string }`
- `ComposeLintRule` interface with `id`, `title`, `severity`, `category`, `explanation`, `fix`, and `check(ctx: ComposeRuleContext): ComposeRuleViolation[]`
- `ComposeRuleContext` = `{ doc: Document; rawText: string; lineCounter: LineCounter; json: Record<string, unknown>; services: Map<string, any>; networks: Map<string, any>; volumes: Map<string, any>; secrets: Map<string, any>; configs: Map<string, any> }` -- import `Document` and `LineCounter` from `'yaml'`
- `ComposeRuleViolation` = `{ ruleId: string; line: number; endLine?: number; column: number; endColumn?: number; message: string }`
- `ComposeScoreDeduction` = `{ ruleId: string; category: ComposeCategory; severity: ComposeSeverity; points: number; line: number }`
- `ComposeCategoryScore` = `{ category: ComposeCategory; score: number; weight: number; deductions: ComposeScoreDeduction[] }`
- `ComposeScoreResult` = `{ overall: number; grade: string; categories: ComposeCategoryScore[]; deductions: ComposeScoreDeduction[] }`
- `ComposeLintViolation extends ComposeRuleViolation` adding `severity`, `category`, `title`, `explanation`, `fix`
- `ComposeAnalysisResult` = `{ violations: ComposeLintViolation[]; score: ComposeScoreResult; parseSuccess: boolean; timestamp: number }`

Use named exports for all types. Follow the 2-space indent, single-quote, trailing-comma conventions.

**Step 3: Create `src/lib/tools/compose-validator/interpolation.ts`.**
Implement the interpolation normalizer exactly as specified in 33-RESEARCH.md Pattern 2:

- `INTERPOLATION_REGEX` constant for detecting `${...}` and `$VAR` patterns
- `containsInterpolation(value: string): boolean` -- tests if a string contains interpolation
- `normalizeInterpolation(value: string): string` -- resolves interpolation patterns for validation:
  - `$$` -> `$` (literal dollar)
  - `${VAR:-default}` and `${VAR-default}` -> use the default value
  - `${VAR:+replacement}` and `${VAR+replacement}` -> use the replacement value
  - `${VAR:?error}` and `${VAR?error}` -> `'placeholder'`
  - `${VAR}` and `$VAR` -> `'placeholder'`
  - Process in this exact order to avoid regex conflicts
- `normalizeJsonForValidation(obj: unknown): unknown` -- recursively walks a JSON object and normalizes all interpolated string values. Returns a new object (does not mutate). Handles: strings, arrays, plain objects, and pass-through for null/number/boolean.

Important: The normalizer runs on the JSON object AFTER `doc.toJSON()`, NOT on the raw YAML string. This preserves correct AST line offsets.
  </action>
  <verify>
1. `npm ls yaml ajv ajv-formats` shows all three packages installed
2. `npx tsc --noEmit src/lib/tools/compose-validator/types.ts` compiles without errors
3. `npx tsc --noEmit src/lib/tools/compose-validator/interpolation.ts` compiles without errors
4. `npm run build` succeeds (Astro build does not regress)
  </verify>
  <done>
- yaml, ajv, and ajv-formats are in package.json dependencies
- types.ts exports all compose-validator types mirroring the Dockerfile Analyzer pattern with ComposeCategory including 'schema', 'security', 'semantic', 'best-practice', 'style'
- interpolation.ts exports containsInterpolation, normalizeInterpolation, and normalizeJsonForValidation
- normalizeInterpolation handles all 6 Docker Compose interpolation patterns ($$, :-default, -default, :+replacement, +replacement, :?error, ?error, bare ${VAR}, bare $VAR)
- normalizeJsonForValidation recursively walks objects/arrays and normalizes string values
  </done>
</task>

<task type="auto">
  <name>Task 2: Bundle compose-spec schema and create YAML parser with AST helpers</name>
  <files>
    src/lib/tools/compose-validator/compose-spec-schema.json
    src/lib/tools/compose-validator/parser.ts
  </files>
  <action>
**Step 1: Bundle the compose-spec JSON Schema.**
Fetch the compose-spec schema from the official repo and save as `src/lib/tools/compose-validator/compose-spec-schema.json`:
- Run: `curl -sL https://raw.githubusercontent.com/compose-spec/compose-spec/main/schema/compose-spec.json -o src/lib/tools/compose-validator/compose-spec-schema.json`
- Add a comment-equivalent approach: Since JSON does not support comments, add a `"$comment"` property at the top level with the source URL, fetch date, and a note about the compose-spec version. Example: `"$comment": "compose-spec JSON Schema fetched from https://github.com/compose-spec/compose-spec/blob/main/schema/compose-spec.json on 2026-02-22"`
- Verify the schema has `"$schema": "http://json-schema.org/draft-07/schema#"` confirming Draft-07 format
- If the schema is missing `$id`, that is fine -- ajv does not require it

**Step 2: Create `src/lib/tools/compose-validator/parser.ts`.**
Build the core parsing module with these exports:

**`ComposeParseResult` interface:**
```
{
  doc: Document;            // yaml Document AST with node ranges
  lineCounter: LineCounter; // for mapping byte offsets to 1-based line/col
  json: Record<string, unknown> | null;       // raw toJSON() result (pre-normalization)
  normalizedJson: Record<string, unknown> | null; // interpolation-normalized JSON for ajv
  parseSuccess: boolean;    // true if no YAML syntax errors
  parseErrors: ComposeRuleViolation[];  // CV-S001 violations for syntax errors
  services: Map<string, any>;  // extracted from AST
  networks: Map<string, any>;
  volumes: Map<string, any>;
  secrets: Map<string, any>;
  configs: Map<string, any>;
}
```

**`parseComposeYaml(rawText: string): ComposeParseResult` function:**
1. Create `new LineCounter()`
2. Call `parseDocument(rawText, { version: '1.1', merge: true, lineCounter, prettyErrors: true, uniqueKeys: false, keepSourceTokens: false })`
   - `version: '1.1'` is CRITICAL -- Docker Compose uses YAML 1.1 merge keys (`<<`)
   - `merge: true` enables merge key resolution (redundant with 1.1 but explicit)
   - `uniqueKeys: false` allows duplicate keys in some Compose contexts
3. Map `doc.errors` to `ComposeRuleViolation[]` with ruleId `'CV-S001'`, using `lineCounter.linePos(err.pos[0])` with null guard on `err.pos`
4. If `doc.errors.length === 0`, call `doc.toJSON()` wrapped in try/catch to get the raw JSON
5. If raw JSON succeeded, call `normalizeJsonForValidation(json)` from interpolation.ts to get the normalized JSON
6. Extract top-level maps using `extractTopLevelMap` helper for services, networks, volumes, secrets, configs
7. Return the full `ComposeParseResult`

**`extractTopLevelMap(doc: Document, key: string): Map<string, any>` function:**
Walk the Document AST contents (which is a YAMLMap) to find the pair with the given key, then extract its children into a Map. Use `isMap`, `isPair`, `isScalar` type guards from `'yaml'`. Return empty Map if key not found. This is for AST-level extraction (not JSON-level) so rules can access AST nodes with range info.

**`resolveInstancePath(doc: Document, path: string): any` function:**
Walk the YAML AST following a JSON Pointer path (like `/services/web/ports/0`) to find the corresponding AST node. Split path by `/`, filter empty segments, then iterate:
- If current node `isMap`: find the pair whose key matches the segment, advance to pair.value
- If current node `isSeq`: parse segment as integer index, advance to items[index]
- Return null if path cannot be followed
- Add null check for `current` at top of each iteration

**`getNodeLine(node: any, lineCounter: LineCounter): { line: number; col: number }` function:**
Safe line-number extraction that guards against undefined `range` (yaml issue #573):
- Check `node?.range && Array.isArray(node.range) && node.range.length >= 1`
- If valid, return `lineCounter.linePos(node.range[0])`
- Wrap in try/catch (linePos can throw on invalid offsets)
- Fallback to `{ line: 1, col: 1 }`

Import `parseDocument`, `LineCounter`, `isMap`, `isPair`, `isScalar`, `isSeq` from `'yaml'` and `Document` type. Import `ComposeRuleViolation` from `./types`. Import `normalizeJsonForValidation` from `./interpolation`.
  </action>
  <verify>
1. `npx tsc --noEmit src/lib/tools/compose-validator/parser.ts` compiles without errors
2. `npm run build` succeeds (the schema JSON file does not break Astro's build)
3. The compose-spec-schema.json file exists and contains `"$schema": "http://json-schema.org/draft-07/schema#"`
4. parser.ts imports from `'yaml'` with `version: '1.1'` in the parseDocument options
5. parser.ts imports and uses `normalizeJsonForValidation` from `./interpolation`
6. `resolveInstancePath` and `getNodeLine` are exported for use by schema-validator.ts in Plan 33-02
  </verify>
  <done>
- compose-spec-schema.json is bundled with source attribution and confirmed Draft-07
- parseComposeYaml() parses YAML in 1.1 mode with merge key support, LineCounter integration, syntax error reporting as CV-S001 violations with 1-based line numbers, raw JSON extraction, interpolation-normalized JSON for ajv, and top-level AST map extraction
- extractTopLevelMap() walks the YAML Document AST to extract named top-level sections as Maps
- resolveInstancePath() walks the AST following JSON Pointer paths for line-number recovery from ajv errors
- getNodeLine() safely extracts 1-based line/col from AST nodes with range-undefined guard
  </done>
</task>

</tasks>

<verification>
1. `npm ls yaml ajv ajv-formats` -- all 3 dependencies installed
2. `npx tsc --noEmit` -- full project type-checks without errors
3. `npm run build` -- Astro build succeeds, no regressions
4. Verify compose-spec-schema.json starts with `{"$schema":"http://json-schema.org/draft-07/schema#"` or similar Draft-07 declaration
5. Verify parser.ts contains `version: '1.1'` in parseDocument options (grep for it)
6. Verify parser.ts uses `normalizeJsonForValidation` from interpolation.ts
7. Verify `getNodeLine` includes the range-undefined guard (`node?.range && Array.isArray`)
8. All files exist: types.ts, interpolation.ts, parser.ts, compose-spec-schema.json
</verification>

<success_criteria>
- yaml, ajv, and ajv-formats are installed and in package.json
- compose-spec JSON Schema is bundled as a static file
- YAML 1.1 parser with merge key support produces Document AST with node ranges
- LineCounter converts byte offsets to 1-based line/column positions
- Invalid YAML syntax produces CV-S001 violations with line numbers
- Variable interpolation normalizer handles all Docker Compose patterns without mutating the AST
- resolveInstancePath and getNodeLine are ready for Plan 33-02's schema validator
- Astro build succeeds with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/33-yaml-parsing-schema-validation-foundation/33-01-SUMMARY.md`
</output>
