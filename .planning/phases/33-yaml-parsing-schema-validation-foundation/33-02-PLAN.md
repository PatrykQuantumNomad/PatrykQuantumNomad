---
phase: 33-yaml-parsing-schema-validation-foundation
plan: 02
type: execute
wave: 2
depends_on: ["33-01"]
files_modified:
  - src/lib/tools/compose-validator/schema-validator.ts
  - src/lib/tools/compose-validator/rules/schema/CV-S001-invalid-yaml-syntax.ts
  - src/lib/tools/compose-validator/rules/schema/CV-S002-unknown-top-level-property.ts
  - src/lib/tools/compose-validator/rules/schema/CV-S003-unknown-service-property.ts
  - src/lib/tools/compose-validator/rules/schema/CV-S004-invalid-port-format.ts
  - src/lib/tools/compose-validator/rules/schema/CV-S005-invalid-volume-format.ts
  - src/lib/tools/compose-validator/rules/schema/CV-S006-invalid-duration-format.ts
  - src/lib/tools/compose-validator/rules/schema/CV-S007-invalid-restart-policy.ts
  - src/lib/tools/compose-validator/rules/schema/CV-S008-invalid-depends-on-condition.ts
  - src/lib/tools/compose-validator/rules/schema/index.ts
autonomous: true

must_haves:
  truths:
    - "Schema validation against compose-spec reports structural errors with accurate 1-based source line numbers"
    - "Unknown top-level properties (typos in services, networks, volumes) are detected with line numbers"
    - "Unknown service properties (typos within service definitions) are detected with line numbers"
    - "Invalid port formats produce a human-readable error message with the line number"
    - "Invalid volume formats produce a human-readable error message with the line number"
    - "Invalid duration formats in healthcheck intervals produce a human-readable error with the line number"
    - "Invalid restart policy values produce a human-readable error with the line number"
    - "Invalid depends_on condition values produce a human-readable error with the line number"
    - "Human-readable error messages are generated from ajv oneOf/anyOf validation failures (not raw JSON Schema paths)"
  artifacts:
    - path: "src/lib/tools/compose-validator/schema-validator.ts"
      provides: "ajv singleton, schema compilation, error categorization, human-readable message generation"
      exports: ["validateComposeSchema", "categorizeSchemaErrors"]
    - path: "src/lib/tools/compose-validator/rules/schema/index.ts"
      provides: "Schema rule registry with all 8 CV-S rules and lookup helpers"
      exports: ["schemaRules", "getSchemaRuleById"]
    - path: "src/lib/tools/compose-validator/rules/schema/CV-S001-invalid-yaml-syntax.ts"
      provides: "CV-S001 rule metadata (title, explanation, fix, severity, category)"
      exports: ["CVS001"]
    - path: "src/lib/tools/compose-validator/rules/schema/CV-S002-unknown-top-level-property.ts"
      provides: "CV-S002 rule metadata"
      exports: ["CVS002"]
    - path: "src/lib/tools/compose-validator/rules/schema/CV-S003-unknown-service-property.ts"
      provides: "CV-S003 rule metadata"
      exports: ["CVS003"]
    - path: "src/lib/tools/compose-validator/rules/schema/CV-S004-invalid-port-format.ts"
      provides: "CV-S004 rule metadata"
      exports: ["CVS004"]
    - path: "src/lib/tools/compose-validator/rules/schema/CV-S005-invalid-volume-format.ts"
      provides: "CV-S005 rule metadata"
      exports: ["CVS005"]
    - path: "src/lib/tools/compose-validator/rules/schema/CV-S006-invalid-duration-format.ts"
      provides: "CV-S006 rule metadata"
      exports: ["CVS006"]
    - path: "src/lib/tools/compose-validator/rules/schema/CV-S007-invalid-restart-policy.ts"
      provides: "CV-S007 rule metadata"
      exports: ["CVS007"]
    - path: "src/lib/tools/compose-validator/rules/schema/CV-S008-invalid-depends-on-condition.ts"
      provides: "CV-S008 rule metadata"
      exports: ["CVS008"]
  key_links:
    - from: "src/lib/tools/compose-validator/schema-validator.ts"
      to: "src/lib/tools/compose-validator/compose-spec-schema.json"
      via: "static JSON import for ajv.compile()"
      pattern: "import.*compose-spec-schema"
    - from: "src/lib/tools/compose-validator/schema-validator.ts"
      to: "src/lib/tools/compose-validator/parser.ts"
      via: "uses resolveInstancePath and getNodeLine for line-number recovery"
      pattern: "resolveInstancePath|getNodeLine"
    - from: "src/lib/tools/compose-validator/schema-validator.ts"
      to: "src/lib/tools/compose-validator/rules/schema/index.ts"
      via: "categorized errors reference rule IDs from the schema rule registry"
      pattern: "CV-S00[1-8]"
    - from: "src/lib/tools/compose-validator/rules/schema/index.ts"
      to: "src/lib/tools/compose-validator/types.ts"
      via: "imports ComposeLintRule and ComposeCategory types"
      pattern: "import.*types"
---

<objective>
Build the ajv schema validation pipeline with the compose-spec schema, the error categorization engine that maps raw ajv errors to specific schema rules (CV-S001 through CV-S008) with human-readable messages and accurate line numbers, and the 8 schema rule metadata files with expert explanations, fix suggestions, and before/after code examples.

Purpose: Complete the structural validation layer so that malformed Docker Compose files produce clear, actionable, line-accurate error messages covering all 8 schema error categories.
Output: schema-validator.ts, 8 schema rule files, and rules/schema/index.ts registry.
</objective>

<execution_context>
@/Users/patrykattc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrykattc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-yaml-parsing-schema-validation-foundation/33-RESEARCH.md
@.planning/phases/33-yaml-parsing-schema-validation-foundation/33-01-SUMMARY.md

# Mirror the existing Dockerfile Analyzer rule pattern
@src/lib/tools/dockerfile-analyzer/types.ts
@src/lib/tools/dockerfile-analyzer/rules/index.ts
@src/lib/tools/dockerfile-analyzer/rules/security/DL3006-tag-version.ts

# Dependencies from Plan 33-01
@src/lib/tools/compose-validator/types.ts
@src/lib/tools/compose-validator/parser.ts
@src/lib/tools/compose-validator/interpolation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create schema-validator.ts with ajv singleton, error categorization, and human-readable messages</name>
  <files>
    src/lib/tools/compose-validator/schema-validator.ts
  </files>
  <action>
**Create `src/lib/tools/compose-validator/schema-validator.ts`.**

This is the core schema validation module. It compiles the compose-spec schema once at module level and provides functions to validate Compose JSON and categorize errors into specific schema rules with line-accurate positions.

**Module-level ajv singleton:**
```
import Ajv from 'ajv';
import addFormats from 'ajv-formats';
import composeSchema from './compose-spec-schema.json';
```
- Create `new Ajv({ allErrors: true, strict: false, verbose: true })`
  - `allErrors: true` -- report ALL errors, not just the first
  - `strict: false` -- compose-spec uses `patternProperties` that strict mode rejects (see Pitfall 3 in RESEARCH.md)
  - `verbose: true` -- include schema/parentSchema in errors for better categorization
- Call `addFormats(ajv)` -- required for `format: "duration"` in compose-spec healthcheck intervals
- Compile once: `const validate = ajv.compile(composeSchema)` -- ~50-100ms, cached for all subsequent validations

**`validateComposeSchema(normalizedJson: Record<string, unknown>): ErrorObject[]` function:**
- Call `validate(normalizedJson)`
- Return empty array if valid or if `validate.errors` is null
- Otherwise return `validate.errors`

**`categorizeSchemaErrors(errors: ErrorObject[], doc: Document, lineCounter: LineCounter): ComposeRuleViolation[]` function:**
This is the critical bridge between ajv's generic errors and domain-specific schema rules. For each ajv ErrorObject:

1. Resolve the AST node: call `resolveInstancePath(doc, error.instancePath)` from parser.ts
2. Get the line number: call `getNodeLine(node, lineCounter)` from parser.ts
3. Categorize by `error.keyword` + `error.instancePath` pattern:

   - **CV-S002 (Unknown top-level property):** `keyword === 'additionalProperties'` AND `instancePath === ''`. Message: `"Unknown top-level property '${error.params.additionalProperty}'. Valid properties: services, networks, volumes, secrets, configs, name, version."`

   - **CV-S003 (Unknown service property):** `keyword === 'additionalProperties'` AND `instancePath` matches `/^\/services\/[^/]+$/`. Extract service name from path. Message: `"Unknown property '${error.params.additionalProperty}' in service '${serviceName}'."`

   - **CV-S004 (Invalid port format):** `instancePath` matches `/\/services\/[^/]+\/ports\/\d+/` AND (`keyword === 'oneOf'` OR `keyword === 'type'` OR `keyword === 'pattern'`). Message: `"Invalid port format. Use 'HOST:CONTAINER' (e.g., '8080:80'), 'CONTAINER' (e.g., '80'), or an object with 'target' and optionally 'published'."`

   - **CV-S005 (Invalid volume format):** `instancePath` matches `/\/services\/[^/]+\/volumes\/\d+/` AND (`keyword === 'oneOf'` OR `keyword === 'type'`). Message: `"Invalid volume format. Use 'SOURCE:TARGET[:MODE]' (e.g., './data:/app/data:ro') or an object with 'type', 'source', and 'target'."`

   - **CV-S006 (Invalid duration format):** `keyword === 'format'` AND `error.params.format === 'duration'`. Extract the field name from instancePath. Message: `"Invalid duration format for '${fieldName}'. Use Docker duration format (e.g., '30s', '5m', '1h30m')."`

   - **CV-S007 (Invalid restart policy):** `instancePath` matches `/\/services\/[^/]+\/restart$/` AND (`keyword === 'enum'` OR `keyword === 'type'`). Message: `"Invalid restart policy '${error.data}'. Must be one of: 'no', 'always', 'on-failure', 'unless-stopped'."`

   - **CV-S008 (Invalid depends_on condition):** `instancePath` matches `/\/services\/[^/]+\/depends_on\/[^/]+\/condition$/` AND (`keyword === 'enum'` OR `keyword === 'type'`). Message: `"Invalid depends_on condition. Must be one of: 'service_started', 'service_healthy', 'service_completed_successfully'."`

   - **Fallback:** Any uncategorized error gets ruleId `'CV-S002'` for top-level or generic schema error. Call `humanizeAjvError(error)` for the message.

4. **Deduplication:** Multiple ajv errors can map to the same rule+line. After categorization, deduplicate by `ruleId + line + message` to avoid showing the same error multiple times. This is especially important for `oneOf` errors which produce sub-errors for each failed branch.

5. **oneOf/anyOf suppression:** When a `oneOf` error is categorized into a specific rule (CV-S004, CV-S005), skip all sub-errors (children) of that oneOf. The ajv `schemaPath` can be used to identify sub-errors. A simpler approach: after categorizing all errors, if any error at a given `instancePath` was categorized as CV-S004/S005/S008, remove any `CV-S002` fallback errors at the same path.

**`humanizeAjvError(error: ErrorObject): string` function:**
Transform raw ajv error messages into human-readable text:
- `keyword === 'additionalProperties'` -> `"Unknown property '${params.additionalProperty}'."`
- `keyword === 'required'` -> `"Missing required property '${params.missingProperty}'."`
- `keyword === 'type'` -> `"Expected ${params.type} but got ${typeof error.data}."`
- `keyword === 'enum'` -> `"Value must be one of: ${params.allowedValues.join(', ')}."`
- `keyword === 'pattern'` -> `"Value does not match expected format."`
- `keyword === 'oneOf'` -> `"Value does not match any of the expected formats."`
- `keyword === 'anyOf'` -> `"Value does not match any of the expected formats."`
- Default: capitalize and clean up `error.message` (remove leading "must ", add period)

Import `resolveInstancePath` and `getNodeLine` from `./parser`. Import `ComposeRuleViolation` from `./types`. Import `Document`, `LineCounter` from `'yaml'`. Use `ErrorObject` type from `'ajv'`.
  </action>
  <verify>
1. `npx tsc --noEmit src/lib/tools/compose-validator/schema-validator.ts` compiles without errors
2. schema-validator.ts imports compose-spec-schema.json (grep for the import)
3. schema-validator.ts uses `strict: false` in ajv options
4. schema-validator.ts uses `resolveInstancePath` and `getNodeLine` from parser.ts
5. categorizeSchemaErrors handles all 7 specific rule patterns (CV-S002 through CV-S008) plus CV-S001 fallback
6. humanizeAjvError handles at least: additionalProperties, required, type, enum, pattern, oneOf, anyOf
7. `npm run build` succeeds
  </verify>
  <done>
- ajv singleton compiled once at module level with strict: false, allErrors: true, verbose: true
- ajv-formats added for duration/uri format validation
- validateComposeSchema() validates normalized JSON against compose-spec schema
- categorizeSchemaErrors() maps every ajv error to a specific CV-S rule with human-readable message and 1-based line number
- Deduplication removes duplicate errors from oneOf sub-errors
- humanizeAjvError() transforms raw ajv messages for any uncategorized errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create 8 schema rule metadata files and rules/schema/index.ts registry</name>
  <files>
    src/lib/tools/compose-validator/rules/schema/CV-S001-invalid-yaml-syntax.ts
    src/lib/tools/compose-validator/rules/schema/CV-S002-unknown-top-level-property.ts
    src/lib/tools/compose-validator/rules/schema/CV-S003-unknown-service-property.ts
    src/lib/tools/compose-validator/rules/schema/CV-S004-invalid-port-format.ts
    src/lib/tools/compose-validator/rules/schema/CV-S005-invalid-volume-format.ts
    src/lib/tools/compose-validator/rules/schema/CV-S006-invalid-duration-format.ts
    src/lib/tools/compose-validator/rules/schema/CV-S007-invalid-restart-policy.ts
    src/lib/tools/compose-validator/rules/schema/CV-S008-invalid-depends-on-condition.ts
    src/lib/tools/compose-validator/rules/schema/index.ts
  </files>
  <action>
**Create 8 schema rule metadata files** following the Dockerfile Analyzer rule pattern (see `src/lib/tools/dockerfile-analyzer/rules/security/DL3006-tag-version.ts` for reference).

Each rule file exports a const object conforming to a `SchemaRuleMetadata` type (a subset of `ComposeLintRule` without the `check` method -- schema rules are driven by ajv error categorization in schema-validator.ts, not by individual rule `check()` calls):

```typescript
// Type for schema rule metadata (no check method -- ajv drives validation)
export interface SchemaRuleMetadata {
  id: string;
  title: string;
  severity: ComposeSeverity;
  category: 'schema';
  explanation: string;
  fix: ComposeRuleFix;
}
```

Add the `SchemaRuleMetadata` interface to types.ts (append it after the existing types).

**Rule files -- each exports a single const:**

**CV-S001-invalid-yaml-syntax.ts:**
- id: `'CV-S001'`
- title: `'Invalid YAML Syntax'`
- severity: `'error'`
- category: `'schema'`
- explanation: Expert explanation covering common YAML syntax errors in Compose files -- indentation mismatches, unclosed quotes, tab characters (YAML requires spaces), duplicate keys at the same level, invalid anchors. Mention that Docker Compose uses YAML 1.1 which allows merge keys (`<<`). 3-5 sentences, production-oriented.
- fix: description = `'Fix the YAML syntax error at the indicated line.'`, beforeCode = a 4-line example with a common YAML indentation error (e.g., mixing tabs and spaces, or missing colon), afterCode = the corrected version.

**CV-S002-unknown-top-level-property.ts:**
- id: `'CV-S002'`
- title: `'Unknown Top-Level Property'`
- severity: `'error'`
- category: `'schema'`
- explanation: Explains that Docker Compose only allows specific top-level keys (`services`, `networks`, `volumes`, `secrets`, `configs`, `name`, `version`). Common typos (`service` instead of `services`, `volume` instead of `volumes`). Extension fields starting with `x-` are allowed. 3-5 sentences.
- fix: description = `'Use a valid top-level property name or prefix custom properties with x-.'`, beforeCode = example with `service:` typo, afterCode = corrected to `services:`.

**CV-S003-unknown-service-property.ts:**
- id: `'CV-S003'`
- title: `'Unknown Service Property'`
- severity: `'error'`
- category: `'schema'`
- explanation: Explains that service definitions have a defined set of properties (image, build, command, ports, volumes, environment, depends_on, healthcheck, restart, etc.). Common typos: `port` vs `ports`, `volume` vs `volumes`, `env` vs `environment`. Extension fields starting with `x-` are allowed. 3-5 sentences.
- fix: description = `'Use a valid service property name. Check the Docker Compose reference for the full list.'`, beforeCode = service with `port:` typo, afterCode = corrected to `ports:`.

**CV-S004-invalid-port-format.ts:**
- id: `'CV-S004'`
- title: `'Invalid Port Format'`
- severity: `'error'`
- category: `'schema'`
- explanation: Explains the valid port formats in Docker Compose -- short syntax (`"HOST:CONTAINER"`, `"CONTAINER"`, `"HOST:CONTAINER/PROTOCOL"`) and long syntax (object with `target`, `published`, `protocol`, `host_ip`). Common mistakes: bare numbers without quotes (YAML interprets `80:80` as a base-60 number), missing quotes around port strings, invalid port ranges. Quote port mappings in YAML. 3-5 sentences.
- fix: description = `'Quote port mappings as strings and use valid HOST:CONTAINER or long syntax format.'`, beforeCode = `ports:\n  - 8080:80` (unquoted), afterCode = `ports:\n  - "8080:80"`.

**CV-S005-invalid-volume-format.ts:**
- id: `'CV-S005'`
- title: `'Invalid Volume Format'`
- severity: `'error'`
- category: `'schema'`
- explanation: Explains valid volume formats -- short syntax (`"SOURCE:TARGET"`, `"SOURCE:TARGET:MODE"` where mode is `ro`, `rw`, `z`, `Z`), named volumes (`"volume_name:/container/path"`), and long syntax (object with `type`, `source`, `target`, `read_only`, `bind`, `volume`, `tmpfs`). Common mistakes: missing target path, invalid mode flags, using backslashes (Windows paths). 3-5 sentences.
- fix: description = `'Use valid SOURCE:TARGET[:MODE] short syntax or long syntax with type, source, and target.'`, beforeCode = `volumes:\n  - ./data` (missing target), afterCode = `volumes:\n  - ./data:/app/data`.

**CV-S006-invalid-duration-format.ts:**
- id: `'CV-S006'`
- title: `'Invalid Duration Format'`
- severity: `'warning'`
- category: `'schema'`
- explanation: Explains that healthcheck `interval`, `timeout`, `start_period`, and `start_interval` accept Docker duration format (`30s`, `5m`, `1h30m`, `2h30m15s`). Also accepts ISO 8601 durations. Common mistakes: using bare numbers without unit suffix (e.g., `30` instead of `30s`), space between number and unit. 3-5 sentences.
- fix: description = `'Use Docker duration format with unit suffix (s, m, h).'`, beforeCode = `healthcheck:\n  interval: 30`, afterCode = `healthcheck:\n  interval: 30s`.

**CV-S007-invalid-restart-policy.ts:**
- id: `'CV-S007'`
- title: `'Invalid Restart Policy'`
- severity: `'error'`
- category: `'schema'`
- explanation: Explains the four valid restart policies: `no` (default -- container does not restart), `always` (always restarts on exit), `on-failure` (restarts only on non-zero exit code), `unless-stopped` (like always but respects manual stops). Common mistakes: `never` (use `no`), `on_failure` (use `on-failure` with hyphen), boolean `true`/`false` (use string values). Quote `no` in YAML since bare `no` is interpreted as boolean false. 3-5 sentences.
- fix: description = `'Use a valid restart policy: "no", "always", "on-failure", or "unless-stopped".'`, beforeCode = `restart: never`, afterCode = `restart: "no"` (quoted because YAML parses bare `no` as false).

**CV-S008-invalid-depends-on-condition.ts:**
- id: `'CV-S008'`
- title: `'Invalid depends_on Condition'`
- severity: `'error'`
- category: `'schema'`
- explanation: Explains that the long-form `depends_on` allows specifying startup conditions for dependencies. Valid conditions: `service_started` (default -- waits for container start), `service_healthy` (waits for healthcheck to pass -- requires healthcheck in dependency), `service_completed_successfully` (waits for exit code 0 -- for init containers). Common mistakes: `healthy` instead of `service_healthy`, `started` instead of `service_started`, `completed` instead of `service_completed_successfully`. 3-5 sentences.
- fix: description = `'Use a valid depends_on condition: service_started, service_healthy, or service_completed_successfully.'`, beforeCode = `depends_on:\n  db:\n    condition: healthy`, afterCode = `depends_on:\n  db:\n    condition: service_healthy`.

**Create `src/lib/tools/compose-validator/rules/schema/index.ts`:**
- Import all 8 rule metadata exports
- Import `SchemaRuleMetadata` from `../../types`
- Export `schemaRules: SchemaRuleMetadata[]` array with all 8 rules
- Export `getSchemaRuleById(id: string): SchemaRuleMetadata | undefined` lookup function
- Export `getSchemaRuleSeverity(id: string): ComposeSeverity` with `'info'` fallback
- Export `getSchemaRuleCategory(id: string): ComposeCategory` with `'schema'` fallback

Follow the existing Dockerfile Analyzer `rules/index.ts` pattern exactly.
  </action>
  <verify>
1. `npx tsc --noEmit` -- full project type-checks without errors
2. All 8 rule files exist in `src/lib/tools/compose-validator/rules/schema/`
3. `src/lib/tools/compose-validator/rules/schema/index.ts` imports and exports all 8 rules
4. Each rule has id, title, severity, category='schema', explanation (3+ sentences), and fix with beforeCode/afterCode
5. CV-S001 is 'error' severity, CV-S006 is 'warning' severity, all others are 'error'
6. `npm run build` succeeds
  </verify>
  <done>
- 8 schema rule metadata files created with expert explanations and before/after code examples
- CV-S001 through CV-S008 cover: invalid YAML syntax, unknown top-level properties, unknown service properties, invalid port format, invalid volume format, invalid duration format, invalid restart policy, invalid depends_on condition
- Schema rule registry exports schemaRules array and lookup helpers
- SchemaRuleMetadata type added to types.ts
- All violations reference specific rule IDs with human-readable messages (not raw ajv paths)
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- full project type-checks without errors
2. `npm run build` -- Astro build succeeds with no regressions
3. schema-validator.ts compiles the compose-spec schema with ajv and exports validateComposeSchema + categorizeSchemaErrors
4. All 8 schema rule metadata files exist with expert content
5. rules/schema/index.ts registry exports schemaRules array with 8 entries
6. The full pipeline is wired: parser.ts -> schema-validator.ts -> rules/schema/index.ts
7. Every ajv error maps to a specific CV-S rule with a human-readable message and 1-based line number
8. oneOf/anyOf errors are categorized into domain-specific rules (not shown as raw schema paths)
</verification>

<success_criteria>
- ajv validates against compose-spec schema with allErrors + strict:false + ajv-formats
- categorizeSchemaErrors maps every ajv error to CV-S001 through CV-S008 with line-accurate positions
- humanizeAjvError transforms raw ajv messages for any unmapped errors
- 8 schema rule files provide expert explanations and fix suggestions with before/after code
- Schema rule registry mirrors the Dockerfile Analyzer rules/index.ts pattern
- Astro build succeeds with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/33-yaml-parsing-schema-validation-foundation/33-02-SUMMARY.md`
</output>
