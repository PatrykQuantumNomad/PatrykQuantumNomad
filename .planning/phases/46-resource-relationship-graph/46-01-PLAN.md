---
phase: 46-resource-relationship-graph
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/tools/k8s-analyzer/k8s-graph-data-extractor.ts
  - src/components/tools/k8s-results/K8sResourceNode.tsx
  - src/components/tools/k8s-results/K8sRelationshipEdge.tsx
  - src/components/tools/k8s-results/K8sGraphSkeleton.tsx
  - src/components/tools/k8s-results/k8s-graph.css
autonomous: true

must_haves:
  truths:
    - "Graph data extractor produces nodes and edges from parsed K8s resources"
    - "All 6 relationship types extracted: selector-match, volume-mount, env-from, ingress-backend, hpa-target, rbac-binding"
    - "Dangling references produce edges with resolved=false"
    - "Well-known resources (default SA, kube-root-ca.crt) are skipped in extraction"
    - "Edges are deduplicated by source+target+type"
    - "Custom node component renders resource kind label with category color"
    - "Custom edge component renders type label and red dashed stroke for dangling refs"
  artifacts:
    - path: "src/lib/tools/k8s-analyzer/k8s-graph-data-extractor.ts"
      provides: "Graph data extraction from ParsedResource[] + ResourceRegistry"
      exports: ["extractK8sGraphData", "K8sGraphData", "K8sGraphNode", "K8sGraphEdge", "K8sEdgeType", "K8sNodeCategory", "KIND_TO_CATEGORY"]
    - path: "src/components/tools/k8s-results/K8sResourceNode.tsx"
      provides: "Custom React Flow node with kind category color-coding"
      exports: ["K8sResourceNode", "K8sResourceNodeData", "K8sResourceNodeType", "CATEGORY_COLORS"]
    - path: "src/components/tools/k8s-results/K8sRelationshipEdge.tsx"
      provides: "Custom React Flow edge with type label + dangling styling"
      exports: ["K8sRelationshipEdge", "K8sRelationshipEdgeData", "K8sRelationshipEdgeType"]
    - path: "src/components/tools/k8s-results/K8sGraphSkeleton.tsx"
      provides: "Suspense fallback for lazy-loaded graph"
      exports: ["K8sGraphSkeleton"]
    - path: "src/components/tools/k8s-results/k8s-graph.css"
      provides: "Dark theme CSS overrides for React Flow"
  key_links:
    - from: "k8s-graph-data-extractor.ts"
      to: "types.ts (ParsedResource, ResourceRegistry)"
      via: "import types + registry.getByName() lookups"
      pattern: "import.*ParsedResource.*from.*types"
    - from: "k8s-graph-data-extractor.ts"
      to: "well-known-resources.ts"
      via: "import WELL_KNOWN_* sets for filtering"
      pattern: "import.*WELL_KNOWN.*from.*well-known-resources"
    - from: "k8s-graph-data-extractor.ts"
      to: "container-helpers.ts"
      via: "import getPodSpec/getContainerSpecs for volume/envFrom extraction"
      pattern: "import.*getPodSpec.*from.*container-helpers"
    - from: "k8s-graph-data-extractor.ts"
      to: "KA-X001 (TEMPLATE_LABEL_PATHS)"
      via: "import for selector match label path navigation"
      pattern: "import.*TEMPLATE_LABEL_PATHS.*from.*KA-X001"
---

<objective>
Create the graph data extraction module and all custom React Flow visual components for the K8s resource relationship graph.

Purpose: Build the data layer that walks ParsedResource[] to extract all 6 inter-resource relationship types as typed graph edges, plus the presentational React Flow components (custom node, custom edge, skeleton, CSS) that will render the graph in Plan 02.

Output: 5 new files -- the graph data extractor, custom node/edge components, skeleton fallback, and dark theme CSS.
</objective>

<execution_context>
@/Users/patrykattc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrykattc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/46-resource-relationship-graph/46-RESEARCH.md

# Key source files to reference:
@src/lib/tools/k8s-analyzer/types.ts
@src/lib/tools/k8s-analyzer/resource-registry.ts
@src/lib/tools/k8s-analyzer/container-helpers.ts
@src/lib/tools/k8s-analyzer/rules/cross-resource/well-known-resources.ts
@src/lib/tools/k8s-analyzer/rules/cross-resource/KA-X001-service-selector-mismatch.ts

# Reference implementations (Compose graph):
@src/components/tools/compose-results/ServiceNode.tsx
@src/components/tools/compose-results/DependencyEdge.tsx
@src/components/tools/compose-results/GraphSkeleton.tsx
@src/components/tools/compose-results/dependency-graph.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create K8s graph data extractor module</name>
  <files>src/lib/tools/k8s-analyzer/k8s-graph-data-extractor.ts</files>
  <action>
Create the graph data extraction module that walks `ParsedResource[]` and a `ResourceRegistry` to extract ALL inter-resource relationships (both resolved and dangling).

**Types to export:**
- `K8sEdgeType` = `'selector-match' | 'volume-mount' | 'env-from' | 'ingress-backend' | 'hpa-target' | 'rbac-binding'`
- `K8sNodeCategory` = `'workload' | 'service' | 'config' | 'storage' | 'rbac' | 'scaling'`
- `K8sGraphNode` = `{ id, kind, name, namespace, category, isPhantom? }`
- `K8sGraphEdge` = `{ sourceId, targetId, targetKind, targetName, edgeType, resolved, label? }`
- `K8sGraphData` = `{ nodes, edges, hasDanglingRefs }`
- `KIND_TO_CATEGORY` constant (Record<string, K8sNodeCategory> mapping all 19 supported kinds)

**Main export: `extractK8sGraphData(resources, registry): K8sGraphData`**

Implementation pattern: Follow the exact JSON traversal patterns from the cross-resource rules (KA-X001 through KA-X008), but emit edges for ALL references (not just violations). Check `registry.getByName()` to set `resolved: true/false`.

**9 extraction functions** (one per relationship source):

1. `extractServiceSelectorEdges` -- Service -> workload via label selector matching. Import `TEMPLATE_LABEL_PATHS` from KA-X001. For each Service with a non-empty `spec.selector`, iterate all resources with matching TEMPLATE_LABEL_PATHS, compare all selector entries against template labels. Emit `selector-match` edge per match. Dangling selector (no match found) does NOT create a phantom edge since there's no specific target.

2. `extractIngressBackendEdges` -- Ingress -> Service. Walk `spec.rules[*].http.paths[*].backend.service.name` and `spec.defaultBackend.service.name`. Skip `WELL_KNOWN_SERVICES`. Use `nodeIds.has(targetId)` for resolved check.

3. `extractConfigMapEdges` -- Workload -> ConfigMap. For each resource with a PodSpec (use `getPodSpec`):
   - Volumes: `podSpec.volumes[*].configMap.name` -> `volume-mount` edge
   - EnvFrom: containers `envFrom[*].configMapRef.name` -> `env-from` edge (use `getContainerSpecs`)
   - Env valueFrom: containers `env[*].valueFrom.configMapKeyRef.name` -> `env-from` edge
   Skip `WELL_KNOWN_CONFIGMAPS`. Deduplicate by source+target+type.

4. `extractSecretEdges` -- Workload -> Secret. Same pattern as ConfigMap but:
   - Volumes: `podSpec.volumes[*].secret.secretName` -> `volume-mount` edge
   - EnvFrom: `envFrom[*].secretRef.name` -> `env-from` edge
   - Env valueFrom: `env[*].valueFrom.secretKeyRef.name` -> `env-from` edge
   Skip `WELL_KNOWN_SECRETS`. Deduplicate by source+target+type.

5. `extractPvcEdges` -- Workload -> PVC via `podSpec.volumes[*].persistentVolumeClaim.claimName`. Edge type: `volume-mount`. Skip `WELL_KNOWN_PVCS`.

6. `extractServiceAccountEdges` -- Workload -> ServiceAccount via `podSpec.serviceAccountName` or `podSpec.serviceAccount`. Edge type: `rbac-binding` (logically a pod-level binding to a SA). Skip `WELL_KNOWN_SERVICE_ACCOUNTS`.

7. `extractHpaTargetEdges` -- HPA -> scalable workload. Walk `spec.scaleTargetRef.kind` + `spec.scaleTargetRef.name`. Only emit for known scalable kinds: Deployment, StatefulSet, ReplicaSet. Edge type: `hpa-target`.

8. `extractRbacBindingEdges` -- RoleBinding/ClusterRoleBinding -> Role/ClusterRole via `roleRef.kind` + `roleRef.name`. For ClusterRole targets, use `'default'` namespace in the target ID (consistent with ResourceRegistry's defaulting). Edge type: `rbac-binding`.

9. `extractNetworkPolicySelectorEdges` -- NetworkPolicy -> workloads via `spec.podSelector.matchLabels`. Same label matching pattern as Service selectors but using `spec.podSelector.matchLabels` path. Edge type: `selector-match`.

**Edge deduplication:** Use a `Set` keyed by `${sourceId}->${targetId}:${edgeType}` to prevent duplicate edges (e.g., a Deployment mounting the same ConfigMap via both volume and envFrom only produces one `volume-mount` and one `env-from` edge, not two of either).

**Phantom nodes:** After all extraction, scan edges for `resolved === false` where `targetId` is not in `nodeIds`. Add phantom nodes with `isPhantom: true` to the nodes array. Category is derived from `KIND_TO_CATEGORY[edge.targetKind]`.

**Well-known resource filtering:** Import all 5 `WELL_KNOWN_*` sets from `well-known-resources.ts`. Each extraction function checks the target name against the relevant set BEFORE creating an edge. This prevents noise like dangling edges to the default ServiceAccount.

**Helper function:** `resourceId(kind, namespace, name)` returns `"kind/namespace/name"` consistent with ResourceRegistry's `byNameIndex` key format.
  </action>
  <verify>
Run `npx tsc --noEmit` from project root -- no TypeScript errors on the new file. Verify the file exports `extractK8sGraphData`, `K8sGraphData`, `K8sGraphNode`, `K8sGraphEdge`, `K8sEdgeType`, `K8sNodeCategory`, and `KIND_TO_CATEGORY`.
  </verify>
  <done>
The graph data extractor module exists, exports the main `extractK8sGraphData` function and all supporting types, handles all 6 edge types across 9 extraction functions, deduplicates edges, creates phantom nodes for dangling references, and skips well-known resources. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create custom React Flow node, edge, skeleton, and CSS components</name>
  <files>
    src/components/tools/k8s-results/K8sResourceNode.tsx
    src/components/tools/k8s-results/K8sRelationshipEdge.tsx
    src/components/tools/k8s-results/K8sGraphSkeleton.tsx
    src/components/tools/k8s-results/k8s-graph.css
  </files>
  <action>
Create four files following the Compose graph reference implementations exactly.

**K8sResourceNode.tsx** -- Custom React Flow node component (reference: `ServiceNode.tsx`):
- Export type `K8sResourceNodeData = { label: string, kind: string, namespace: string, categoryColor: string, isPhantom?: boolean }`
- Export type `K8sResourceNodeType = Node<K8sResourceNodeData, 'k8s-resource'>`
- Export `CATEGORY_COLORS: Record<string, string>` mapping the 6 categories:
  - workload: `#3b82f6` (blue)
  - service: `#10b981` (emerald)
  - config: `#f59e0b` (amber)
  - storage: `#8b5cf6` (violet)
  - rbac: `#ef4444` (red)
  - scaling: `#06b6d4` (cyan)
- Render a `div` with:
  - Border color from `data.categoryColor`
  - If `data.isPhantom`: red dashed border (`border-dashed border-red-500/60`) and slightly transparent background
  - Background: `var(--color-surface-alt, rgba(0,0,0,0.4))`
  - Kind label: 10px mono uppercase with category color
  - Name label: bold, truncated with title attr
  - Namespace: only show if !== 'default', 12px secondary text
  - Top `Handle` (target) and bottom `Handle` (source) with accent color
  - Width: 200px

**K8sRelationshipEdge.tsx** -- Custom React Flow edge component (reference: `DependencyEdge.tsx`):
- Export type `K8sRelationshipEdgeData = { edgeType: string, isDangling: boolean, label?: string }`
- Export type `K8sRelationshipEdgeType = Edge<K8sRelationshipEdgeData, 'k8s-relationship'>`
- Define `EDGE_TYPE_LABELS: Record<string, string>`:
  - `selector-match` -> `selects`
  - `volume-mount` -> `mounts`
  - `env-from` -> `envFrom`
  - `ingress-backend` -> `routes to`
  - `hpa-target` -> `scales`
  - `rbac-binding` -> `binds`
- Use `getSmoothStepPath` for path calculation (same as DependencyEdge)
- `BaseEdge` stroke: `#ef4444` for dangling, `var(--color-text-secondary, #888)` for normal
- `strokeDasharray: '6 3'` for dangling edges (GRAPH-04)
- `strokeWidth`: 2 for dangling, 1.5 for normal
- Edge label via `EdgeLabelRenderer`: 10px text, surface bg, border, positioned at label midpoint

**K8sGraphSkeleton.tsx** -- Suspense fallback (fork of `GraphSkeleton.tsx`):
- Same SVG with three connected circles animation as Compose skeleton
- Text: "Loading resource graph..." (instead of "Loading dependency graph...")
- Same `animate-pulse` class

**k8s-graph.css** -- Dark theme CSS (fork of `dependency-graph.css`):
- Replace `.compose-graph` with `.k8s-graph` in all selectors
- Same CSS variables: `--xy-background-color: transparent`, node-color, edge-stroke, etc.
- Same controls button hover/focus styling
- Same attribution hide
- Keep minimap and arrowhead color overrides
  </action>
  <verify>
Run `npx tsc --noEmit` from project root -- no TypeScript errors. Verify all 4 files exist in `src/components/tools/k8s-results/` with correct exports.
  </verify>
  <done>
All 4 visual components exist: K8sResourceNode renders with category color-coding and phantom node styling, K8sRelationshipEdge renders with type labels and red dashed dangling styling, K8sGraphSkeleton provides the Suspense fallback, and k8s-graph.css provides dark theme overrides. TypeScript compiles without errors.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `k8s-graph-data-extractor.ts` exports `extractK8sGraphData` and all supporting types
3. `K8sResourceNode.tsx` exports `K8sResourceNode`, `CATEGORY_COLORS`, and type aliases
4. `K8sRelationshipEdge.tsx` exports `K8sRelationshipEdge` and type aliases
5. `K8sGraphSkeleton.tsx` exports `K8sGraphSkeleton`
6. `k8s-graph.css` uses `.k8s-graph` class prefix for all React Flow overrides
</verification>

<success_criteria>
- 5 new files created with correct exports
- Graph data extractor handles all 6 relationship types across 9 extraction functions
- Dangling references produce edges with resolved=false and phantom nodes with isPhantom=true
- Well-known resources are filtered out to prevent noise
- Edge deduplication prevents duplicates
- Custom node renders kind category color and phantom styling
- Custom edge renders type label and red dashed stroke for dangling
- TypeScript compilation succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/46-resource-relationship-graph/46-01-SUMMARY.md`
</output>
