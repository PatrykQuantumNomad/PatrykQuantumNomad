---
phase: 48-infrastructure-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/eda/schema.ts
  - src/lib/eda/og-cache.ts
  - src/data/eda/techniques.json
  - src/data/eda/distributions.json
  - src/content.config.ts
autonomous: true
requirements:
  - INFRA-05
  - INFRA-06
  - INFRA-07

must_haves:
  truths:
    - "Content collections accept a sample technique entry through Zod validation without errors"
    - "Content collections accept a sample distribution entry through Zod validation without errors"
    - "OG image caching computes deterministic hashes and skips regeneration for unchanged content"
    - "Three content collections (edaTechniques, edaDistributions, edaPages) are registered in content.config.ts"
  artifacts:
    - path: "src/lib/eda/schema.ts"
      provides: "Zod schemas for EdaTechnique and EdaDistribution types"
      exports: ["edaTechniqueSchema", "edaDistributionSchema", "tierSchema", "EdaTechnique", "EdaDistribution"]
    - path: "src/lib/eda/og-cache.ts"
      provides: "Content-hash OG image caching utility"
      exports: ["computeOgHash", "getCachedOgImage", "cacheOgImage"]
    - path: "src/data/eda/techniques.json"
      provides: "Sample technique entries (2-3 entries for validation)"
      contains: "histogram"
    - path: "src/data/eda/distributions.json"
      provides: "Sample distribution entries (2-3 entries for validation)"
      contains: "normal"
    - path: "src/content.config.ts"
      provides: "Three new EDA collections registered alongside existing blog, languages, dbModels"
      contains: "edaTechniques"
  key_links:
    - from: "src/content.config.ts"
      to: "src/lib/eda/schema.ts"
      via: "import edaTechniqueSchema and edaDistributionSchema"
      pattern: "import.*schema"
    - from: "src/content.config.ts"
      to: "src/data/eda/techniques.json"
      via: "file() loader path"
      pattern: "file.*techniques.json"
    - from: "src/content.config.ts"
      to: "src/data/eda/distributions.json"
      via: "file() loader path"
      pattern: "file.*distributions.json"
---

<objective>
Define Zod schemas for EDA content types, register three new content collections, add sample data entries for validation, and implement the OG image caching utility to prevent build time regression at 90+ page scale.

Purpose: Content collections are the data backbone of the encyclopedia. Validating schemas with sample data now ensures the data model is correct before populating 90+ entries in Phase 49. The OG cache prevents build time from scaling linearly with page count.

Output: Zod schemas (EdaTechnique, EdaDistribution), three registered content collections, sample data passing validation, and a content-hash OG caching utility.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/48-infrastructure-foundation/48-RESEARCH.md

@src/content.config.ts
@src/lib/beauty-index/schema.ts
@src/lib/og-image.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zod schemas, sample data, and register content collections</name>
  <files>
    src/lib/eda/schema.ts
    src/data/eda/techniques.json
    src/data/eda/distributions.json
    src/content.config.ts
  </files>
  <action>
1. Create `src/lib/eda/schema.ts` with Zod schemas matching the research specification:
   - Import `z` from `'astro/zod'` (same pattern as beauty-index/schema.ts and db-compass/schema.ts)
   - Export `tierSchema`: `z.enum(['A', 'B', 'C'])` (interactivity tiers: A=static SVG, B=SVG swap, C=D3 explorer)
   - Export `edaTechniqueSchema`: z.object with fields:
     - `id`: z.string()
     - `title`: z.string()
     - `slug`: z.string()
     - `category`: z.enum(['graphical', 'quantitative'])
     - `section`: z.string() (e.g., "1.3.3.14" — NIST section ref)
     - `nistSection`: z.string() (full NIST section identifier)
     - `description`: z.string()
     - `tier`: tierSchema
     - `variantCount`: z.number().int().min(0).default(0)
     - `relatedTechniques`: z.array(z.string()).default([]) (array of slugs)
     - `tags`: z.array(z.string()).default([]) (e.g., ["location", "randomness"])
   - Export `edaDistributionSchema`: z.object with fields:
     - `id`: z.string()
     - `title`: z.string()
     - `slug`: z.string()
     - `parameters`: z.array(z.object({ name: z.string(), symbol: z.string(), min: z.number(), max: z.number(), default: z.number(), step: z.number() }))
     - `pdfFormula`: z.string() (KaTeX-ready LaTeX)
     - `cdfFormula`: z.string() (KaTeX-ready LaTeX)
     - `mean`: z.string() (formula for mean)
     - `variance`: z.string() (formula for variance)
     - `relatedDistributions`: z.array(z.string()).default([]) (array of slugs)
     - `nistSection`: z.string()
     - `description`: z.string()
   - Export TypeScript types: `type EdaTechnique = z.infer<typeof edaTechniqueSchema>`, `type EdaDistribution = z.infer<typeof edaDistributionSchema>`

2. Create `src/data/eda/techniques.json` with 3 sample entries for validation:
   - Entry 1: Histogram (graphical, tier B, 4 variants, slug "histogram")
   - Entry 2: Scatter Plot (graphical, tier B, 2 variants, slug "scatter-plot")
   - Entry 3: Mean (quantitative, tier A, 0 variants, slug "mean")
   - Each entry must have all required fields. Use realistic NIST section numbers (e.g., "1.3.3.14" for histogram).
   - Include realistic tags (e.g., ["distribution", "shape"] for histogram).
   - Include relatedTechniques cross-references between the sample entries.

3. Create `src/data/eda/distributions.json` with 2 sample entries for validation:
   - Entry 1: Normal Distribution (slug "normal", 2 params: mu [-5,5,0,0.1], sigma [0.1,5,1,0.1])
     - pdfFormula: `"f(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}} e^{-\\frac{1}{2}\\left(\\frac{x - \\mu}{\\sigma}\\right)^2}"`
     - cdfFormula: `"F(x) = \\frac{1}{2}\\left[1 + \\text{erf}\\left(\\frac{x - \\mu}{\\sigma\\sqrt{2}}\\right)\\right]"`
     - mean: `"\\mu"`, variance: `"\\sigma^2"`
   - Entry 2: Exponential Distribution (slug "exponential", 1 param: lambda [0.1,5,1,0.1])
     - Include proper PDF/CDF formulas
   - Each entry must pass edaDistributionSchema validation.

4. Update `src/content.config.ts`:
   - Add import: `import { edaTechniqueSchema, edaDistributionSchema } from './lib/eda/schema';`
   - Add `edaTechniques` collection: `defineCollection({ loader: file('src/data/eda/techniques.json'), schema: edaTechniqueSchema })`
   - Add `edaDistributions` collection: `defineCollection({ loader: file('src/data/eda/distributions.json'), schema: edaDistributionSchema })`
   - Add `edaPages` collection: `defineCollection({ loader: glob({ pattern: '**/*.mdx', base: './src/data/eda/pages' }), schema: z.object({ title: z.string(), description: z.string(), section: z.string(), category: z.enum(['foundations', 'case-studies', 'reference']), nistSection: z.string() }) })`
   - Create empty directory `src/data/eda/pages/` (needed for glob() loader to not error — create a `.gitkeep` or empty directory)
   - Update exports: `export const collections = { blog, languages, dbModels, edaTechniques, edaDistributions, edaPages };`
   - Do NOT modify existing blog, languages, or dbModels collections

5. Run `npm run build` to verify all collections load and validate without errors.
  </action>
  <verify>
    <automated>cd /Users/patrykattc/work/git/PatrykQuantumNomad && npm run build 2>&1 | grep -E "(error|Error|edaTechnique|edaDistribution|collection)" | head -20</automated>
    <manual>Build succeeds. No Zod validation errors for sample technique or distribution entries. Content collections log shows edaTechniques (3 entries), edaDistributions (2 entries), edaPages (0 entries) loaded.</manual>
  </verify>
  <done>Zod schemas defined with all fields matching research specification. 3 sample technique entries and 2 sample distribution entries pass validation. Three content collections (edaTechniques, edaDistributions, edaPages) registered in content.config.ts alongside existing collections. Build succeeds.</done>
</task>

<task type="auto">
  <name>Task 2: Implement OG image caching utility</name>
  <files>
    src/lib/eda/og-cache.ts
  </files>
  <action>
1. Create `src/lib/eda/og-cache.ts` implementing content-hash based OG image caching:
   - Import `createHash` from `'node:crypto'`
   - Import `readFile`, `writeFile`, `mkdir`, `stat` from `'node:fs/promises'`
   - Import `join` from `'node:path'`
   - Define `CACHE_DIR = 'public/open-graph/eda'`
   - Define `CACHE_VERSION = '1'` (bump when OG template markup or fonts change)

2. Export `computeOgHash(title: string, description: string): string`:
   - Creates md5 hash of `${CACHE_VERSION}:${title}:${description}`
   - Returns first 12 hex characters (sufficient for uniqueness at 90-page scale)

3. Export `getCachedOgImage(hash: string): Promise<Buffer | null>`:
   - Constructs path: `${CACHE_DIR}/${hash}.png`
   - Uses `stat()` to check existence (faster than try/catch on readFile)
   - If exists, reads and returns Buffer
   - If not found, returns null

4. Export `cacheOgImage(hash: string, png: Buffer): Promise<void>`:
   - Creates cache directory with `mkdir({ recursive: true })`
   - Writes PNG buffer to `${CACHE_DIR}/${hash}.png`

5. Export `getOrGenerateOgImage(title: string, description: string, generateFn: () => Promise<Buffer>): Promise<Buffer>`:
   - Convenience wrapper: computes hash, checks cache, generates if missing, caches result
   - This is the function OG image endpoints will call

6. Create `public/open-graph/eda/.gitkeep` to ensure the cache directory is tracked by git (the actual PNG cache files should be gitignored — add `public/open-graph/eda/*.png` to `.gitignore`).

7. Add `public/open-graph/eda/*.png` to `.gitignore` to prevent cached OG images from bloating the repo.

IMPORTANT: This utility runs at build time only (Node.js APIs). It is NOT a client-side module.
  </action>
  <verify>
    <automated>cd /Users/patrykattc/work/git/PatrykQuantumNomad && node -e "const { computeOgHash } = require('./src/lib/eda/og-cache.ts'); console.log('hash:', computeOgHash('test', 'desc'));" 2>/dev/null || node --import tsx -e "import { computeOgHash } from './src/lib/eda/og-cache.ts'; console.log('hash:', computeOgHash('test', 'desc'));" 2>/dev/null || npx tsx -e "import { computeOgHash } from './src/lib/eda/og-cache.ts'; console.log('hash:', computeOgHash('test', 'desc'));"</automated>
    <manual>computeOgHash returns a 12-character hex string. Same inputs produce same output (deterministic). Different inputs produce different output.</manual>
  </verify>
  <done>OG cache utility exports computeOgHash, getCachedOgImage, cacheOgImage, and getOrGenerateOgImage. Hash is deterministic (same title+description = same hash). Cache version included in hash for invalidation. .gitignore updated to exclude cached PNGs.</done>
</task>

</tasks>

<verification>
1. `npm run build` completes without Zod validation errors
2. `src/lib/eda/schema.ts` exports edaTechniqueSchema, edaDistributionSchema, tierSchema, EdaTechnique, EdaDistribution
3. `src/data/eda/techniques.json` contains 3 entries that pass schema validation
4. `src/data/eda/distributions.json` contains 2 entries with valid parameter arrays and LaTeX formulas
5. `src/content.config.ts` registers edaTechniques, edaDistributions, edaPages alongside existing collections
6. `src/lib/eda/og-cache.ts` exports all 4 functions
7. computeOgHash produces deterministic 12-char hex strings
8. .gitignore includes `public/open-graph/eda/*.png`
</verification>

<success_criteria>
- Three content collections registered and validated with sample data
- Zod schemas cover all fields from the research specification
- Existing content collections (blog, languages, dbModels) unaffected
- OG cache utility produces deterministic hashes with version salt
- Build succeeds with all collections loaded
</success_criteria>

<output>
After completion, create `.planning/phases/48-infrastructure-foundation/48-02-SUMMARY.md`
</output>
