---
phase: 41-foundation-schema-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["41-01"]
files_modified:
  - src/lib/tools/k8s-analyzer/resource-registry.ts
  - src/lib/tools/k8s-analyzer/schema-validator.ts
autonomous: true
requirements: [PARSE-04, PARSE-05, SCHEMA-07]

must_haves:
  truths:
    - "A resource registry indexes all parsed resources by kind, name, namespace, and labels for cross-resource lookups"
    - "Resource summary displays count of each resource type found in the manifest"
    - "Each parsed resource is validated against the correct K8s 1.31 JSON Schema producing field-level error messages with accurate line numbers"
  artifacts:
    - path: "src/lib/tools/k8s-analyzer/resource-registry.ts"
      provides: "ResourceRegistry class with multi-index lookups (byKind, byName, byNamespace, byLabels) and summary generation"
      exports: ["ResourceRegistry"]
    - path: "src/lib/tools/k8s-analyzer/schema-validator.ts"
      provides: "Schema validation function that dynamically imports compiled validators and maps ajv errors to K8s violations"
      exports: ["validateResource"]
  key_links:
    - from: "src/lib/tools/k8s-analyzer/schema-validator.ts"
      to: "src/lib/tools/k8s-analyzer/validate-k8s.js"
      via: "dynamic import() for lazy loading"
      pattern: "import\\("
    - from: "src/lib/tools/k8s-analyzer/resource-registry.ts"
      to: "src/lib/tools/k8s-analyzer/types.ts"
      via: "ParsedResource type for indexing"
      pattern: "ParsedResource"
    - from: "src/lib/tools/k8s-analyzer/schema-validator.ts"
      to: "src/lib/tools/k8s-analyzer/parser.ts"
      via: "resolveInstancePath and getNodeLine for ajv error line resolution"
      pattern: "resolveInstancePath|getNodeLine"
---

<objective>
Create the resource registry for cross-resource lookups and the schema validator that maps ajv errors to K8s violations with accurate line numbers.

Purpose: The resource registry enables Phase 44 cross-resource validation (selector matching, reference checks). The schema validator is the core of Phase 41 -- it runs pre-compiled K8s JSON Schemas against each parsed resource and produces field-level diagnostics.
Output: `resource-registry.ts` with multi-index ResourceRegistry class, and `schema-validator.ts` with async dynamic-import-based validation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/41-foundation-schema-infrastructure/41-RESEARCH.md
@.planning/phases/41-foundation-schema-infrastructure/41-01-SUMMARY.md
@src/lib/tools/compose-validator/schema-validator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ResourceRegistry class with multi-index lookups</name>
  <files>src/lib/tools/k8s-analyzer/resource-registry.ts</files>
  <action>
Create `src/lib/tools/k8s-analyzer/resource-registry.ts` following the pattern from the research:

1. **ResourceRegistry class** with private indexes:
   - `byKind: Map<string, ParsedResource[]>` — index by resource kind (e.g., 'Deployment')
   - `byName: Map<string, ParsedResource[]>` — index by qualified name key `"kind/namespace/name"` (e.g., 'Deployment/default/my-app')
   - `byNamespace: Map<string, ParsedResource[]>` — index by namespace
   - `all: ParsedResource[]` — flat array of all resources

2. **add(resource: ParsedResource): void** — Add resource to all four indexes:
   - Push to `all` array
   - Append to `byKind.get(resource.kind)` (create array if missing)
   - Append to `byName.get(qualifiedName)` where qualifiedName = `${resource.kind}/${resource.namespace}/${resource.name}`
   - Append to `byNamespace.get(resource.namespace)` (create array if missing)

3. **getByKind(kind: string): ParsedResource[]** — Return all resources of a given kind, or empty array

4. **getByName(kind: string, namespace: string, name: string): ParsedResource | undefined** — Return first resource matching the qualified name

5. **getByNamespace(namespace: string): ParsedResource[]** — Return all resources in a namespace

6. **getByLabels(selector: Record<string, string>): ParsedResource[]** — Return all resources whose labels contain all key-value pairs in the selector. Filter `this.all` where every entry in selector matches the resource's labels.

7. **getAll(): ParsedResource[]** — Return all resources

8. **getSummary(): Map<string, number>** — Return count of resources per kind. Iterate byKind, set each kind to its array length.

9. **static buildFromDocuments(documents: ParsedDocument[]): ResourceRegistry** — Factory method that creates a new registry and adds only valid (non-empty, has apiVersion+kind+name) parsed documents as ParsedResource objects. Convert ParsedDocument to ParsedResource: set namespace to `document.namespace ?? 'default'`, annotations to `(document.json?.metadata as any)?.annotations ?? {}`.

Import `ParsedResource`, `ParsedDocument` from `./types`.
Named export only for the class.
  </action>
  <verify>
    npx tsc --noEmit src/lib/tools/k8s-analyzer/resource-registry.ts 2>&1 | head -20
  </verify>
  <done>ResourceRegistry class compiles, has all 4 indexes (byKind, byName, byNamespace, all), 7 query methods, factory buildFromDocuments method, and getSummary for resource counts</done>
</task>

<task type="auto">
  <name>Task 2: Create async schema validator with ajv error mapping</name>
  <files>src/lib/tools/k8s-analyzer/schema-validator.ts</files>
  <action>
Create `src/lib/tools/k8s-analyzer/schema-validator.ts` following compose-validator schema-validator.ts patterns but with async dynamic imports for K8s multi-type validation:

1. **Module-level cache**: `let validators: Record<string, ValidateFunction> | null = null;` to cache the dynamically imported validators after first load.

2. **loadValidators(): Promise<Record<string, ValidateFunction>>** — Private async function:
   - If `validators` is not null, return cached
   - `const mod = await import('./validate-k8s.js');`
   - Assign `validators = mod` (the module has named exports per resource type)
   - Return validators

3. **validateResource(resourceType: string, doc: ParsedDocument, lineCounter: LineCounter): Promise<K8sRuleViolation[]>** — Main validation function:
   - Load validators via `loadValidators()`
   - Get the specific validator: `validators[resourceType]`
   - If no validator found for resourceType, return empty array (should not happen if GVK registry is correct)
   - Call `validator(doc.json)` — returns boolean
   - If valid, return empty array
   - Map `validator.errors` (ajv ErrorObject[]) to K8sRuleViolation[]:
     a. For each error, resolve the instancePath to an AST node via `resolveInstancePath(doc.doc, error.instancePath)`
     b. Get line/col via `getNodeLine(node, lineCounter)`
     c. Create violation with ruleId 'KA-S005', line, column, and human-readable message from `humanizeAjvError(error)`

4. **humanizeAjvError(error: ErrorObject): string** — Convert ajv error objects to human-readable messages:
   - `required`: "Missing required property '{missingProperty}' at {instancePath}"
   - `additionalProperties`: "Unknown property '{additionalProperty}' at {instancePath}"
   - `type`: "Expected {schema type} at {instancePath}, got {typeof data}"
   - `enum`: "Invalid value at {instancePath}. Allowed values: {allowedValues}"
   - `pattern`: "Value at {instancePath} does not match pattern {pattern}"
   - `minimum`/`maximum`: "Value at {instancePath} must be {keyword} {limit}"
   - Default: error.message with instancePath prefix

5. **Deduplication**: ajv with allErrors:true can produce duplicate or overlapping errors. Deduplicate by `instancePath + keyword + message` before mapping.

Import from `./types`: `ParsedDocument`, `K8sRuleViolation`.
Import from `./parser`: `resolveInstancePath`, `getNodeLine`.
Import `LineCounter` from 'yaml'.
Import type `ErrorObject` from 'ajv'.
Named exports: `validateResource`, `loadValidators` (exported for testing/preloading).

NOTE: Do NOT use `import type` for ErrorObject if it is used as a value type in function signatures with runtime checks. Use regular import if needed, or use `import type` and rely on structural typing.
  </action>
  <verify>
    npx tsc --noEmit src/lib/tools/k8s-analyzer/schema-validator.ts 2>&1 | head -20
  </verify>
  <done>schema-validator.ts compiles cleanly, exports validateResource (async), dynamically imports validate-k8s.js, maps ajv errors to K8sRuleViolation with accurate line numbers and human-readable messages</done>
</task>

</tasks>

<verification>
- Both files compile with no TypeScript errors
- ResourceRegistry correctly indexes by kind, name, namespace, and labels
- ResourceRegistry.getSummary returns accurate resource counts
- schema-validator dynamically imports the compiled validators (async)
- ajv errors are mapped to K8sRuleViolation with line numbers from AST resolution
- Error messages are human-readable (not raw ajv error format)
</verification>

<success_criteria>
- ResourceRegistry supports all 4 lookup patterns needed by Phase 44 cross-resource validation
- ResourceRegistry.buildFromDocuments converts ParsedDocuments to ParsedResources with default namespace
- Schema validator loads all 18+ compiled validators via dynamic import
- ajv errors produce field-level diagnostics with accurate line numbers relative to full input
- Validators are cached after first load (no redundant imports)
</success_criteria>

<output>
After completion, create `.planning/phases/41-foundation-schema-infrastructure/41-03-SUMMARY.md`
</output>
