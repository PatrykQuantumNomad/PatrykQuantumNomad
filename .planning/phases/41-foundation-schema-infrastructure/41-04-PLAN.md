---
phase: 41-foundation-schema-infrastructure
plan: 04
type: execute
wave: 3
depends_on: ["41-02", "41-03"]
files_modified:
  - src/lib/tools/k8s-analyzer/engine.ts
  - src/lib/tools/k8s-analyzer/sample-manifest.ts
autonomous: true
requirements: [PARSE-04, PARSE-05, PARSE-06, SCHEMA-03, SCHEMA-04, SCHEMA-05, SCHEMA-06, SCHEMA-07, SCHEMA-08, SCHEMA-09, SCHEMA-10, SCHEMA-11, SCHEMA-12]

must_haves:
  truths:
    - "A multi-document K8s manifest string is fully analyzed: parsed, schema-validated per resource type, metadata checked, and resource registry built"
    - "The engine produces violations sorted by line number covering all 10 diagnostic rules (KA-S001 through KA-S010)"
    - "A pre-loaded sample manifest demonstrates all supported resource types and common issues"
    - "The resource summary shows counts per resource type found in the manifest"
  artifacts:
    - path: "src/lib/tools/k8s-analyzer/engine.ts"
      provides: "Async orchestrator that runs the full K8s analysis pipeline"
      exports: ["runK8sEngine"]
    - path: "src/lib/tools/k8s-analyzer/sample-manifest.ts"
      provides: "Pre-loaded sample K8s YAML with deliberate issues across multiple resource types"
      exports: ["SAMPLE_K8S_MANIFEST"]
  key_links:
    - from: "src/lib/tools/k8s-analyzer/engine.ts"
      to: "src/lib/tools/k8s-analyzer/parser.ts"
      via: "parseK8sYaml for multi-doc parsing"
      pattern: "parseK8sYaml"
    - from: "src/lib/tools/k8s-analyzer/engine.ts"
      to: "src/lib/tools/k8s-analyzer/schema-validator.ts"
      via: "validateResource for per-resource schema validation"
      pattern: "validateResource"
    - from: "src/lib/tools/k8s-analyzer/engine.ts"
      to: "src/lib/tools/k8s-analyzer/resource-registry.ts"
      via: "ResourceRegistry.buildFromDocuments for cross-resource index"
      pattern: "ResourceRegistry\\.buildFromDocuments"
    - from: "src/lib/tools/k8s-analyzer/engine.ts"
      to: "src/lib/tools/k8s-analyzer/diagnostic-rules.ts"
      via: "checkMetadata for KA-S007/S008/S009 and getDeprecation for KA-S006"
      pattern: "checkMetadata|getDeprecation"
    - from: "src/lib/tools/k8s-analyzer/engine.ts"
      to: "src/lib/tools/k8s-analyzer/gvk-registry.ts"
      via: "getResourceType and isValidGvk for resource identification"
      pattern: "getResourceType|isValidGvk"
---

<objective>
Create the async K8s analysis engine that orchestrates the full validation pipeline and a sample manifest for testing.

Purpose: The engine is the single entry point for running K8s manifest analysis. It ties together parsing, GVK identification, schema validation, metadata checks, and resource registry building. The sample manifest provides a pre-loaded example for the editor UI in Phase 45.
Output: `engine.ts` async orchestrator and `sample-manifest.ts` with a multi-resource K8s YAML.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/41-foundation-schema-infrastructure/41-RESEARCH.md
@.planning/phases/41-foundation-schema-infrastructure/41-02-SUMMARY.md
@.planning/phases/41-foundation-schema-infrastructure/41-03-SUMMARY.md
@src/lib/tools/compose-validator/engine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create async K8s analysis engine</name>
  <files>src/lib/tools/k8s-analyzer/engine.ts</files>
  <action>
Create `src/lib/tools/k8s-analyzer/engine.ts` following the compose-validator engine.ts pattern but async and multi-resource:

1. **runK8sEngine(rawText: string): Promise<K8sEngineResult>** — The main async orchestrator:

   **Step 1: Parse multi-document YAML**
   ```
   const parseResult = parseK8sYaml(rawText);
   const violations: K8sRuleViolation[] = [...parseResult.parseErrors]; // KA-S001 violations
   ```

   **Step 2: Process each parsed document**
   For each document in `parseResult.documents`:

   a. **KA-S010: Empty document check** — If `doc.isEmpty`, push info-level violation with message "Empty document in multi-document YAML (likely a trailing '---' separator)". Use doc.startLine for line number. Continue to next document.

   b. **KA-S002: Missing apiVersion** — If `doc.apiVersion` is null/undefined, push error violation. Check for case-insensitive near-match (e.g., user wrote 'apiversion') and include "Did you mean 'apiVersion'?" in message if found. Continue to next document (cannot proceed without apiVersion).

   c. **KA-S003: Missing kind** — If `doc.kind` is null/undefined, push error violation. Check for case-insensitive near-match. Continue to next document.

   d. **KA-S004: Unknown apiVersion/kind** — Call `getResourceType(doc.apiVersion, doc.kind)`. If returns null:
      - Call `findNearMatch(doc.apiVersion, doc.kind)` for helpful suggestion
      - Push error violation with message including the near-match suggestion if found
      - Check `getDeprecation(doc.apiVersion, doc.kind)` — if it is a deprecated API version, push KA-S006 warning instead of/in addition to KA-S004
      - Continue to next document (cannot schema-validate without valid GVK)

   e. **KA-S006: Deprecated API version** — If resource type IS valid but also appears in deprecated list, push warning violation with migration message. (This handles the case where a deprecated version still has a valid schema, e.g., if we added backwards compat.)
      - Actually: deprecated versions are NOT in the GVK_REGISTRY (those use old apiVersions). So KA-S006 fires from the getDeprecation check in step d. If the apiVersion/kind is deprecated, getResourceType returns null (not in registry), so we push both KA-S004 and KA-S006. CORRECTION: Only push KA-S006 (deprecated), not KA-S004 (unknown), when the combination is in the deprecated list. The user typed a real apiVersion/kind, it is just outdated.

   f. **KA-S005: Schema validation** — Call `await validateResource(resourceType, doc, parseResult.lineCounter)`. Push all returned violations.

   g. **KA-S007/S008/S009: Metadata checks** — Call `checkMetadata(doc, parseResult.lineCounter)`. Push all returned violations.

   **Step 3: Build resource registry**
   ```
   const registry = ResourceRegistry.buildFromDocuments(parseResult.documents);
   const resourceSummary = registry.getSummary();
   ```

   **Step 4: Sort and return**
   Sort violations by line then column (same as compose engine).
   Count rulesRun (10 schema rules) and rulesPassed (documents with no violations from a given rule).
   Return `K8sEngineResult` with violations, resources from registry.getAll(), resourceSummary, rulesRun, rulesPassed.

Import from:
- `./types`: K8sEngineResult, K8sRuleViolation, ParsedDocument
- `./parser`: parseK8sYaml
- `./gvk-registry`: getResourceType, getDeprecation, findNearMatch
- `./resource-registry`: ResourceRegistry
- `./schema-validator`: validateResource
- `./diagnostic-rules`: checkMetadata

Named export: `runK8sEngine`.
  </action>
  <verify>
    npx tsc --noEmit src/lib/tools/k8s-analyzer/engine.ts 2>&1 | head -20
  </verify>
  <done>engine.ts compiles, exports async runK8sEngine, orchestrates parse -> per-doc validation -> registry build -> sorted violations return</done>
</task>

<task type="auto">
  <name>Task 2: Create sample K8s manifest and verify full pipeline</name>
  <files>src/lib/tools/k8s-analyzer/sample-manifest.ts</files>
  <action>
Create `src/lib/tools/k8s-analyzer/sample-manifest.ts` with a `SAMPLE_K8S_MANIFEST` exported string constant.

The sample manifest should be a multi-document YAML string (using `---` separators) that includes:

1. **A Namespace** (v1/Namespace) — valid, demonstrates basic resource
2. **A ConfigMap** (v1/ConfigMap) — valid, with data entries
3. **A Secret** (v1/Secret) — valid, with base64-encoded data
4. **A Deployment** (apps/v1/Deployment) with DELIBERATE issues:
   - Missing `metadata.name` (triggers KA-S007)
   - Container with invalid image format (triggers KA-S005 schema error)
   - Missing resource limits (will be caught by Phase 43 rules, but structurally valid for schema)
5. **A Service** (v1/Service) — valid, with selector matching the deployment
6. **An Ingress** (networking.k8s.io/v1/Ingress) — valid, with rules pointing to the service
7. **A resource with deprecated API version**: `extensions/v1beta1` Deployment (triggers KA-S006)
8. **A resource with invalid labels**: label key with invalid characters (triggers KA-S009)
9. **A resource with invalid metadata.name**: uppercase characters in name (triggers KA-S008)
10. **A trailing `---`** at the end to trigger KA-S010 (empty document)

The manifest should be realistic and educational — something a K8s user would recognize as a typical microservice deployment with common mistakes. Include comments in the YAML explaining what each section demonstrates.

Total size: ~80-120 lines of YAML.

Export as: `export const SAMPLE_K8S_MANIFEST = \`...\` as const;`

After creating the sample, verify the full engine pipeline works by checking that `npx tsx` can import and run the engine against the sample manifest. Create a quick verification by adding a comment in the file about expected violations, but the actual verification is via the verify command.
  </action>
  <verify>
    npx tsx -e "import { runK8sEngine } from './src/lib/tools/k8s-analyzer/engine.ts'; import { SAMPLE_K8S_MANIFEST } from './src/lib/tools/k8s-analyzer/sample-manifest.ts'; runK8sEngine(SAMPLE_K8S_MANIFEST).then(r => { console.log('Resources:', r.resources.length); console.log('Violations:', r.violations.length); console.log('Summary:', Object.fromEntries(r.resourceSummary)); r.violations.forEach(v => console.log(v.ruleId, 'L'+v.line, v.message.slice(0,80))); })" 2>&1 | head -40
  </verify>
  <done>Sample manifest contains 7+ resources with deliberate issues, full engine pipeline runs without errors, produces violations for KA-S006 (deprecated API), KA-S007 (missing name), KA-S008 (invalid name), KA-S009 (invalid labels), KA-S010 (empty doc), and KA-S005 (schema errors)</done>
</task>

</tasks>

<verification>
- engine.ts runs the full async pipeline: parse -> validate -> registry -> sorted violations
- Sample manifest triggers at least 5 different diagnostic rules (KA-S005, S006, S007, S008, S009, S010)
- Resource registry contains all valid resources from the sample
- Resource summary shows correct counts per kind
- Violations are sorted by line number
- No runtime errors when running the full pipeline via tsx
- `npm run build` (Astro build) still succeeds with the new files (no import side effects)
</verification>

<success_criteria>
- runK8sEngine is the single async entry point for K8s manifest analysis
- Engine correctly handles: valid resources, empty docs, missing fields, unknown GVKs, deprecated APIs, schema errors, metadata issues
- Sample manifest is realistic and educational with ~80-120 lines covering multiple resource types
- Full pipeline verified end-to-end: input YAML string -> structured violations + resource registry + summary
- All Phase 41 requirements (PARSE-01 through PARSE-06, SCHEMA-01 through SCHEMA-12) are satisfied by the combined 4-plan output
</success_criteria>

<output>
After completion, create `.planning/phases/41-foundation-schema-infrastructure/41-04-SUMMARY.md`
</output>
