---
phase: 41-foundation-schema-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["41-01"]
files_modified:
  - src/lib/tools/k8s-analyzer/gvk-registry.ts
  - src/lib/tools/k8s-analyzer/parser.ts
  - src/lib/tools/k8s-analyzer/diagnostic-rules.ts
autonomous: true
requirements: [PARSE-01, PARSE-02, PARSE-03, PARSE-06, SCHEMA-03, SCHEMA-04, SCHEMA-05, SCHEMA-06, SCHEMA-08, SCHEMA-09, SCHEMA-10, SCHEMA-11, SCHEMA-12]

must_haves:
  truths:
    - "A multi-document YAML string with --- separators is parsed into individual documents with correct line numbers"
    - "Each parsed document has apiVersion and kind extracted for resource type identification"
    - "Valid apiVersion/kind combinations are recognized for all 18 supported resource types"
    - "Deprecated API versions are identified with migration guidance"
    - "YAML syntax errors, empty documents, missing fields, and invalid metadata produce correct diagnostics"
  artifacts:
    - path: "src/lib/tools/k8s-analyzer/gvk-registry.ts"
      provides: "GVK registry mapping 19 apiVersion/kind combinations to resource types, plus 18 deprecated API version entries"
      exports: ["GvkEntry", "DeprecatedApiVersion", "GVK_REGISTRY", "DEPRECATED_API_VERSIONS", "getResourceType", "isValidGvk", "getDeprecation"]
    - path: "src/lib/tools/k8s-analyzer/parser.ts"
      provides: "Multi-document YAML parser with shared LineCounter, per-document metadata extraction, and AST-based line resolution"
      exports: ["parseK8sYaml", "resolveInstancePath", "getNodeLine"]
    - path: "src/lib/tools/k8s-analyzer/diagnostic-rules.ts"
      provides: "SchemaRuleMetadata definitions for KA-S001 through KA-S010 and metadata validation helpers"
      exports: ["SCHEMA_RULE_METADATA", "checkMetadata", "validateMetadataName", "validateLabelKey", "validateLabelValue"]
  key_links:
    - from: "src/lib/tools/k8s-analyzer/parser.ts"
      to: "yaml"
      via: "parseAllDocuments with shared LineCounter"
      pattern: "parseAllDocuments.*lineCounter"
    - from: "src/lib/tools/k8s-analyzer/diagnostic-rules.ts"
      to: "src/lib/tools/k8s-analyzer/gvk-registry.ts"
      via: "getDeprecation for KA-S006 warnings"
      pattern: "getDeprecation"
    - from: "src/lib/tools/k8s-analyzer/parser.ts"
      to: "src/lib/tools/k8s-analyzer/types.ts"
      via: "ParsedDocument and K8sParseResult types"
      pattern: "ParsedDocument|K8sParseResult"
---

<objective>
Create the GVK registry, multi-document YAML parser, and diagnostic rule metadata for the K8s analyzer.

Purpose: These are the core parsing and identification modules. The GVK registry maps Kubernetes resource types, the parser splits multi-document YAML with accurate line tracking, and the diagnostic rules define metadata validation (KA-S001 through KA-S010).
Output: `gvk-registry.ts`, `parser.ts`, and `diagnostic-rules.ts` with all parsing, identification, and pre-schema diagnostic capabilities.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/41-foundation-schema-infrastructure/41-RESEARCH.md
@.planning/phases/41-foundation-schema-infrastructure/41-01-SUMMARY.md
@src/lib/tools/compose-validator/parser.ts
@src/lib/tools/compose-validator/schema-validator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GVK registry and deprecated API versions</name>
  <files>src/lib/tools/k8s-analyzer/gvk-registry.ts</files>
  <action>
Create `src/lib/tools/k8s-analyzer/gvk-registry.ts` with:

1. **GvkEntry interface**: `{ apiVersion: string; kind: string; resourceType: string; schemaFile: string }`

2. **GVK_REGISTRY array** with all 19 entries from the research (the 19 supported apiVersion/kind combinations mapping to resource type identifiers):
   - v1: ConfigMap, Secret, Service, ServiceAccount, Namespace, Pod, PersistentVolumeClaim
   - apps/v1: Deployment, StatefulSet, DaemonSet
   - batch/v1: Job, CronJob
   - networking.k8s.io/v1: Ingress, NetworkPolicy
   - autoscaling/v2: HorizontalPodAutoscaler
   - rbac.authorization.k8s.io/v1: Role, ClusterRole, RoleBinding, ClusterRoleBinding

   Each entry's `resourceType` is the lowercase kind (e.g., 'deployment', 'configmap').

3. **Lookup functions**:
   - `getResourceType(apiVersion: string, kind: string): string | null` — returns resourceType or null. Match is case-sensitive for apiVersion but case-insensitive for kind (user might type 'deployment' instead of 'Deployment'). WAIT — per research, GVK matching should be case-sensitive per YAML spec. Include a helper that checks for near-misses for better error messages.
   - `isValidGvk(apiVersion: string, kind: string): boolean` — returns true if combination exists in registry
   - `findNearMatch(apiVersion: string, kind: string): GvkEntry | null` — case-insensitive lookup for helpful error messages when exact match fails

4. **DeprecatedApiVersion interface**: `{ apiVersion: string; kind: string; removedIn: string; replacement: string; message: string }`

5. **DEPRECATED_API_VERSIONS array** with all 18 entries from the research:
   - Removed in 1.16: extensions/v1beta1 (Deployment, DaemonSet, ReplicaSet, NetworkPolicy), apps/v1beta1 (Deployment, StatefulSet), apps/v1beta2 (Deployment, StatefulSet, DaemonSet)
   - Removed in 1.22: extensions/v1beta1 Ingress, networking.k8s.io/v1beta1 Ingress, rbac.authorization.k8s.io/v1beta1 (Role, ClusterRole, RoleBinding, ClusterRoleBinding)
   - Removed in 1.25: batch/v1beta1 CronJob, autoscaling/v2beta1 HPA
   - Removed in 1.26: autoscaling/v2beta2 HPA

6. **getDeprecation(apiVersion: string, kind: string): DeprecatedApiVersion | null** — returns deprecation info or null

All exports named. No default export.
  </action>
  <verify>
    npx tsc --noEmit src/lib/tools/k8s-analyzer/gvk-registry.ts 2>&1 | head -20
  </verify>
  <done>GVK registry has 19 entries covering all supported resource types, deprecated API versions has 18 entries, lookup functions return correct results for valid/invalid/deprecated combinations</done>
</task>

<task type="auto">
  <name>Task 2: Create multi-document YAML parser and diagnostic rule metadata</name>
  <files>
    src/lib/tools/k8s-analyzer/parser.ts
    src/lib/tools/k8s-analyzer/diagnostic-rules.ts
  </files>
  <action>
**parser.ts** — Create `src/lib/tools/k8s-analyzer/parser.ts` following compose-validator parser.ts patterns but with multi-document support:

1. **parseK8sYaml(rawText: string): K8sParseResult** — Main parser function:
   - Create shared `LineCounter` instance
   - Call `parseAllDocuments(rawText, { lineCounter })` from yaml 2.x
   - For each document:
     a. Map YAML syntax errors to KA-S001 violations via `doc.errors` array, resolving positions via `lineCounter.linePos(err.pos[0])`
     b. Call `safeToJSON(doc)` to get JSON (wrap doc.toJSON() in try/catch)
     c. Extract apiVersion, kind, name, namespace, labels from JSON
     d. Calculate startLine from `doc.contents?.range` via `lineCounter.linePos(range[0]).line`
     e. Determine isEmpty: json is null/undefined or empty object
   - Return `{ documents: ParsedDocument[], lineCounter, parseErrors }`

2. **resolveInstancePath(doc: Document, instancePath: string): Node | null** — Walk the YAML AST using a JSON Pointer path (e.g., `/spec/template/spec/containers/0/image`). Split path on `/`, for each segment: if current node isMap, find pair with matching key; if isSeq, index into items array. Return the leaf node or null. Same pattern as compose-validator but extracted as a shared utility.

3. **getNodeLine(node: Node | null, lineCounter: LineCounter): { line: number; col: number }** — Get line/col from AST node range. Include try/catch and range-undefined guard per yaml issue #573 (same as compose-validator pattern). Return `{ line: 1, col: 1 }` as fallback.

Import from yaml: `parseAllDocuments`, `LineCounter`, `Document`, `isMap`, `isPair`, `isScalar`, `isSeq`, `Node`.
Import types from `./types`: `ParsedDocument`, `K8sParseResult`, `K8sRuleViolation`.

**diagnostic-rules.ts** — Create `src/lib/tools/k8s-analyzer/diagnostic-rules.ts`:

1. **SCHEMA_RULE_METADATA**: Record of SchemaRuleMetadata for rules KA-S001 through KA-S010:
   - KA-S001: Invalid YAML syntax (error, schema)
   - KA-S002: Missing apiVersion field (error, schema)
   - KA-S003: Missing kind field (error, schema)
   - KA-S004: Unknown apiVersion/kind combination (error, schema)
   - KA-S005: Schema validation failure (error, schema)
   - KA-S006: Deprecated API version (warning, schema)
   - KA-S007: Missing metadata.name (error, schema)
   - KA-S008: Invalid metadata.name format (warning, schema)
   - KA-S009: Invalid label key/value format (warning, schema)
   - KA-S010: Empty document in multi-doc YAML (info, schema)

   Each entry includes: id, title, severity, category ('schema'), explanation (expert-voice production-consequence style matching compose-validator), and fix (description + beforeCode + afterCode).

2. **validateMetadataName(name: string): string | null** — RFC 1123 DNS subdomain validation per research:
   - Max 253 chars
   - Must match `/^[a-z0-9]([a-z0-9.-]*[a-z0-9])?$/`
   - Return error message string or null if valid

3. **validateLabelKey(key: string): string | null** — K8s qualified name validation per research:
   - Optional prefix (DNS subdomain, max 253 chars) + `/` + name (max 63 chars)
   - Name must match `/^([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]$/`
   - Return error message or null

4. **validateLabelValue(value: string): string | null** — K8s label value validation:
   - Empty string is valid
   - Max 63 chars
   - Must match `/^([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]$/`
   - Return error message or null

5. **checkMetadata(doc: ParsedDocument, lineCounter: LineCounter): K8sRuleViolation[]** — Check metadata for KA-S007 (missing name), KA-S008 (invalid name format), KA-S009 (invalid label key/value). Uses AST node resolution via resolveInstancePath to get accurate line numbers for each violation. Skip metadata checks if doc has no json or isEmpty.

Import from `./types`: `ParsedDocument`, `K8sRuleViolation`, `SchemaRuleMetadata`.
Import from `./parser`: `resolveInstancePath`, `getNodeLine`.
Import `LineCounter` from 'yaml'.
  </action>
  <verify>
    npx tsc --noEmit src/lib/tools/k8s-analyzer/parser.ts src/lib/tools/k8s-analyzer/diagnostic-rules.ts 2>&1 | head -20
  </verify>
  <done>Parser correctly splits multi-document YAML with accurate line numbers, diagnostic-rules.ts defines all 10 schema rule metadata entries and metadata validation functions, all TypeScript compiles cleanly</done>
</task>

</tasks>

<verification>
- All 3 files compile with no TypeScript errors
- parseK8sYaml handles: single doc, multi-doc with ---, trailing ---, empty documents, syntax errors
- GVK registry correctly identifies all 19 supported apiVersion/kind combinations
- Deprecated API version lookup returns migration guidance for all 18 deprecated entries
- Metadata validation catches invalid DNS names and malformed label keys/values
- Line numbers are accurate relative to full multi-document input (not per-document)
</verification>

<success_criteria>
- GVK registry has 19 entries covering all supported K8s 1.31 resource types
- Deprecated API versions has 18 entries with removal version and migration message
- Multi-document YAML parser produces ParsedDocument[] with accurate startLine values
- KA-S001 through KA-S010 all have SchemaRuleMetadata definitions
- Metadata validation (name, label key, label value) follows K8s validation.go patterns exactly
</success_criteria>

<output>
After completion, create `.planning/phases/41-foundation-schema-infrastructure/41-02-SUMMARY.md`
</output>
