---
phase: 41-foundation-schema-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/tools/k8s-analyzer/types.ts
  - scripts/compile-k8s-schemas.mjs
  - scripts/schemas/_definitions.json
  - src/lib/tools/k8s-analyzer/validate-k8s.js
autonomous: true
requirements: [SCHEMA-01, SCHEMA-02]

must_haves:
  truths:
    - "18 K8s resource type validators are compiled into a single ESM module with named exports"
    - "The compiled validator module loads via dynamic import and stays under 200KB gzipped"
    - "All K8s analyzer types are defined with proper severity, category, and violation interfaces"
  artifacts:
    - path: "src/lib/tools/k8s-analyzer/types.ts"
      provides: "All TypeScript interfaces for K8s analyzer engine"
      exports: ["K8sSeverity", "K8sCategory", "K8sRuleViolation", "K8sRuleFix", "K8sLintRule", "K8sLintViolation", "K8sAnalysisResult", "K8sScoreResult", "K8sCategoryScore", "K8sScoreDeduction", "ParsedDocument", "K8sParseResult", "ParsedResource", "K8sEngineResult", "SchemaRuleMetadata"]
    - path: "scripts/compile-k8s-schemas.mjs"
      provides: "Build script that downloads K8s 1.31 schemas and compiles via ajv standalone"
      min_lines: 80
    - path: "src/lib/tools/k8s-analyzer/validate-k8s.js"
      provides: "Auto-generated pre-compiled ajv standalone module with 18 named validator exports"
      contains: "export const configmap"
  key_links:
    - from: "scripts/compile-k8s-schemas.mjs"
      to: "src/lib/tools/k8s-analyzer/validate-k8s.js"
      via: "ajv standalone code generation"
      pattern: "standaloneCode"
    - from: "src/lib/tools/k8s-analyzer/validate-k8s.js"
      to: "ajv runtime"
      via: "inline equal function (no require() calls)"
      pattern: "function equal"
---

<objective>
Create the K8s analyzer type system and compile pre-built schema validators for all 18 supported Kubernetes resource types.

Purpose: This is the CRITICAL PATH task for Phase 41. The compiled schema bundle size must be validated under 200KB gzipped before any other work proceeds. The type system provides the foundation interfaces all other modules depend on.
Output: `types.ts` with all K8s analyzer interfaces, `compile-k8s-schemas.mjs` build script, and `validate-k8s.js` compiled validator module.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/41-foundation-schema-infrastructure/41-RESEARCH.md
@scripts/compile-compose-schema.mjs
@src/lib/tools/compose-validator/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create K8s analyzer type system</name>
  <files>src/lib/tools/k8s-analyzer/types.ts</files>
  <action>
Create `src/lib/tools/k8s-analyzer/types.ts` following the compose-validator types.ts pattern but adapted for K8s multi-resource analysis.

Define these types and interfaces:

1. **K8sSeverity**: `'error' | 'warning' | 'info'` (same as ComposeSeverity)
2. **K8sCategory**: `'schema' | 'security' | 'reliability' | 'best-practice' | 'cross-resource'` (5 categories for K8s, different from compose)
   - Weights: Security 35%, Reliability 20%, Best Practice 20%, Schema 15%, Cross-Resource 10%
3. **K8sRuleFix**: `{ description: string; beforeCode: string; afterCode: string }` (same pattern as ComposeRuleFix)
4. **K8sRuleViolation**: `{ ruleId: string; line: number; endLine?: number; column: number; endColumn?: number; message: string }` (same as ComposeRuleViolation)
5. **K8sLintRule**: `{ id: string; title: string; severity: K8sSeverity; category: K8sCategory; explanation: string; fix: K8sRuleFix; check(ctx: K8sRuleContext): K8sRuleViolation[] }` (same pattern as ComposeLintRule)
6. **K8sRuleContext**: `{ resources: ParsedResource[]; registry: ResourceRegistry; lineCounter: LineCounter; rawText: string }` (multi-resource context, NOT single-doc like compose)
7. **K8sLintViolation**: extends K8sRuleViolation with `severity`, `category`, `title`, `explanation`, `fix`, `resourceName?`, `resourceKind?` (enriched for nanostore, adds resource identification)
8. **K8sScoreDeduction**: `{ ruleId: string; category: K8sCategory; severity: K8sSeverity; points: number; line: number }`
9. **K8sCategoryScore**: `{ category: K8sCategory; score: number; weight: number; deductions: K8sScoreDeduction[] }`
10. **K8sScoreResult**: `{ overall: number; grade: string; categories: K8sCategoryScore[]; deductions: K8sScoreDeduction[] }`
11. **K8sAnalysisResult**: `{ violations: K8sLintViolation[]; score: K8sScoreResult; resources: ParsedResource[]; resourceSummary: Map<string, number>; parseSuccess: boolean; timestamp: number }`
12. **ParsedDocument**: `{ doc: Document; json: Record<string, unknown> | null; apiVersion: string | null; kind: string | null; name: string | null; namespace: string | null; labels: Record<string, string>; startLine: number; isEmpty: boolean }` (import Document from 'yaml')
13. **K8sParseResult**: `{ documents: ParsedDocument[]; lineCounter: LineCounter; parseErrors: K8sRuleViolation[] }` (import LineCounter from 'yaml')
14. **ParsedResource**: `{ apiVersion: string; kind: string; name: string; namespace: string; labels: Record<string, string>; annotations: Record<string, string>; doc: Document; json: Record<string, unknown>; startLine: number }` (validated resources only, namespace defaults to 'default')
15. **K8sEngineResult**: `{ violations: K8sRuleViolation[]; resources: ParsedResource[]; resourceSummary: Map<string, number>; rulesRun: number; rulesPassed: number }`
16. **SchemaRuleMetadata**: `{ id: string; title: string; severity: K8sSeverity; category: 'schema'; explanation: string; fix: K8sRuleFix }` (no check method; ajv drives validation)

Use `import type { Document, LineCounter } from 'yaml'` for yaml types.
Use forward reference comment for ResourceRegistry (defined in resource-registry.ts, imported at use site).
Follow compose-validator naming convention: K8s prefix on all types.
Use named exports only, no default export.
  </action>
  <verify>
    npx tsc --noEmit src/lib/tools/k8s-analyzer/types.ts 2>&1 | head -20
  </verify>
  <done>types.ts compiles with no TypeScript errors and exports all 16 types/interfaces listed above</done>
</task>

<task type="auto">
  <name>Task 2: Create schema compilation build script and compile K8s validators</name>
  <files>
    scripts/compile-k8s-schemas.mjs
    scripts/schemas/_definitions.json
    src/lib/tools/k8s-analyzer/validate-k8s.js
  </files>
  <action>
Create `scripts/compile-k8s-schemas.mjs` modeled after `scripts/compile-compose-schema.mjs` but for 18 K8s resource types.

The script must:

1. **Download schemas** from `yannh/kubernetes-json-schema` v1.31.0-local variant:
   - Base URL: `https://raw.githubusercontent.com/yannh/kubernetes-json-schema/master/v1.31.0-local/`
   - Download `_definitions.json` (shared definitions with $ref)
   - Download all 18 resource schema files (see GVK_REGISTRY in research for exact filenames: configmap-v1.json, secret-v1.json, service-v1.json, serviceaccount-v1.json, namespace-v1.json, pod-v1.json, persistentvolumeclaim-v1.json, deployment-apps-v1.json, statefulset-apps-v1.json, daemonset-apps-v1.json, job-batch-v1.json, cronjob-batch-v1.json, ingress-networking-v1.json, networkpolicy-networking-v1.json, horizontalpodautoscaler-autoscaling-v2.json, role-rbac-v1.json, clusterrole-rbac-v1.json, rolebinding-rbac-v1.json, clusterrolebinding-rbac-v1.json)
   - NOTE: That is 19 GVK entries but rolebinding and clusterrolebinding share a similar structure. Check: the research lists 18 resource types with the GVK registry having 19 entries (ClusterRoleBinding is #19). Actually recount: the research lists exactly 19 GVK entries. The intent is 18 resource types -- RoleBinding and ClusterRoleBinding are separate. Include all 19.
   - Save to `scripts/schemas/` directory (create if needed)

2. **Strip descriptions and status** from downloaded schemas before compilation:
   - Remove all `description` fields recursively (saves ~30-40% size)
   - Remove `status` property from schemas that have it (linters don't validate status)
   - This is a size optimization critical for staying under 200KB gzipped

3. **Compile via ajv standalone**:
   - Create ajv instance with: `{ allErrors: true, strict: false, verbose: true, validateSchema: false, code: { source: true, esm: true } }`
   - Call `addFormats(ajv)` for format keywords (date-time, uri, etc.)
   - Add `_definitions.json` as a shared schema: `ajv.addSchema(definitions, '_definitions.json')`
   - For each resource schema: set `schema.$id = resourceType`, call `ajv.addSchema(schema)`
   - Build export map: `{ configmap: 'configmap', secret: 'secret', ... }` mapping all resource types
   - Generate code: `standaloneCode(ajv, exportMap)`
   - Replace `require("ajv/dist/runtime/equal")` with inline equal function (copy exact pattern from compile-compose-schema.mjs)
   - Check for remaining `require()` calls and fail if found
   - Write output to `src/lib/tools/k8s-analyzer/validate-k8s.js` with `// AUTO-GENERATED` header and `// @ts-nocheck`

4. **Validate bundle size**:
   - After writing the file, report raw size
   - Compute gzipped size using Node.js `zlib.gzipSync` and report it
   - If gzipped size exceeds 200KB (204800 bytes), print ERROR and exit with code 1
   - If under 200KB, print SUCCESS with the exact sizes

5. **Run the script**: Execute `node scripts/compile-k8s-schemas.mjs` to generate the compiled validator.

IMPORTANT: The `scripts/schemas/` directory should be gitignored OR the downloaded schemas committed for reproducibility. Add `scripts/schemas/*.json` to `.gitignore` if it makes sense (prefer committing them for reproducibility since they are pinned to v1.31.0).

CRITICAL: If the gzipped size exceeds 200KB, apply additional optimizations before proceeding:
- Verify description stripping is working
- Verify status stripping is working
- Check if any schemas have excessive `x-kubernetes-*` extension fields that can be stripped
- As last resort, switch from strict to non-strict variant (remove additionalProperties)
  </action>
  <verify>
    node scripts/compile-k8s-schemas.mjs 2>&1 && ls -la src/lib/tools/k8s-analyzer/validate-k8s.js && node -e "const fs=require('fs');const zlib=require('zlib');const buf=fs.readFileSync('src/lib/tools/k8s-analyzer/validate-k8s.js');const gz=zlib.gzipSync(buf);console.log('Raw:',buf.length,'Gzip:',gz.length,'Under 200KB:',gz.length<204800)"
  </verify>
  <done>validate-k8s.js exists with 18+ named exports (one per resource type), contains no require() calls, is valid ESM, and gzipped size is under 200KB. Build script is reproducible.</done>
</task>

</tasks>

<verification>
- `src/lib/tools/k8s-analyzer/types.ts` compiles with no TypeScript errors
- `scripts/compile-k8s-schemas.mjs` runs successfully and produces `validate-k8s.js`
- `validate-k8s.js` is valid ESM with no `require()` calls
- Gzipped size of `validate-k8s.js` is under 200KB (the critical constraint)
- The compiled module has named exports for all 18+ resource types
</verification>

<success_criteria>
- All 16 K8s analyzer types/interfaces defined and exported from types.ts
- Pre-compiled ajv standalone module generated with 18+ named validator exports
- Bundle size validated under 200KB gzipped
- No runtime `require()` calls in compiled output
- Build script is reproducible (can re-run to regenerate)
</success_criteria>

<output>
After completion, create `.planning/phases/41-foundation-schema-infrastructure/41-01-SUMMARY.md`
</output>
