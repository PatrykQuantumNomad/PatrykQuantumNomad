---
phase: 23-rule-engine-scoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/tools/dockerfile-analyzer/types.ts
  - src/lib/tools/dockerfile-analyzer/engine.ts
  - src/lib/tools/dockerfile-analyzer/scorer.ts
  - src/lib/tools/dockerfile-analyzer/rules/index.ts
  - src/lib/tools/dockerfile-analyzer/rules/security/DL3006-tag-version.ts
  - src/lib/tools/dockerfile-analyzer/rules/security/DL3007-no-latest.ts
  - src/lib/tools/dockerfile-analyzer/rules/security/DL3008-pin-apt-versions.ts
  - src/lib/tools/dockerfile-analyzer/rules/security/DL3020-use-copy-not-add.ts
  - src/lib/tools/dockerfile-analyzer/rules/security/DL3004-no-sudo.ts
  - src/lib/tools/dockerfile-analyzer/rules/security/DL3002-no-root-user.ts
  - src/lib/tools/dockerfile-analyzer/rules/security/DL3061-from-first.ts
  - src/lib/tools/dockerfile-analyzer/rules/efficiency/DL3059-consolidate-runs.ts
  - src/lib/tools/dockerfile-analyzer/rules/efficiency/DL3014-use-apt-y.ts
  - src/lib/tools/dockerfile-analyzer/rules/efficiency/DL3015-no-install-recommends.ts
  - src/lib/tools/dockerfile-analyzer/rules/maintainability/DL4000-no-maintainer.ts
  - src/lib/tools/dockerfile-analyzer/rules/maintainability/DL3025-use-json-cmd.ts
  - src/lib/tools/dockerfile-analyzer/rules/maintainability/DL3000-absolute-workdir.ts
  - src/lib/tools/dockerfile-analyzer/rules/reliability/DL4003-multiple-cmd.ts
  - src/lib/tools/dockerfile-analyzer/rules/reliability/DL4004-multiple-entrypoint.ts
  - src/components/tools/EditorPanel.tsx
  - src/stores/dockerfileAnalyzerStore.ts
autonomous: true
requirements: [RULE-01, RULE-04, RULE-05, RULE-06, RULE-07, SCORE-01, SCORE-02, SCORE-03, SCORE-04]

must_haves:
  truths:
    - "Running the engine against the sample Dockerfile produces violations from at least 3 of 5 categories"
    - "Each violation has a DL-prefixed rule code, severity, category, expert explanation, and fix with before/after code"
    - "The scorer produces an overall 0-100 score with letter grade reflecting category weights"
    - "Per-category sub-scores are computed with transparent deductions traceable to specific violations"
    - "A clean Dockerfile (no violations) scores 100/A+"
    - "Clicking Analyze in the browser dispatches real diagnostics to the CodeMirror editor gutter"
  artifacts:
    - path: "src/lib/tools/dockerfile-analyzer/types.ts"
      provides: "LintRule, RuleViolation, RuleFix, ScoreResult, CategoryScore, ScoreDeduction, expanded LintViolation, AnalysisResult interfaces"
      contains: "LintRule"
    - path: "src/lib/tools/dockerfile-analyzer/engine.ts"
      provides: "runRuleEngine function"
      exports: ["runRuleEngine"]
    - path: "src/lib/tools/dockerfile-analyzer/scorer.ts"
      provides: "computeScore function with category weights and diminishing returns"
      exports: ["computeScore"]
    - path: "src/lib/tools/dockerfile-analyzer/rules/index.ts"
      provides: "Rule registry exporting allRules array and lookup helpers"
      exports: ["allRules"]
    - path: "src/components/tools/EditorPanel.tsx"
      provides: "Updated analyze pipeline calling runRuleEngine + computeScore"
  key_links:
    - from: "src/components/tools/EditorPanel.tsx"
      to: "src/lib/tools/dockerfile-analyzer/engine.ts"
      via: "import runRuleEngine"
      pattern: "runRuleEngine"
    - from: "src/components/tools/EditorPanel.tsx"
      to: "src/lib/tools/dockerfile-analyzer/scorer.ts"
      via: "import computeScore"
      pattern: "computeScore"
    - from: "src/lib/tools/dockerfile-analyzer/engine.ts"
      to: "src/lib/tools/dockerfile-analyzer/rules/index.ts"
      via: "import allRules"
      pattern: "allRules"
    - from: "src/lib/tools/dockerfile-analyzer/scorer.ts"
      to: "src/lib/tools/dockerfile-analyzer/rules/index.ts"
      via: "import allRules for rule lookup"
      pattern: "allRules"
    - from: "src/components/tools/EditorPanel.tsx"
      to: "src/stores/dockerfileAnalyzerStore.ts"
      via: "analysisResult.set with score field"
      pattern: "analysisResult\\.set"
---

<objective>
Build the rule engine foundation, scoring algorithm, 15 Tier 1 critical rules, and wire everything into the existing EditorPanel so clicking Analyze produces real violations with scores.

Purpose: This is the critical path -- establishing the LintRule interface, engine runner, scorer with category weights and diminishing returns, and validating the full pipeline end-to-end with 15 production rules. All subsequent rule plans follow the pattern established here.

Output: Working analysis pipeline: user clicks Analyze -> dockerfile-ast parses -> 15 rules check -> scorer computes weighted score -> diagnostics appear in CodeMirror gutter -> AnalysisResult with score stored in nanostore.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-rule-engine-scoring/23-RESEARCH.md
@.planning/phases/22-editor-foundation-technology-validation/22-02-SUMMARY.md
@src/lib/tools/dockerfile-analyzer/types.ts
@src/lib/tools/dockerfile-analyzer/parser.ts
@src/lib/tools/dockerfile-analyzer/sample-dockerfile.ts
@src/components/tools/EditorPanel.tsx
@src/stores/dockerfileAnalyzerStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create expanded types, rule engine, scorer, and rule registry</name>
  <files>
    src/lib/tools/dockerfile-analyzer/types.ts
    src/lib/tools/dockerfile-analyzer/engine.ts
    src/lib/tools/dockerfile-analyzer/scorer.ts
    src/lib/tools/dockerfile-analyzer/rules/index.ts
  </files>
  <action>
**types.ts** -- Replace entirely with expanded type system from research. Key types:
- `RuleSeverity` = 'error' | 'warning' | 'info'
- `RuleCategory` = 'security' | 'efficiency' | 'maintainability' | 'reliability' | 'best-practice'
- `RuleFix` = { description, beforeCode, afterCode }
- `LintRule` = { id, title, severity, category, explanation, fix, check(dockerfile, rawText): RuleViolation[] }
- `RuleViolation` = { ruleId, line (1-based), endLine?, column (1-based), endColumn?, message }
- `ScoreDeduction` = { ruleId, category, severity, points, line }
- `CategoryScore` = { category, score (0-100), weight, deductions }
- `ScoreResult` = { overall (0-100), grade, categories, deductions }
- `LintViolation` extends `RuleViolation` with { severity, category, title, explanation, fix } -- enriched version for nanostore
- `AnalysisResult` = { violations: LintViolation[], score: ScoreResult, astNodeCount, parseSuccess, timestamp }

Use `import('dockerfile-ast').Dockerfile` for the check function's parameter type to avoid forcing consumers to install dockerfile-ast types.

**engine.ts** -- Create `runRuleEngine(dockerfile: Dockerfile, rawText: string): EngineResult`:
- Import `allRules` from `./rules`
- Iterate all rules, call `rule.check(dockerfile, rawText)`
- Sort violations by line number, then column
- Return `{ violations: RuleViolation[], rulesRun: number, rulesPassed: number }`
- The EngineResult interface should also be exported

**scorer.ts** -- Create `computeScore(violations: RuleViolation[]): ScoreResult`:
- Category weights: Security 30%, Efficiency 25%, Maintainability 20%, Reliability 15%, Best Practice 10%
- Severity base deductions: error=15, warning=8, info=3
- IMPORTANT: Use diminishing returns formula: `deduction = baseSeverityPoints / (1 + 0.3 * priorViolationsInCategory)` where priorViolationsInCategory is the count of violations already processed for that category. This prevents category scores from clustering at 0.
- Per-category score = max(0, 100 - sum of diminished deductions)
- Overall = round(sum of categoryScore * weight/100)
- Grade thresholds: A+ >= 97, A >= 93, A- >= 90, B+ >= 87, B >= 83, B- >= 80, C+ >= 77, C >= 73, C- >= 70, D+ >= 67, D >= 63, D- >= 60, F < 60
- Export `computeScore` and `ScoreResult` (re-export from types)

**rules/index.ts** -- Create rule registry:
- Import all rule objects from category subdirectories (will start empty, populated as rules are added)
- Export `allRules: LintRule[]` array
- Export helper: `getRuleById(id: string): LintRule | undefined`
- Export helper: `getRuleSeverity(id: string): RuleSeverity` (returns 'info' as fallback)
- Export helper: `getRuleCategory(id: string): RuleCategory` (returns 'best-practice' as fallback)
- Start with empty array -- Task 2 will add imports

Create directories: `src/lib/tools/dockerfile-analyzer/rules/security/`, `efficiency/`, `maintainability/`, `reliability/`, `best-practice/`
  </action>
  <verify>
Run `npx tsc --noEmit 2>&1 | grep -v "open-graph"` -- types compile without errors. Verify engine.ts and scorer.ts import correctly from types.ts and rules/index.ts.
  </verify>
  <done>
types.ts exports all 10+ interfaces. engine.ts exports runRuleEngine. scorer.ts exports computeScore with diminishing returns. rules/index.ts exports allRules (empty array initially) and lookup helpers. All compile clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement 15 Tier 1 critical rules across 4 categories</name>
  <files>
    src/lib/tools/dockerfile-analyzer/rules/security/DL3006-tag-version.ts
    src/lib/tools/dockerfile-analyzer/rules/security/DL3007-no-latest.ts
    src/lib/tools/dockerfile-analyzer/rules/security/DL3008-pin-apt-versions.ts
    src/lib/tools/dockerfile-analyzer/rules/security/DL3020-use-copy-not-add.ts
    src/lib/tools/dockerfile-analyzer/rules/security/DL3004-no-sudo.ts
    src/lib/tools/dockerfile-analyzer/rules/security/DL3002-no-root-user.ts
    src/lib/tools/dockerfile-analyzer/rules/security/DL3061-from-first.ts
    src/lib/tools/dockerfile-analyzer/rules/efficiency/DL3059-consolidate-runs.ts
    src/lib/tools/dockerfile-analyzer/rules/efficiency/DL3014-use-apt-y.ts
    src/lib/tools/dockerfile-analyzer/rules/efficiency/DL3015-no-install-recommends.ts
    src/lib/tools/dockerfile-analyzer/rules/maintainability/DL4000-no-maintainer.ts
    src/lib/tools/dockerfile-analyzer/rules/maintainability/DL3025-use-json-cmd.ts
    src/lib/tools/dockerfile-analyzer/rules/maintainability/DL3000-absolute-workdir.ts
    src/lib/tools/dockerfile-analyzer/rules/reliability/DL4003-multiple-cmd.ts
    src/lib/tools/dockerfile-analyzer/rules/reliability/DL4004-multiple-entrypoint.ts
    src/lib/tools/dockerfile-analyzer/rules/index.ts
  </files>
  <action>
Each rule file follows the EXACT pattern from research. Every rule exports a named `LintRule` object. Use dockerfile-ast typed APIs (not raw string matching) for AST inspection. Use regex ONLY for inspecting RUN instruction arguments.

**CRITICAL per-rule details (use these EXACT detection approaches):**

**Security rules (7):**

1. **DL3006** (tag-version, warning): `dockerfile.getFROMs()` -> for each FROM, check `from.getImageTag()` AND `from.getImageDigest()` are both null/undefined. Skip `scratch`. Skip if image name matches a prior build stage alias (collect aliases from `from.getBuildStage()` across all FROMs). Line = `from.getRange().start.line + 1`.

2. **DL3007** (no-latest, warning): `dockerfile.getFROMs()` -> `from.getImageTag() === 'latest'`. Same skip logic as DL3006 for scratch/build-stage references.

3. **DL3008** (pin-apt-versions, warning): For RUN instructions containing `apt-get install`, extract package names after `install` flags (-y, --no-install-recommends, etc.), flag packages without `=` version pin. Use regex on `getArgumentsContent()`. Skip lines that are clearly flags (start with `-`).

4. **DL3020** (use-copy-not-add, error): `instruction.getKeyword() === 'ADD'` -> check if arguments are URLs (http/https) or .tar/.tar.gz archives (ADD is valid for these). Flag ADD for plain file copies. Use `getArgumentsContent()` to inspect.

5. **DL3004** (no-sudo, error): For RUN instructions, regex `\bsudo\b` on `getArgumentsContent()`.

6. **DL3002** (no-root-user, warning): Stage-aware -- find the LAST `FROM` instruction, then find USER instructions AFTER that FROM's line. If the last USER in the final stage has argument `root` or `0`, flag it. If no USER instruction exists in final stage, do NOT flag (DL3002 only flags explicit `USER root`).

7. **DL3061** (from-first, error): Get all instructions. Find the first instruction that is NOT a comment (skip comments) and NOT `ARG`. If its keyword is not `FROM`, flag it. Only flag once (the first non-ARG, non-comment instruction).

**Efficiency rules (3):**

8. **DL3059** (consolidate-runs, info): Iterate instructions, flag when `instructions[i].getKeyword() === 'RUN'` AND `instructions[i-1].getKeyword() === 'RUN'`. Flag the SECOND RUN (not the first).

9. **DL3014** (use-apt-y, warning): For RUN instructions containing `apt-get install`, check arguments do NOT contain `-y`, `--yes`, or `-qq`. Use regex on `getArgumentsContent()`.

10. **DL3015** (no-install-recommends, info): For RUN instructions containing `apt-get install`, check arguments do NOT contain `--no-install-recommends`. Use regex on `getArgumentsContent()`.

**Maintainability rules (3):**

11. **DL4000** (no-maintainer, error): `instruction.getKeyword() === 'MAINTAINER'`.

12. **DL3025** (use-json-cmd, warning): For CMD and ENTRYPOINT instructions, check if arguments start with `[` (JSON array form). If `getArgumentsContent()` does not start with `[` (after trimming), flag it. Check both `dockerfile.getCMDs()` and `dockerfile.getENTRYPOINTs()`.

13. **DL3000** (absolute-workdir, error): For instructions with `getKeyword() === 'WORKDIR'`, check `getArgumentsContent()`. If it does not start with `/` or `$` (variable reference), flag it.

**Reliability rules (2):**

14. **DL4003** (multiple-cmd, warning): Stage-aware for final stage. Get last FROM line, count CMD instructions after it. If count > 1, flag all CMDs after the first one in the final stage.

15. **DL4004** (multiple-entrypoint, error): Same approach as DL4003 but for ENTRYPOINT instructions in the final stage.

**Update rules/index.ts:** Import all 15 rules and add to the `allRules` array.

**Expert explanations:** Each rule MUST have an `explanation` field written in expert-voice with "why this matters in production" perspective, 2-3 sentences, specific about consequences. See research for examples (DL3006, DL3007, PG001 explanations are good templates).

**Fix suggestions:** Each rule MUST have a `fix` object with `description`, `beforeCode`, and `afterCode`. Use realistic Dockerfile snippets.

**Null safety:** ALWAYS null-check `getArgumentsContent()` before using it. Return early if null.
  </action>
  <verify>
Run `npx tsc --noEmit 2>&1 | grep -v "open-graph"` -- all 15 rule files compile. Verify `rules/index.ts` imports all 15 and `allRules.length === 15`.
  </verify>
  <done>
15 rule files exist in category subdirectories. Each exports a LintRule with id, title, severity, category, explanation (expert-voice), fix (before/after), and check function. rules/index.ts imports all 15 and exports them in allRules. TypeScript compiles clean.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire engine into EditorPanel and verify end-to-end pipeline</name>
  <files>
    src/components/tools/EditorPanel.tsx
    src/stores/dockerfileAnalyzerStore.ts
  </files>
  <action>
**EditorPanel.tsx** -- Replace the Phase 22 placeholder pipeline in `analyzeRef.current` with the real rule engine:

1. Add imports:
   - `import { DockerfileParser } from 'dockerfile-ast';`
   - `import { runRuleEngine } from '../../lib/tools/dockerfile-analyzer/engine';`
   - `import { computeScore } from '../../lib/tools/dockerfile-analyzer/scorer';`
   - `import { getRuleById } from '../../lib/tools/dockerfile-analyzer/rules';`
   - `import type { Diagnostic } from '@codemirror/lint';`
   - Remove the `parseDockerfile` import (no longer needed -- use DockerfileParser directly)

2. Replace `analyzeRef.current` body:
   ```
   const content = view.state.doc.toString();
   if (!content.trim()) {
     view.dispatch(setDiagnostics(view.state, []));
     analysisResult.set(null);
     return;
   }

   isAnalyzing.set(true);

   const ast = DockerfileParser.parse(content);
   const { violations, rulesRun } = runRuleEngine(ast, content);
   const score = computeScore(violations);

   // Convert violations to CodeMirror Diagnostics
   const diagnostics: Diagnostic[] = violations.map((v) => {
     const line = view.state.doc.line(v.line);
     const rule = getRuleById(v.ruleId);
     const severity = rule?.severity === 'error' ? 'error' : rule?.severity === 'warning' ? 'warning' : 'info';
     return {
       from: line.from + (v.column - 1),
       to: v.endLine ? view.state.doc.line(v.endLine).to : line.to,
       severity,
       message: `[${v.ruleId}] ${v.message}`,
       source: 'dockerfile-analyzer',
     };
   });

   view.dispatch(setDiagnostics(view.state, diagnostics));

   // Enrich violations with rule metadata for nanostore
   const enrichedViolations = violations.map(v => {
     const rule = getRuleById(v.ruleId);
     return {
       ...v,
       severity: rule?.severity ?? 'info' as const,
       category: rule?.category ?? 'best-practice' as const,
       title: rule?.title ?? v.ruleId,
       explanation: rule?.explanation ?? '',
       fix: rule?.fix ?? { description: '', beforeCode: '', afterCode: '' },
     };
   });

   analysisResult.set({
     violations: enrichedViolations,
     score,
     astNodeCount: ast.getInstructions().length,
     parseSuccess: true,
     timestamp: Date.now(),
   });

   isAnalyzing.set(false);
   ```

3. Keep the empty-content guard (dispatch empty diagnostics + set null).
4. Keep the analyzeRef pattern, handleButtonClick, shortcutHint, and JSX unchanged.
5. Handle parse errors: wrap DockerfileParser.parse() in try/catch. On error, set `analysisResult` with `parseSuccess: false`, empty violations, and a default zero score.

**dockerfileAnalyzerStore.ts** -- No changes needed. The `AnalysisResult` type in types.ts now includes the `score` field, and the atom type will automatically pick up the expanded interface.

**Verify the pipeline works:** After wiring, run `npm run build` to confirm the build completes without errors. The nanostore atom is typed as `AnalysisResult | null` which now includes the `score: ScoreResult` field.
  </action>
  <verify>
Run `npm run build` -- build completes with exit code 0. Run `npx tsc --noEmit 2>&1 | grep -v "open-graph"` -- no new type errors. Verify EditorPanel.tsx imports runRuleEngine, computeScore, and getRuleById. Verify no remaining references to the old `parseDockerfile` import in EditorPanel.
  </verify>
  <done>
EditorPanel.tsx calls runRuleEngine + computeScore on Analyze. Violations appear as CodeMirror diagnostics (gutter markers + inline). AnalysisResult in nanostore includes score with category breakdowns. Build passes. The sample Dockerfile produces violations from multiple categories when analyzed.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes with exit code 0
2. `npx tsc --noEmit 2>&1 | grep -v "open-graph"` shows no new errors
3. The rule registry exports 15 rules (`allRules.length === 15`)
4. types.ts exports LintRule, RuleViolation, ScoreResult, CategoryScore, ScoreDeduction, LintViolation, AnalysisResult
5. scorer.ts uses diminishing returns formula (not flat deductions)
6. EditorPanel.tsx no longer imports parseDockerfile -- uses DockerfileParser + runRuleEngine directly
</verification>

<success_criteria>
- 15 Tier 1 rules implemented with expert explanations and fix suggestions
- Rule engine produces violations sorted by line number
- Scorer computes category-weighted scores with diminishing returns
- EditorPanel dispatches real diagnostics to CodeMirror on Analyze
- AnalysisResult in nanostore includes score with per-category breakdowns
- Clean Dockerfile input produces score 100/A+
- Build and TypeScript compilation pass
</success_criteria>

<output>
After completion, create `.planning/phases/23-rule-engine-scoring/23-01-SUMMARY.md`
</output>
