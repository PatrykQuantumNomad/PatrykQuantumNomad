/**
 * Dimension justifications for all 25 Beauty Index languages.
 * Each entry maps a dimension key to the editorial reasoning behind that score.
 * Text may contain HTML (e.g. <em>, <code>) — render with set:html.
 */
export const JUSTIFICATIONS: Record<string, Record<string, string>> = {
  python: {
    phi: 'Indentation <em>is</em> syntax. Python enforces geometric structure at the grammar level. A screenful of Python has natural visual rhythm with minimal punctuation noise.',
    omega: 'List comprehensions, generators, and first-class functions bring Python closer to mathematical notation than most dynamic languages. <code>sum(x**2 for x in range(10))</code> reads like a formula. Not Haskell-tier, but a clear step above "workhorse" expressiveness.',
    lambda: 'The closest any general-purpose language gets to executable pseudocode. Variable naming conventions, keyword arguments, and minimal ceremony make intent self-evident to readers at nearly any experience level.',
    psi: 'Universally liked, beginner-friendly, and the default choice across data science, web, scripting, and education. The community is enormous, warm, and productive. Packaging friction (pip vs. poetry vs. uv) is a real blemish, but the read-write experience remains unmatched in reach.',
    gamma: 'Python codebases age well. Duck typing, simple module structure, and a culture of readability make modification and extension feel natural. The language bends to the domain rather than imposing rigid abstractions.',
    sigma: '"There should be one, and preferably only one, obvious way to do it." The Zen of Python is a genuine design philosophy, not a marketing tagline. Guido\'s benevolent-dictator era gave the language a coherent soul that has mostly survived committee evolution.',
  },
  ruby: {
    phi: 'Ruby\'s block syntax, <code>do...end</code> and <code>{ }</code> conventions, and method chaining create a natural visual flow. Code reads top-to-bottom with a literary rhythm. Indentation feels organic rather than enforced.',
    omega: 'Everything is an object, every expression returns a value, and blocks enable higher-order patterns. Not a mathematical language per se, but its internal consistency gives algorithms a sense of inevitability.',
    lambda: '<code>.reject(&amp;:empty?)</code>, <code>.each_with_index</code>, <code>File.readlines</code> — Ruby reads aloud as English. Matz explicitly optimized for human communication over machine efficiency. Among the highest Knuthian "wit" in any language.',
    psi: 'Ruby was <em>designed</em> to maximize programmer happiness, it\'s the explicit, stated mission. Matz\'s philosophy permeates everything from the standard library API to the community culture. The canonical 10 on this dimension.',
    gamma: 'Monkey-patching, open classes, and convention-over-configuration make Ruby extremely habitable. Code accommodates change with minimal friction. The language invites you to extend it rather than fight it.',
    sigma: '"Optimize for programmer happiness" is a clear, singular vision. Ruby occasionally accumulates features (e.g., multiple ways to define lambdas), but the core philosophy holds. Docked slightly for the flexibility-creates-inconsistency tradeoff.',
  },
  haskell: {
    phi: 'Clean Haskell is visually striking, <code>where</code> clauses, pattern matching, and type signatures create a structured, proportional layout. Docked from 9 because production Haskell with GADTs and monad transformer stacks can produce dense type-signature walls.',
    omega: 'The gold standard. <code>fibs = 0 : 1 : zipWith (+) fibs (tail fibs)</code> defines infinity by self-reference. Purity, lazy evaluation, and higher-kinded types let algorithms approach Erdős\'s "Book" proofs. No other language comes close.',
    lambda: 'Simple Haskell reads like mathematics rendered in prose. Point-free style and function composition create elegant chains of meaning. Docked from 9 because lens operators (<code>^.</code>, <code>.~</code>) and advanced type-level code can be opaque even to intermediate Haskellers.',
    psi: 'Moderate Stack Overflow admiration (~57%), well below Rust, Elixir, or Gleam. The learning curve is brutal, Cabal/Stack tooling fragmentation has caused years of pain, and cryptic error messages for type-level code create real frustration. The community is passionate but small. Developers admire Haskell more than they enjoy it day-to-day.',
    gamma: 'Purity is a double-edged sword, you can\'t "just add a side effect here" without restructuring. Changing one type signature can cascade through an entire module. Haskell code is correct but often brittle to modify, which is the opposite of Gabriel\'s habitability ideal.',
    sigma: '"Avoid success at all costs." Haskell is <em>about</em> something: purity, types, and mathematical foundations. Every feature follows from a coherent worldview. It\'s the most internally consistent language design on this list.',
  },
  rust: {
    phi: '<code>rustfmt</code> enforces strong visual consistency, and <code>match</code> arms, <code>impl</code> blocks, and module structure create clear visual architecture. Docked because lifetime annotations, turbofish (<code>::&lt;&gt;</code>), and trait bounds add visual noise that breaks geometric serenity.',
    omega: 'Algebraic data types, pattern matching, and zero-cost abstractions let you write algorithms that feel close to mathematical proofs. Ownership annotations interrupt the flow slightly — the ceremony is justified but still ceremony.',
    lambda: 'Trait-based design, expressive enums, and the <code>?</code> operator make intent clear. Rust rewards you with readable code once you know the idioms. Lifetime annotations are information for the compiler rather than the human reader, which docks it from 9.',
    psi: 'Topped Stack Overflow\'s "Most Admired" for 7+ consecutive years at 72%. The community is evangelical in its love. Compiler error messages are genuinely helpful. The "fighting the borrow checker" phase gives way to deep satisfaction.',
    gamma: 'Ownership rules force you to think about structure upfront, which often produces code that ages well. Some modifications ("I just wanted to add a reference here") cascade more than expected, but the type system catches the fallout.',
    sigma: '"Safety without sacrificing control." Every feature (ownership, borrowing, lifetimes, traits) follows from this single idea. Rust is the most opinionated systems language ever designed, and every opinion is justified by the core philosophy.',
  },
  elixir: {
    phi: 'Pipeline operators, pattern-matching clauses, and module structure create a visual flow that scans beautifully. Elixir code looks like a series of clean, evenly weighted transformation steps.',
    omega: 'Pattern matching, recursion, and immutable data structures support elegant algorithm expression. Not as abstract as Haskell or OCaml, but the BEAM VM\'s concurrency primitives give certain distributed algorithms an inevitable quality.',
    lambda: 'The pipe operator (<code>|&gt;</code>) turns data transformation into a readable narrative. <code>"hello" |&gt; String.split() |&gt; Enum.map(&amp;String.capitalize/1)</code> reads as a clear sequence of intentions. Among the most literate functional languages.',
    psi: 'Stack Overflow admiration at 66%. The Phoenix framework, LiveView, and OTP give practitioners a feeling of building something that "just works." The community is small but deeply enthusiastic and welcoming.',
    gamma: 'Pipelines are growth-point idioms, insert a transformation step anywhere without restructuring. OTP\'s supervision trees are the embodiment of habitable architecture: systems designed to fail gracefully and be extended incrementally.',
    sigma: '"Erlang\'s power with modern syntax." José Valim had a clear vision: bring functional programming and fault-tolerant concurrency to a wider audience. The language feels designed by one mind with a singular purpose.',
  },
  kotlin: {
    phi: 'Data classes, named arguments, and concise lambda syntax produce clean, well-proportioned code. The visual improvement over Java is immediately obvious, less ceremony, more signal.',
    omega: 'Extension functions, sealed classes, and functional collection operations (<code>map</code>, <code>filter</code>, <code>fold</code>) support elegant algorithm expression within a pragmatic framework. Not pushing mathematical frontiers, but consistently economical.',
    lambda: 'Kotlin reads clearly, <code>listOf</code>, <code>when</code>, <code>?.let { }</code> communicate intent without requiring deep language knowledge. Scope functions (<code>let</code>, <code>run</code>, <code>apply</code>) can slightly obscure control flow when overused, preventing a 9.',
    psi: 'Strong admiration in the Android community and growing JVM adoption. JetBrains\' tooling (IntelliJ integration) is best-in-class. Developers who switch from Java rarely want to go back.',
    gamma: 'Interoperability with Java means Kotlin codebases can grow incrementally. Null-safety, sealed classes, and coroutines provide guardrails that help code age well without over-constraining structure.',
    sigma: '"What if Java, but good?" is a clear mission, but it\'s defined in opposition to something else rather than from first principles. The pragmatic "fix everything" approach is coherent but doesn\'t have the singular philosophical punch of Rust or Clojure.',
  },
  fsharp: {
    phi: 'Significant whitespace, pipeline operators, and concise type definitions give F# a clean, proportional visual feel. Pattern matching arms align naturally. Less visual noise than C# by a wide margin.',
    omega: 'MetaLanguage-family heritage gives F# deep mathematical roots. Computation expressions, active patterns, and type providers enable algorithm expression that approaches Hardy\'s "economy" criterion.',
    lambda: 'The pipeline operator, discriminated unions, and lack of ceremony make F# remarkably readable. <code>items |&gt; List.filter isValid |&gt; List.map transform</code> reads as a clear chain of intent. One of the most literate typed languages.',
    psi: 'A small, devoted community, but limited industry adoption creates friction, fewer libraries, fewer tutorials, fewer jobs. The .NET ecosystem helps, but F# often feels like a second-class citizen behind C#.',
    gamma: 'Type inference and immutability-by-default produce code that ages reasonably well. The .NET interop story is good. Docked because the ecosystem\'s size means patterns and libraries are less battle-tested than in larger communities.',
    sigma: '"Functional-first on .NET" is a clear, focused vision that Don Syme has maintained consistently. F# knows what it is and doesn\'t try to be everything. The design is opinionated in the right ways.',
  },
  gleam: {
    phi: 'Clean syntax with no semicolons, no null, no exceptions. The visual layout is consistent and uncluttered. Gleam code has the proportional clarity of a well-organized document.',
    omega: 'Deliberately simple, no higher-kinded types, no advanced abstractions. Gleam trades mathematical power for clarity. The design is intentional, but it limits the ceiling for algorithmic elegance compared to Haskell or OCaml.',
    lambda: 'Explicit, predictable, and readable. Every value is named, every path is visible. Not as fluent as Ruby or Elixir in "reads-like-prose" terms, but the absence of magic makes intent self-evident.',
    psi: 'Stack Overflow\'s #2 "Most Admired" at 70%. For a language that hit 1.0 in 2024, the community love is extraordinary. The compiler\'s error messages are famously friendly.',
    gamma: 'No null, no exceptions, no implicit behavior means fewer surprises as codebases grow. The radical simplicity is itself a growth-point philosophy, less to go wrong, more room to extend.',
    sigma: '"Radical simplicity." Every feature omission is a deliberate design statement. Louis Pilfold\'s vision is crystal clear: a language where the right thing is the only thing. Few languages this young have this much conceptual integrity.',
  },
  clojure: {
    phi: 'Clojure\'s parentheses-heavy syntax is unconventional, but it\'s regular and tree-like. The uniform <code>(verb noun noun)</code> structure has its own geometric coherence once you internalize the visual grammar. Not chaotic, just non-traditional.',
    omega: 'Homoiconicity (code is data) enables metaprogramming that feels mathematical. Persistent data structures, lazy sequences, and transducers let you express algorithms with remarkable economy. Among the most "Book", like in practice.',
    lambda: 'Threading macros (<code>-&gt;</code>, <code>-&gt;&gt;</code>) transform nested Lisp into readable pipelines. The data-oriented philosophy, plain maps and vectors over custom types, makes intent transparent. Prefix notation is a barrier for newcomers, but the idioms are clear once learned.',
    psi: 'A devoted, intellectually engaged community. The REPL-driven workflow induces genuine flow states. The ecosystem is mature (for its size). Docked because the community is small and Lisp-family syntax creates a real adoption barrier.',
    gamma: 'Immutable data and pure functions produce code that is inherently easy to extend and modify, no hidden state to trip over. Rich Hickey\'s "simple made easy" philosophy is the definition of habitable design.',
    sigma: '"Code is data. Data is code. Everything is immutable." Clojure is distilled philosophy, every design choice follows from a handful of axioms. Rich Hickey\'s talks are effectively the language\'s specification, and the language is the talks made concrete.',
  },
  swift: {
    phi: 'Swift\'s syntax is visually clean and well-proportioned, closures, guard statements, and trailing closure syntax create a natural reading flow. Apple\'s design obsession shows in the visual weight of the code.',
    omega: 'Generics, protocol extensions, and enum-associated values support expressive algorithm design. Not in the functional-language Omega tier, but protocol-oriented programming enables elegant domain modeling.',
    lambda: 'Named parameters, guard clauses, and descriptive API naming conventions (inherited from Objective-C culture) make Swift code read clearly. <code>array.filter { $0.isValid }.map { $0.name }</code> communicates intent directly.',
    psi: 'Strong satisfaction among iOS/macOS developers. Swift Playgrounds and Xcode integration create pleasant workflows. Docked because the ecosystem is Apple-locked, and build times plus ABI stability issues have caused real friction.',
    gamma: 'Protocol-oriented design encourages extensible architecture. Codebases can grow along protocol boundaries. Docked because Apple\'s rapid language evolution (Swift 1→6) has imposed migration costs, and the tight platform coupling limits organic growth beyond Apple\'s garden.',
    sigma: '"Safe, fast, expressive" with protocol-oriented programming as a distinctive paradigm. The design is opinionated, but Apple\'s commercial interests and platform-specific priorities dilute the pure language-design vision.',
  },
  ocaml: {
    phi: 'Pattern matching, <code>let</code> bindings, and module signatures create a structured visual feel. Clean but not striking, the syntax is functional without being visually adventurous.',
    omega: 'MetaLanguage-family heritage gives OCaml one of the most expressive type systems in existence. GADTs, functors, and first-class modules enable algorithm expression that approaches mathematical proof. Type theory pioneers use OCaml for a reason.',
    lambda: 'The <code>|&gt;</code> operator, descriptive module paths, and pattern matching make OCaml code readable to anyone familiar with ML conventions. The language communicates structure and intent through types rather than comments.',
    psi: 'A small community with niche adoption. Tooling has improved dramatically (opam, dune, Merlin), but the ecosystem remains thin compared to mainstream languages. Practitioners love it deeply, but they are few.',
    gamma: 'Strong types and module boundaries help code age well. The functors system enables reusable, extensible abstractions. Docked because the ecosystem\'s small size means fewer established patterns for common problems.',
    sigma: 'OCaml has always known what it is: a practical functional language with an exceptional type system. The design is focused and coherent, types as the organizing principle, everything else in service of that.',
  },
  scala: {
    phi: 'Case classes, pattern matching, and for-comprehensions produce visually clean code. The layout can be elegant. Docked because Scala\'s flexibility means visual style varies wildly between codebases and teams.',
    omega: 'Higher-kinded types, implicits (now <code>given</code>/<code>using</code>), and for-comprehensions give Scala deep mathematical expressiveness. Capable of Haskell-tier abstraction when used by expert practitioners.',
    lambda: 'At its best, Scala reads clearly, <code>users.filter(_.isActive).map(_.name)</code>. At its worst, implicit resolution chains create invisible logic. The gap between readable and opaque Scala is wider than most languages.',
    psi: 'Respected but not beloved by the wider developer community. Build times, the Scala 2→3 migration pain, and the steep learning curve for advanced features create real friction. The community is engaged but fragmented.',
    gamma: 'The "better Java" vs. "Haskell on JVM" community split means codebases lack stylistic consensus. The Scala 2→3 migration has caused real ecosystem pain. Complex implicit resolution chains make codebases brittle to modify. Long-term habitability is uneven.',
    sigma: 'Scala tries to unify OOP and FP at maximum power, resulting in a language with two souls rather than one. The Scala 2→3 evolution signals that even the designer\'s vision has shifted. Multi-paradigm breadth weakens the single coherent "language soul" that Sigma measures.',
  },
  go: {
    phi: '<code>gofmt</code> produces the most visually uniform code of any language. Every Go file looks the same. Enforced formatting eliminates style debates entirely, this is the Bauhaus ideal realized through tooling.',
    omega: 'Go deliberately avoids mathematical abstraction. No generics (until recently, and limited), no algebraic types, no higher-order patterns. Algorithms in Go are written out explicitly, which is the opposite of Hardy\'s "economy." The philosophy is valid, but Omega measures what it measures.',
    lambda: 'Go is verbose but never confusing. There is zero ambiguity about what any line does. <code>if err != nil</code> is noise, but the signal-to-noise ratio on <em>intent</em> is actually quite high because the language has so few constructs. "Technical manual" clarity, not literary, but reliably communicative.',
    psi: 'Excellent tooling (<code>go fmt</code>, <code>go vet</code>, <code>go test</code>, <code>go mod</code>), fast compilation, and simplicity that induces flow states. Docked from higher because the enforced simplicity can feel constraining, and the <code>if err != nil</code> repetition is a genuine pain point.',
    gamma: 'Go codebases are among the most maintainable in any language. The limited feature set means less stylistic drift over time. New developers can contribute immediately. Code ages gracefully because there\'s only one way to write it.',
    sigma: '"Simplicity is complicated." Rob Pike and Ken Thompson\'s vision is razor-sharp: remove every feature that isn\'t essential. Go is the most opinionated language about what it <em>won\'t</em> do, and that discipline is itself a form of conceptual integrity.',
  },
  julia: {
    phi: 'Unicode operators, mathematical notation support, and clean function definitions give Julia a visual feel closer to mathematics than most languages. Matrix operations look like textbook equations.',
    omega: 'Multiple dispatch as the core paradigm enables elegant mathematical abstractions. Julia\'s type system lets you write generic algorithms that specialize naturally. Scientific algorithms can approach "Book" elegance.',
    lambda: 'Julia reads clearly for scientific audiences, broadcasting syntax, comprehensions, and mathematical operators make domain intent visible. Less clear for general-purpose tasks outside its scientific home turf.',
    psi: 'Loved by its scientific computing community. The "two-language problem" solution is real and appreciated. Docked because time-to-first-plot latency, package precompilation times, and ecosystem maturity create friction.',
    gamma: 'Multiple dispatch and scientific workflow patterns age more gracefully than originally credited. Julia codebases tend to grow organically along domain boundaries — new methods extend existing types naturally without modification.',
    sigma: '"Solve the two-language problem" is a clear mission, and multiple dispatch as the unifying principle is distinctive. Docked because the "be Python, R, and Fortran simultaneously" ambition stretches the conceptual focus.',
  },
  zig: {
    phi: 'Clean and minimal but not visually distinctive. Zig code is functional and well-structured, but the syntax doesn\'t create the kind of visual rhythm that scores above 7. Workmanlike layout.',
    omega: '<code>comptime</code> is genuinely clever, compile-time code generation without metaprogramming complexity. The approach to generics and allocators is elegant in a systems-programming context, though not mathematically abstract.',
    lambda: 'Explicit by design, no hidden control flow, no hidden allocators. This makes code predictable but verbose. You always know what\'s happening, but you\'re reading more to know it.',
    psi: 'Growing admiration in the systems programming community. The compiler\'s error messages are good, and the community is enthusiastic. Still young enough that tooling and ecosystem maturity lag behind established languages.',
    gamma: 'Zig\'s explicitness makes code predictable to modify but also verbose to evolve. The language removes footguns but doesn\'t actively create growth-point idioms. Habitable by being unsurprising rather than by being inviting.',
    sigma: '"No hidden control flow, no hidden memory allocators." Andrew Kelley\'s vision is sharp and consistent. Every design choice follows from the principle that implicit behavior is the enemy. A focused, opinionated systems language.',
  },
  typescript: {
    phi: 'Inherits JavaScript\'s visual structure, which is functional but unremarkable. Generic type annotations and complex union types can create visual density. Not ugly, but not architecturally striking.',
    omega: 'Conditional types, mapped types, and template literal types are genuinely innovative, the type system is more expressive than most mainstream languages. But the underlying JS runtime prevents the mathematical "economy" that Omega measures.',
    lambda: 'TypeScript improves on JavaScript\'s readability significantly, type annotations as documentation, discriminated unions for intent, and strong IDE support make code self-explanatory. A clear upgrade in linguistic clarity.',
    psi: 'Consistently scores ~73% admired in Stack Overflow surveys. The VS Code integration is best-in-class, and catching bugs at compile time is genuinely satisfying. Developers actively choose TypeScript over JavaScript.',
    gamma: 'Gradual typing means you can introduce TypeScript incrementally. Codebases grow naturally from loose to strict. The <code>any</code> escape hatch is ugly but pragmatically habitable, you can always tighten later.',
    sigma: 'TypeScript has evolved beyond "typed JavaScript" into its own identity. The type system is a language-within-a-language with a coherent mission: add sound typing to JS without breaking compatibility. Still inherits some of JavaScript\'s conceptual chaos, but the mission itself is clear and focused.',
  },
  c: {
    phi: 'C code can be visually clean, function signatures, struct definitions, and <code>#define</code> blocks have a spare, architectural quality. But pointer notation, preprocessor macros, and manual memory management create visual noise.',
    omega: 'Algorithms in C are explicit and transparent, you can see every machine operation. This clarity has its own elegance, but the manual machinery (<code>malloc</code>, <code>sizeof</code>, <code>void*</code> casts) obscures the mathematical intent. Power, not economy.',
    lambda: 'C communicates what the <em>machine</em> is doing, not what the <em>programmer</em> intends. Skilled C programmers write beautifully clear code, but the language itself doesn\'t guide you toward Knuthian "wit." You earn clarity; it\'s not given.',
    psi: 'Respected but not loved. Debugging segfaults, managing memory manually, and undefined behavior create constant friction. The tooling ecosystem is mature but the developer experience is unforgiving.',
    gamma: 'C\'s simplicity means codebases <em>can</em> age well, and many have (Linux kernel, SQLite). But the lack of safety guardrails makes modification risky, one wrong pointer and you\'re debugging memory corruption. Habitable for experts, hostile to newcomers.',
    sigma: '"Trust the programmer." Dennis Ritchie\'s design philosophy is one of the clearest and most consistent in computing history. Every C feature follows from the idea that the programmer should have direct, unsupervised access to the machine.',
  },
  lua: {
    phi: 'Lua\'s minimal syntax, <code>function</code>, <code>end</code>, <code>local</code>, tables, creates clean, visually proportional code. The lack of punctuation noise gives it a quiet, uncluttered feel. Small but well-composed.',
    omega: 'Lua is deliberately simple. Tables as the single data structure are elegant in concept, but the language doesn\'t provide tools for abstract mathematical expression. Practical economy rather than mathematical economy.',
    lambda: 'Lua reads simply and directly for small scripts. The table-as-everything paradigm is clear once understood. Docked because the lack of distinct data structures (no arrays, no classes, just tables) can make larger codebases harder to read.',
    psi: 'Appreciated by game developers and embedded systems programmers. The embedding experience is seamless. But as a standalone language, the ecosystem is thin and the community is niche.',
    gamma: 'Lua\'s tiny footprint and simple embedding API make it exceptionally habitable in its niche, you can drop it into any C/C++ project. Metatables allow organic extension. Code accommodates change well within its scope.',
    sigma: '"Small, fast, embeddable." Lua knows exactly what it is and stays in its lane. The design is coherent and focused. Docked slightly because the minimalism is more pragmatic than philosophical — it\'s simple because it needs to be small, not because simplicity is the point.',
  },
  dart: {
    phi: 'Dart\'s syntax is clean and visually familiar to Java/JavaScript developers. Flutter\'s widget tree syntax, with its trailing commas and nested constructors, has a structured, tree-like visual geometry.',
    omega: 'Dart is a pragmatic language without strong mathematical abstractions. It does what it needs to for UI programming. Generics and async/await are useful but not mathematically elegant.',
    lambda: 'Readable and predictable. Named parameters, cascade notation (<code>..</code>), and clear class syntax make intent visible. Not particularly literary, but consistently clear.',
    psi: 'Flutter developers generally enjoy the experience. Hot reload is a genuine joy. The language itself is pleasant enough, but Dart\'s identity is inseparable from Flutter, outside that context, enthusiasm drops significantly.',
    gamma: 'Dart codebases grow well within the Flutter paradigm. The widget composition model encourages incremental, modular extension. Sound null safety (added retroactively) improved long-term maintainability.',
    sigma: 'Dart\'s identity crisis, initially a web language, then reborn as a Flutter companion, weakens its conceptual integrity. It\'s a good language in service of a framework, not a language with its own philosophical center.',
  },
  csharp: {
    phi: 'C# has reduced ceremony significantly with top-level statements, records, and file-scoped namespaces. But the language\'s Java-era heritage still shows in verbose patterns, property accessors, attribute decorations, and <code>using</code> blocks add visual weight. Improving, but not yet clean.',
    omega: 'LINQ is genuinely elegant, embedding query algebra into the type system is a real achievement. Pattern matching in C# 11+ is increasingly expressive. But the OOP substrate limits how close algorithms can get to mathematical notation.',
    lambda: 'Modern C# reads well, async/await patterns are clear, LINQ chains communicate intent, and named arguments help. The language has steadily improved its Knuthian "wit" with each version.',
    psi: 'Modern .NET is a pleasure to use, excellent tooling (Rider, VS Code, hot reload), rapid language evolution, and an engaged community. Stack Overflow admiration is solid and improving. The "corporate Java clone" reputation is outdated but sticky, and the developer experience has genuinely earned a higher mark than the old perception suggests.',
    gamma: 'C#\'s backward compatibility and incremental feature additions mean codebases can adopt new patterns gradually. The ecosystem is mature and battle-tested. Docked because the language\'s breadth (OOP + FP + async + LINQ + dynamic) means codebases vary widely in style.',
    sigma: 'Anders Hejlsberg has maintained a clearer vision than most credit, async/await, LINQ, and pattern matching feel <em>designed</em> rather than patched on. But the steady feature accumulation over 25 years does dilute the singular "language soul." C# is coherent, not focused.',
  },
  r: {
    phi: 'R code can be clean within the tidyverse idiom, but base R\'s syntax (the <code>$</code>, <code>[[]]</code>, <code>&lt;-</code> operator) is visually noisy. The language has two competing visual styles that coexist uneasily.',
    omega: 'Within its domain, R achieves genuine mathematical elegance. Vectorized operations, the pipe operator, and ggplot2\'s grammar of graphics are beautiful statistical expressions. The math-to-code mapping for statistics is among the shortest in any language.',
    lambda: 'The tidyverse reads remarkably well for data analysis pipelines. Base R is less clear, inconsistent naming (<code>read.csv</code> vs. <code>readLines</code>), formula syntax, and the <code>~</code> operator create a readability barrier outside the statistical domain.',
    psi: 'Statisticians and data scientists appreciate R\'s domain power. But the language has significant usability friction — cryptic error messages, the CRAN submission process, and the base-R vs. tidyverse cultural split. Many users tolerate rather than love it.',
    gamma: 'Within statistical workflows, R code extends naturally. But the language\'s quirks (1-indexed, <code>&lt;-</code> vs <code>=</code>, copy-on-modify semantics) make general-purpose code fragile. The gap between "R for stats" and "R for anything else" is stark.',
    sigma: '"By statisticians, for statisticians" is a clear origin, but R has accumulated features and paradigms without a strong unifying vision. The language is a collection of good ideas from different eras rather than a coherent whole.',
  },
  java: {
    phi: 'Java code is visually heavy, class wrappers, access modifiers, type declarations, and boilerplate create dense blocks. Modern Java (records, sealed classes) helps, but the language\'s verbosity is structural, not stylistic.',
    omega: 'Java\'s OOP-first design resists mathematical abstraction. Expressing algorithms requires ceremony, <code>AbstractFactory</code>, <code>Iterator</code>, <code>Consumer&lt;T&gt;</code>. The patterns are powerful but the opposite of Hardy\'s "economy."',
    lambda: 'Java communicates intent through names and types, but the signal is buried under ceremony. <code>AbstractSingletonProxyFactoryBean</code> communicates structure but not <em>wit</em>. Java code is precise, but reading it is work.',
    psi: 'Widely used, rarely loved. Stack Overflow admiration is moderate. The ecosystem is massive and mature, but developer experience surveys consistently place Java in the "tolerated" category. The JVM is respected; the language syntax is endured.',
    gamma: 'Java\'s greatest strength: codebases survive decades. Backward compatibility is nearly absolute. Enterprise patterns, for all their verbosity, create predictable structures that large teams can maintain. Java is habitable in the way a well-run office building is habitable.',
    sigma: '"Write once, run anywhere" was a clear mission, and the JVM delivered. But decades of committee-driven feature additions (generics via erasure, streams, modules, records) have layered paradigms without fully integrating them. Coherent enough, not focused.',
  },
  javascript: {
    phi: 'JavaScript\'s visual style depends entirely on the developer and framework. The language itself imposes no visual discipline. Curly braces, callbacks, and framework-specific patterns create inconsistent visual texture across codebases.',
    omega: 'First-class functions, closures, and prototype chains enable some elegant patterns. Array methods (<code>.map</code>, <code>.reduce</code>, <code>.filter</code>) are expressive. But the language provides too many ways to do everything, and none feel mathematically inevitable.',
    lambda: 'Modern JavaScript (ES6+) reads reasonably well — arrow functions, destructuring, and template literals improve clarity. Docked because <code>typeof null === \'object\'</code>, implicit coercion, and <code>this</code> binding make code that <em>looks</em> clear but <em>behaves</em> surprisingly.',
    psi: 'JavaScript is everywhere, and many developers use it because they must, not because they love it. The ecosystem\'s churn (framework fatigue) creates constant friction. Individual tools (React, Node) are liked; the language itself gets mixed reviews.',
    gamma: 'JavaScript\'s flexibility means codebases <em>can</em> be extended organically. The ecosystem\'s dynamism keeps things evolving. But the same flexibility produces wildly inconsistent patterns, and the lack of guardrails makes long-term maintenance unpredictable.',
    sigma: 'Famously designed in 10 days with no unified vision. Decades of backward-compatible additions have layered prototypal OOP, functional patterns, class syntax, modules, and async models on top of each other. JavaScript is the archetypal "accumulated rather than designed" language.',
  },
  cpp: {
    phi: 'Template metaprogramming, <code>#include</code> chains, and nested angle brackets (<code>std::vector&lt;std::pair&lt;int, std::string&gt;&gt;</code>) create some of the most visually dense code in any language. Modern C++ is cleaner, but the language\'s visual floor is very low.',
    omega: 'C++ is Turing-complete at compile time. Template metaprogramming and concepts (C++20) enable powerful abstractions. The mathematical capability is real, but <code>std::transform(v.begin(), v.end(), v.begin(), [](int x){ return x*x; })</code> vs. Haskell\'s <code>map (^2) v</code> tells the story, the machinery is always visible.',
    lambda: 'Modern C++ is more readable than legacy C++, but the language\'s accumulated complexity means any line might require knowing 10 different features. Range-based for loops and structured bindings help, but the cognitive load of "which C++ era is this?" persists.',
    psi: 'Respected for power, rarely enjoyed for developer experience. Build systems, header management, cryptic template error messages, and undefined behavior create constant friction. Developers use C++ because nothing else does what it does, not because they prefer it.',
    gamma: 'Adding a feature to a C++ codebase can require understanding templates, RAII, move semantics, and exception safety simultaneously. The language\'s complexity makes modification risky. Codebases tend to become more brittle over time as layers of C++ eras accumulate.',
    sigma: '"C with classes" was a clear idea, but 40+ years of committee additions have layered paradigms without full integration. C++11/14 brought more coherence (RAII, value semantics, move), but the language remains a cathedral built by many architects across many centuries.',
  },
  php: {
    phi: '<code>$</code> on every variable, <code>-&gt;</code> for method calls, inconsistent brace styles across frameworks, and <code>&lt;?php</code> tags create visual clutter. Modern PHP (8.x) with named arguments and match expressions is cleaner, but the legacy visual debt remains.',
    omega: 'PHP is a templating language that grew into a general-purpose one. Array functions exist but lack the composability of functional languages. Mathematical elegance is not the design space PHP occupies.',
    lambda: 'PHP can be readable in modern frameworks (Laravel\'s fluent syntax reads well). But <code>str_replace</code> vs. <code>strpos</code> vs. <code>substr</code>, inconsistent parameter ordering, and the legacy API are the antithesis of linguistic clarity. Two PHPs coexist: modern and legacy.',
    psi: 'PHP developers themselves joke about PHP. The community is large and productive, but "most admired" it is not. Modern PHP (8.x with Laravel) has improved the experience significantly, but the reputation, and the daily reality of legacy code, weighs on happiness.',
    gamma: 'PHP codebases survive, 77% of the web runs on PHP, and that code keeps working. The language is pragmatically habitable. But the inconsistent standard library and multiple paradigm shifts (procedural → OOP → modern PHP) make long-term evolution uneven.',
    sigma: 'PHP was not designed; it was accumulated. Rasmus Lerdorf\'s personal homepage tools grew into a language without a coherent philosophy. Each version has improved quality, but there is no "soul", no single idea that all features follow from. The quintessential committee language.',
  },
};
